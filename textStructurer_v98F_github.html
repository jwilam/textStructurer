<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Structurer Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #f5f5f5;
        }

        .container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        /* Left Panel */
        .left-panel {
            width: 40%;
            min-width: 200px;
            max-width: 80%;
            background: white;
            border-right: 2px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: none;
            position: relative;
            flex-shrink: 0;
            z-index: 100;
        }

        .left-panel.collapsed {
            width: 0;
            min-width: 0;
            border-right: none;
            overflow: hidden;
        }

        /* Resizer */
        .resizer {
            width: 8px;
            background: #ddd;
            cursor: col-resize;
            position: relative;
            flex-shrink: 0;
            transition: background 0.2s;
            z-index: 100;
        }

        .resizer:hover {
            background: #3498db;
        }

        .resizer.resizing {
            background: #2980b9;
        }

        .resizer.hidden {
            display: none;
        }

        .panel-header {
            padding: 20px;
            background: #2c3e50;
            color: white;
        }

        /* BULLETPROOF UI TITLES */
        .panel-header h1 {
            font-size: 20px !important;
            margin-bottom: 5px !important;
            color: white !important;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
            font-weight: 600 !important;
        }

        .panel-header p {
            font-size: 13px !important;
            opacity: 0.9 !important;
            margin-top: 5px !important;
            color: white !important;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-download {
            background: #9b59b6;
            color: white;
        }

        .btn-download:hover {
            background: #8e44ad;
        }

        #fileInput, #loadProjectInput, #htmlFileInput {
            display: none;
        }

        /* Unified Tab Container with Scrolling */
        .unified-tab-container {
            background: #2c3e50;
            padding: 0 20px;
            display: flex;
            gap: 5px;
            border-bottom: 2px solid #1a252f;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: #34495e #2c3e50;
            z-index: 10;
            position: relative;
        }

        .unified-tab-container::-webkit-scrollbar {
            height: 6px;
        }

        .unified-tab-container::-webkit-scrollbar-track {
            background: #2c3e50;
        }

        .unified-tab-container::-webkit-scrollbar-thumb {
            background: #34495e;
            border-radius: 3px;
        }

        .unified-tab-container::-webkit-scrollbar-thumb:hover {
            background: #4a5f7f;
        }

        .unified-tab {
            padding: 10px 20px;
            background: #1a252f;
            color: #95a5a6;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .unified-tab:hover {
            background: #34495e;
            color: white;
        }

        .unified-tab.active {
            background: white;
            color: #2c3e50;
            font-weight: bold;
        }

        .unified-tab.text-tab .close-btn {
            color: #e74c3c;
            font-weight: bold;
            font-size: 16px;
            margin-left: 4px;
        }

        .unified-tab.text-tab .close-btn:hover {
            color: #c0392b;
        }

        .new-text-tab-btn {
            padding: 10px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .new-text-tab-btn:hover {
            background: #2980b9;
        }

        .unified-tab.special-tab {
            background: #16a085;
            color: white;
        }

        .unified-tab.special-tab:hover {
            background: #1abc9c;
        }

        .unified-tab.special-tab.active {
            background: white;
            color: #16a085;
        }

        .left-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .left-page {
            display: none;
            flex: 1;
            overflow-y: auto;
        }

        .left-page.active {
            display: flex;
            flex-direction: column;
        }

        /* Text Pages Container */
        .text-pages-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .text-page {
            display: none;
            height: 100%;
            overflow-y: auto;
        }

        .text-page.active {
            display: block;
        }

        .text-area {
            min-height: 100%;
            padding: 20px;
            line-height: 1.8;
            font-size: 16px;
            user-select: text;
            white-space: normal;
            word-wrap: break-word;
        }

        .text-area:empty:before {
            content: "Paste HTML content or upload an HTML file here...";
            color: #999;
        }

        /* Support for HTML content in text-area */
        .text-area img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px 0;
        }

        .text-area table {
            border-collapse: collapse;
            margin: 10px 0;
            width: 100%;
        }

        .text-area table td, .text-area table th {
            border: 1px solid #ddd;
            padding: 8px;
        }

        .text-area table th {
            background-color: #f2f2f2;
        }

        .text-area p {
            margin-bottom: 10px;
        }

        .text-area h1, .text-area h2, .text-area h3, 
        .text-area h4, .text-area h5, .text-area h6 {
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .text-area ul, .text-area ol {
            margin-left: 30px;
            margin-bottom: 10px;
        }

        .text-area blockquote {
            border-left: 4px solid #ddd;
            padding-left: 15px;
            margin: 10px 0;
            color: #666;
        }

        /* Scrollbar styling for text area */
        .text-page::-webkit-scrollbar {
            width: 12px;
        }

        .text-page::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .text-page::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 6px;
        }

        .text-page::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Key information highlighting - bold and red */
        .key-text {
            color: #e74c3c;
            font-weight: bold;
        }

        /* Main Idea and Edgelist Pages */
        .data-page {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .data-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .data-display {
            flex: 1;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .data-display:empty:before {
            content: "Click 'Refresh' to load data...";
            color: #999;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .data-line {
            margin-bottom: 8px;
            padding: 5px;
            border-left: 3px solid #3498db;
            padding-left: 10px;
        }

        .data-line.highlight {
            background-color: #fff9e6;
        }
		
		/* ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: W-NETWORK TOGGLE BUTTON ‚≠ê‚≠ê‚≠ê */
.data-controls .btn-toggle {
    background: #16a085;
    color: white;
}

.data-controls .btn-toggle:hover {
    background: #1abc9c;
}
/* ============================================================================ */
		
		/* ============================================================================ */
/* Info Tab Styles - Compact and Clean */
/* ============================================================================ */

.info-placeholder {
    color: #999;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-style: italic;
    text-align: center;
    padding: 40px 20px;
}

.info-content-wrapper {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.info-content-wrapper h2 {
    color: #2c3e50;
    margin-bottom: 15px;
    font-size: 20px;
}

.info-content-wrapper > p {
    margin-bottom: 12px;
    color: #555;
    line-height: 1.6;
}

.info-content-wrapper h3 {
    color: #3498db;
    margin-top: 20px;
    margin-bottom: 8px;
    font-size: 16px;
    padding-bottom: 5px;
    border-bottom: 2px solid #3498db;
}

.info-content-wrapper h3.stopwords-chinese {
    color: #e74c3c;
    border-bottom-color: #e74c3c;
}

.info-content-wrapper h3.stopwords-custom {
    color: #27ae60;
    border-bottom-color: #27ae60;
}

.info-stopwords-list {
    font-family: 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.4;
    color: #2c3e50;
    margin-top: 8px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 4px;
    max-height: 400px;
    overflow-y: auto;
}

.info-stopwords-list::-webkit-scrollbar {
    width: 8px;
}

.info-stopwords-list::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.info-stopwords-list::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

.info-stopwords-list::-webkit-scrollbar-thumb:hover {
    background: #555;
}

.info-no-data {
    color: #999;
    font-style: italic;
    text-align: center;
    padding: 20px;
}

/* ‚≠ê‚≠ê‚≠ê PHASE 4.2: NODELIST & SETTINGS STYLES ‚≠ê‚≠ê‚≠ê */

/* Settings visibility toggle */
#symbolSettings, #windowSettings {
    transition: opacity 0.3s ease, max-height 0.3s ease;
}

/* Nodelist display - similar to edgelist */
#nodelistDisplay {
    font-family: 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.8;
    white-space: pre-wrap;
    word-wrap: break-word;
}

#nodelistDisplay .data-line {
    margin-bottom: 8px;
    padding: 5px;
    border-left: 3px solid #27ae60;
    padding-left: 10px;
}

/* ============================================================================ */

        /* Network Analysis Styles */
        .network-container {
            display: flex;
            gap: 20px;
            flex: 1;
            overflow: hidden;
        }

        .network-sidebar {
            width: 300px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .network-graph-container {
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
		
/* Network Graph Canvas specific styles */
#canvas-graph .network-container {
    height: 100%;
    flex: 1;
}

#canvas-graph .network-graph-container {
    flex: 1;
    min-height: 400px;
    height: 100%;
}

#networkGraphCanvas {
    width: 100%;
    height: 100%;
    min-height: 400px;
}		
		

        #networkGraph {
            width: 100%;
            height: 100%;
        }

        .metric-section {
            margin-bottom: 20px;
        }

        .metric-section h3 {
            color: #2c3e50;
            font-size: 14px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #3498db;
        }

        .metric-item {
            padding: 8px;
            margin-bottom: 6px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metric-node {
            font-weight: bold;
            color: #2c3e50;
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .metric-value {
            color: #3498db;
            font-weight: bold;
        }
		
		/* ‚≠ê‚≠ê‚≠ê PHASE 3: SORTABLE TABLE STYLES ‚≠ê‚≠ê‚≠ê */
.metric-section h3 {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 25px;
}

.metric-section h3:hover {
    background: rgba(52, 152, 219, 0.1);
}

.metric-section h3 .sort-arrow {
    position: absolute;
    right: 5px;
    font-size: 12px;
    color: #3498db;
}
/* ============================================================================ */
		

        .network-stats {
            background: #e8f5e9;
            border: 1px solid #4caf50;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .network-stats h3 {
            color: #2e7d32;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .stat-line {
            font-size: 12px;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .stat-line strong {
            color: #2e7d32;
        }

        /* Main Idea Item Styling */
        .main-idea-item {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: white;
            border: 2px solid #f39c12;
            border-radius: 6px;
            cursor: move;
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: flex-start;
            gap: 10px;
            text-align: left;
        }

        .main-idea-item:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }

        .main-idea-item.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }

        .main-idea-item.drag-over {
            border-color: #3498db;
            background-color: #e3f2fd;
        }

        .main-idea-number {
            display: inline-block;
            background: #f39c12;
            color: white;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
            font-size: 13px;
            flex-shrink: 0;
            line-height: 1.4;
        }

        .main-idea-text {
            flex: 1;
            line-height: 1.5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            text-align: left;
            word-wrap: break-word;
            padding-right: 25px;
        }

        .main-idea-source {
            display: inline-block;
            background: #95a5a6;
            color: white;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: bold;
        }

        .drag-handle {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            color: #95a5a6;
            cursor: grab;
            line-height: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .main-idea-empty {
            text-align: center;
            padding: 40px 20px;
            color: #999;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
        }

        /* Collapse Toggle Button */
        .collapse-btn {
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1002;
            background: #2c3e50;
            color: white;
            border: none;
            padding: 20px 6px;
            cursor: pointer;
            border-radius: 0 6px 6px 0;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 2px 0 8px rgba(0,0,0,0.2);
            width: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .collapse-btn:hover {
            background: #34495e;
            padding-right: 8px;
        }

        .left-panel.collapsed .collapse-btn {
            opacity: 0;
            pointer-events: none;
        }

        /* Floating expand button when panel is collapsed */
        .floating-expand {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1002;
            background: #2c3e50;
            color: white;
            border: none;
            padding: 20px 6px;
            cursor: pointer;
            border-radius: 0 6px 6px 0;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 2px 0 8px rgba(0,0,0,0.3);
            width: 20px;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
        }

        .floating-expand.show {
            opacity: 1;
            pointer-events: all;
            display: flex;
        }

        .floating-expand:hover {
            background: #34495e;
            padding-right: 8px;
        }

        /* Right Panel - Canvas */
        .right-panel {
            flex: 1;
            background: #ecf0f1;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }

        .canvas-header {
            padding: 20px;
            background: #34495e;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .canvas-header-left h2 {
            font-size: 20px !important;
            margin-bottom: 5px !important;
            color: white !important;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
            font-weight: 600 !important;
        }

        .canvas-header-left p {
            font-size: 13px !important;
            opacity: 0.9 !important;
            margin-top: 5px !important;
            color: white !important;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
        }

        .canvas-header-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }
		
        /* Button separator style */
        .button-separator {
            width: 2px;
            height: 30px;
            background: rgba(255,255,255,0.3);
            margin: 0 2px;
            flex-shrink: 0;
        }		

        .font-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .font-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
			min-width: 60px;
        }

        .font-btn:hover {
            background: #2980b9;
        }

        .font-size-display {
            color: white;
            font-size: 14px;
            min-width: 40px;
            text-align: center;
        }
		
		/* ZOOM CONTROLS */
		.zoom-controls {
		display: flex;
		gap: 10px;
		align-items: center;
		margin-left: 5px;
		padding-left: 0px;
		}

.zoom-btn {
    background: #16a085;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s;
    min-width: 60px;
}

.zoom-btn:hover {
    background: #1abc9c;
}

.zoom-btn:disabled {
    background: #95a5a6;
    cursor: not-allowed;
    opacity: 0.6;
}

.zoom-display {
    color: white;
    font-size: 14px;
    min-width: 60px;
    text-align: center;
    font-weight: bold;
}

.zoom-reset-btn {
    background: #34495e;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.3s;
}

.zoom-reset-btn:hover {
    background: #2c3e50;
}

/* Zoom transform for canvas */
.canvas-inner.zoomed {
    transform-origin: 0 0;
    transition: transform 0.3s ease;
}

        .canvas-btn {
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .canvas-btn:hover {
            background: #229954;
        }

        .canvas-btn.load {
            background: #3498db;
        }

        .canvas-btn.load:hover {
            background: #2980b9;
        }

        /* Tab System with Scrolling */
        .tab-container {
            background: #34495e;
            padding: 0 20px;
            display: flex;
            align-items: flex-end;
            gap: 5px;
            border-bottom: 2px solid #2c3e50;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: #2c3e50 #34495e;
        }

        .tab-container::-webkit-scrollbar {
            height: 6px;
        }

        .tab-container::-webkit-scrollbar-track {
            background: #34495e;
        }

        .tab-container::-webkit-scrollbar-thumb {
            background: #2c3e50;
            border-radius: 3px;
        }

        .tab-container::-webkit-scrollbar-thumb:hover {
            background: #1a252f;
        }

        .tab {
            padding: 10px 20px;
            background: #2c3e50;
            color: #95a5a6;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            position: relative;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab:hover {
            background: #34495e;
            color: white;
        }

        .tab.active {
            background: #ecf0f1;
            color: #2c3e50;
            font-weight: bold;
        }

        .tab.settings-tab {
            margin-left: auto;
            background: #16a085;
            color: white;
        }

        .tab.help-tab {
            background: #16a085;
            color: white;
        }

        .tab.help-tab:hover {
            background: #1abc9c;
        }

        .tab.help-tab.active {
            background: #ecf0f1;
            color: #16a085;
        }

        .tab .close-btn {
            margin-left: 8px;
            color: #e74c3c;
            font-weight: bold;
            font-size: 16px;
        }

        .tab .close-btn:hover {
            color: #c0392b;
        }

        .new-tab-btn {
            padding: 10px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .new-tab-btn:hover {
            background: #2980b9;
        }

        /* Canvas Area */
        .canvas-content {
            flex: 1;
            position: relative;
            overflow: auto;
        }

        .canvas-page {
            display: none;
            position: relative;
            width: 100%;
            height: 100%;
        }

        .canvas-page.active {
            display: block;
        }

        .canvas-inner {
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }

        .textbox {
            position: absolute;
            min-width: 100px;
            max-width: 800px;
            min-height: 40px;
            padding: 10px;
            padding-right: 2px;
            background: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            cursor: move;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 10;
            display: flex;
            align-items: flex-start;
            gap: 2px;
            overflow: visible;
            transition: background-color 0.3s;
        }

        .textbox:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }

        .textbox.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .textbox.resizing {
            cursor: nwse-resize;
        }

        .textbox.greyed {
            opacity: 0.5;
        }

        .textbox.highlighted {
            /* Background color will be set dynamically via JavaScript */
        }

        .textbox.inferred {
            border-style: dashed !important;
            border-width: 2px !important;
        }

        .textbox-content {
            font-size: 14px;
            line-height: 1.6;
            flex: 1;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            width: 0;
            max-height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 2px;
            transition: color 0.3s;
        }

        .textbox.greyed .textbox-content {
            color: #95a5a6;
        }

        .textbox-content::-webkit-scrollbar {
            width: 6px;
        }

        .textbox-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .textbox-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .textbox-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .textbox-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 5px 0;
        }

        .textbox-actions {
            display: grid;
            grid-template-columns: repeat(2, 24px);
            grid-template-rows: repeat(3, 24px);
            gap: 4px;
            flex-shrink: 0;
            margin-top: 0;
            margin-left: 0;
            margin-right: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
            position: relative;
        }

        .textbox:hover .textbox-actions {
            opacity: 1;
        }

        .icon-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
            background: #ecf0f1;
            flex-shrink: 0;
        }

        .icon-btn:hover {
            transform: scale(1.15);
        }

        .icon-btn.connect {
            color: #3498db;
            grid-column: 1;
            grid-row: 1;
        }

        .icon-btn.connect:hover {
            background: #3498db;
            color: white;
        }

        .icon-btn.grey {
            color: #95a5a6;
            grid-column: 2;
            grid-row: 1;
        }

        .icon-btn.grey:hover {
            background: #95a5a6;
            color: white;
        }

        .icon-btn.grey.active {
            background: #95a5a6;
            color: white;
        }

        .icon-btn.highlight {
            color: #f39c12;
            grid-column: 1;
            grid-row: 2;
            position: relative;
        }

        .icon-btn.highlight:hover {
            background: #f39c12;
            color: white;
        }

        .icon-btn.highlight.active {
            background: #f39c12;
            color: white;
        }

.color-palette {
    position: absolute;
    top: 100%;
    left: 0;
    margin-top: 4px;
    background: white;
    border: 2px solid #f39c12;
    border-radius: 6px;
    padding: 8px;
    display: none;
    grid-template-columns: repeat(5, 24px);
    gap: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 1000;
}

.color-palette.show {
    display: grid;
}

/* ‚≠ê NEW: X button to close palette */
.color-palette-close {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 20px;
    height: 20px;
    background: #e74c3c;
    color: white;
    border: 2px solid white;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    line-height: 1;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.color-palette-close:hover {
    background: #c0392b;
}

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.2);
            border-color: #2c3e50;
        }

        .color-option.selected {
            border-color: #2c3e50;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #2c3e50;
        }

        .icon-btn.delete {
            color: #e74c3c;
            grid-column: 2;
            grid-row: 2;
        }

        .icon-btn.delete:hover {
            background: #e74c3c;
            color: white;
        }

        .icon-btn.infer {
            color: #9b59b6;
            grid-column: 1;
            grid-row: 3;
        }

        .icon-btn.infer:hover {
            background: #9b59b6;
            color: white;
        }

        .icon-btn.infer.active {
            background: #9b59b6;
            color: white;
        }

        .source-id-label {
            grid-column: 2;
            grid-row: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #34495e;
            background: #ecf0f1;
            border-radius: 3px;
            padding: 2px;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #3498db 50%);
            border-bottom-right-radius: 6px;
        }

        .resize-handle:hover {
            background: linear-gradient(135deg, transparent 50%, #2980b9 50%);
        }

        svg.connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        svg line, svg path, svg polyline {
            pointer-events: stroke;
            cursor: pointer;
        }

        .dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .dialog-overlay.active {
            display: flex;
        }

        .dialog {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            min-width: 300px;
            max-width: 500px;
        }

        .dialog h3 {
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .relation-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .relation-btn {
            padding: 12px;
            border: 2px solid #3498db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .relation-btn:hover {
            background: #3498db;
            color: white;
        }

        .custom-label-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: 2px solid #34495e;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .custom-label-container label {
            font-size: 14px;
            color: #2c3e50;
            white-space: nowrap;
        }

        .custom-label-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .custom-label-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .dialog-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .cancel-btn, .delete-connection-btn {
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
        }

        .cancel-btn {
            background: #95a5a6;
            color: white;
        }

        .cancel-btn:hover {
            background: #7f8c8d;
        }

        .delete-connection-btn {
            background: #e74c3c;
            color: white;
        }

        .delete-connection-btn:hover {
            background: #c0392b;
        }

        .connection-label-group {
            pointer-events: all;
            cursor: pointer;
        }

        .connection-label {
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            background: white;
            border: 1px solid #3498db;
            border-radius: 3px;
            pointer-events: all;
            cursor: pointer;
            display: inline-block;
        }

        .direction-btn {
            font-size: 11px;
            padding: 2px 6px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 4px;
            pointer-events: all;
        }

        .direction-btn:hover {
            background: #2980b9;
        }

        .help-content {
            padding: 30px;
            overflow-y: auto;
            height: 100%;
            background: white;
        }

        .help-content h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .help-content h3 {
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .help-content p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #555;
        }

        .help-content ol, .help-content ul {
            margin-left: 25px;
            margin-bottom: 15px;
            line-height: 1.8;
        }

        .help-content li {
            margin-bottom: 10px;
            color: #555;
        }

        .relation-list {
            list-style: none;
            margin-left: 0;
        }

        .relation-list li {
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .relation-list li strong {
            display: block;
            margin-bottom: 5px;
        }

        .line-type-demo {
            font-size: 12px;
            color: #7f8c8d;
            font-style: italic;
            margin-top: 3px;
        }

        .credits {
            margin-top: 40px;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }

        .credits h3 {
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .credits p {
            margin-bottom: 8px;
            color: #555;
        }

        .drag-preview {
            position: fixed;
            pointer-events: none;
            background: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 300px;
            opacity: 0.8;
            display: none;
        }

        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #27ae60;
            color: white;
            padding: 15px 25px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10001;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Settings Page Styles */
        .settings-page {
            padding: 30px;
        }

        .settings-section {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .settings-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            border-bottom: 1px solid #ecf0f1;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-info {
            flex: 1;
        }

        .setting-info h4 {
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 16px;
        }

        .setting-info p {
            color: #7f8c8d;
            font-size: 13px;
            margin: 0;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 30px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #27ae60;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }

        .toggle-slider:hover {
            background-color: #bbb;
        }

        .toggle-switch input:checked + .toggle-slider:hover {
            background-color: #229954;
        }

        .setting-badge {
            display: inline-block;
            background: #e74c3c;
            color: white;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: bold;
        }

        .textbox.connecting {
            border-color: #2ecc71 !important;
            border-width: 3px !important;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="left-panel" id="leftPanel">
            <div class="panel-header">
                <h1>Text Structurer</h1>
                <p>Based on Bonnie Meyer's Text Structure Framework</p>
                <div class="controls">
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" title="Upload Text File (.txt)">
                        üìÑ
                    </button>
                    <button class="btn btn-primary" onclick="document.getElementById('htmlFileInput').click()" title="Upload HTML File (.html)">
                        üåê
                    </button>
					
					<div class="button-separator"></div>
					
					<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.1: TOKENIZE BUTTON (NEW - before segment) ‚≠ê‚≠ê‚≠ê -->
					<button class="btn btn-success" id="tokenizeBtn" onclick="tokenizeText()" title="Tokenize text in current tab">
						üî§
					</button>
					<!-- ============================================================================ -->
					
					<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.2: DOC2TERM BUTTON ‚≠ê‚≠ê‚≠ê -->
					<button class="btn btn-success" id="doc2termBtn" onclick="createDoc2TermNetwork()" title="Create doc-to-term network from current tab">
						üìä
					</button>
					<!-- ============================================================================ -->
					
					<div class="button-separator"></div>
					
                    <button class="btn btn-warning" id="segmentBtn" onclick="createSegment()" disabled title="Create Segment on Canvas">
                        ‚úÇÔ∏è
                    </button>
					
					<div class="button-separator"></div>
					
                    <button class="btn btn-danger" id="keyBtn" onclick="toggleKeyHighlight()" disabled title="Mark/Unmark as Key Information">
                        üñåÔ∏è
                    </button>
                    <button class="btn btn-secondary" onclick="clearText()" title="Clear Current Text">
                        üóëÔ∏è
                    </button>
                    <input type="file" id="fileInput" accept=".txt" onchange="loadFile(event)">
                    <input type="file" id="htmlFileInput" accept=".html,.htm" onchange="loadHtmlFile(event)">
                </div>
            </div>

            <div class="unified-tab-container" id="unifiedTabContainer">
                <button class="unified-tab text-tab active" data-page-type="text" data-page-id="1" onclick="switchUnifiedTab('text', 1)">
                    Text 1
                    <span class="close-btn" onclick="event.stopPropagation(); closeTextTab(event, 1)">√ó</span>
                </button>
                <button class="new-text-tab-btn" onclick="createNewTextTab()">+</button>

				
<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.2: NODELIST TAB ‚≠ê‚≠ê‚≠ê -->
<button class="unified-tab special-tab" data-page-type="nodelist" onclick="switchUnifiedTab('nodelist', null)">
    W-network
</button>
<!-- ============================================================================ -->				
				
                <button class="unified-tab special-tab" data-page-type="edgelist" onclick="switchUnifiedTab('edgelist', null)">
                    T-network
                </button>
				
				<!-- Re-locate after Edgelist tab, before Info -->
				<button class="unified-tab special-tab" data-page-type="mainidea" onclick="switchUnifiedTab('mainidea', null)">
                    Main Idea
                </button>
				
				<!-- After Main Idea and Edgelist tab, before closing unified-tab-container -->
				<button class="unified-tab special-tab" data-page-type="info" onclick="switchUnifiedTab('info', null)">
					Info
				</button>
				
            </div>

            <div class="left-content">
                <div class="left-page active" id="leftpage-text">
                    <div class="text-pages-container" id="textPagesContainer">
                        <div class="text-page active" id="textpage-1">
                            <div class="text-area" contenteditable="true"></div>
                        </div>
                    </div>
                </div>

                <div class="left-page" id="leftpage-mainidea">
                    <div class="data-page">
                        <div class="data-controls">
                            <button class="btn btn-primary" onclick="refreshMainIdea()">üîÑ Refresh</button>
                            <button class="btn btn-success" onclick="copyMainIdea()">üìã Copy</button>
                        </div>
                        <div class="data-display" id="mainIdeaDisplay"></div>
                    </div>
                </div>
				
<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: W-NETWORK PAGE WITH TOGGLE & NETWORK ANALYSIS ‚≠ê‚≠ê‚≠ê -->
<div class="left-page" id="leftpage-nodelist">
    <div class="data-page">
        <div class="data-controls">
            <button class="btn btn-toggle" id="backToNodelistBtn" onclick="toggleWNetworkView()" style="display: none;">
                üîÑ Back to Nodelist
            </button>
            <button class="btn btn-success" onclick="copyNodelist()">üìã Copy</button>
            <button class="btn btn-download" onclick="downloadNodelist()">üíæ Download CSV</button>
            <button class="btn btn-warning" onclick="performNetworkAnalysis()">üìä Network Analysis</button>
        </div>
        <div class="data-display" id="nodelistDisplay">
            <span style="color: #999;">Click "üìä Create Semantic Network" to generate nodelist data.</span>
        </div>
    </div>
</div>
<!-- ============================================================================ -->

                <div class="left-page" id="leftpage-edgelist">
                    <div class="data-page">
                        <div class="data-controls">
                            <button class="btn btn-primary" onclick="refreshEdgelist()">üîÑ Refresh</button>
                            <button class="btn btn-success" onclick="copyEdgelist()">üìã Copy</button>
                            <button class="btn btn-download" onclick="downloadEdgelist()">üíæ Download CSV</button>
                            <button class="btn btn-warning" onclick="analyzeNetwork()">üìä Network Analysis</button>
                        </div>
                        <div id="edgelistContent">
                            <div class="data-display" id="edgelistDisplay"></div>
                        </div>
                        <div id="networkAnalysisContent" style="display: none; flex: 1; overflow: hidden;">
                            <div class="network-container">
                                <div class="network-sidebar">
                                    <div class="network-stats" id="networkStats"></div>
                                    <div class="metric-section">
                                        <h3>üìç Degree Centrality</h3>
                                        <div id="degreeCentrality"></div>
                                    </div>
                                    <div class="metric-section">
                                        <h3>üîÄ Betweenness Centrality</h3>
                                        <div id="betweennessCentrality"></div>
                                    </div>
                                    <div class="metric-section">
                                        <h3>üéØ Closeness Centrality</h3>
                                        <div id="closenessCentrality"></div>
                                    </div>
                                    <div class="metric-section">
                                        <h3>‚≠ê Eigenvector Centrality</h3>
                                        <div id="eigenvectorCentrality"></div>
                                    </div>
                                </div>
                                <div class="network-graph-container">
                                    <div id="networkGraph"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
				
				<!-- After leftpage-edgelist -->
				<div class="left-page" id="leftpage-info">
					<div class="data-page">
						<div class="data-display" id="infoDisplay">
							<p class="info-placeholder">
								This tab displays platform resources and information. Use "Show Stopwords in Info" button in Settings to view active stopwords, or check here for other platform data.
							</p>
						</div>
					</div>
				</div>
								
            </div>

            <button class="collapse-btn" id="collapseBtn" onclick="togglePanel()">‚óÄ</button>
        </div>

        <div class="resizer" id="resizer"></div>

        <button class="floating-expand" id="floatingExpand" onclick="togglePanel()">‚ñ∂</button>

        <div class="right-panel">
            <div class="canvas-header">
                <div class="canvas-header-left">
                    <!-- Analysis Canvas -->
                    <!-- Drag text segments here and connect them to analyze structure -->
                </div>
                <div class="canvas-header-right">
                    <button class="canvas-btn" onclick="saveProject()" title="Save Entire Project">
                        üíæ Save Project
                    </button>
                    <button class="canvas-btn load" onclick="document.getElementById('loadProjectInput').click()" title="Load Project">
                        üìÇ Load Project
                    </button>
                    <input type="file" id="loadProjectInput" accept=".json" onchange="loadProject(event)">
                    
                    <button class="canvas-btn" id="exportSVGBtn" onclick="exportCanvasAsSVG()" title="Export Current Canvas as SVG" style="display: none;">
                        üì• Export SVG
                    </button>
                    <button class="canvas-btn" onclick="saveCanvasAsImage()" title="Save current view as PNG (Canvas or Graph)">
						üñºÔ∏è Snap PNG
					</button>
					
					<div class="button-separator"></div>
					
                    <div class="font-controls">
                        <button class="font-btn" onclick="decreaseFontSize()" title="Decrease Font Size">A-</button>
                        <span class="font-size-display" id="fontSizeDisplay">16px</span>
                        <button class="font-btn" onclick="increaseFontSize()" title="Increase Font Size">A+</button>
                    </div>
					
					<div class="button-separator"></div>
					
					<div class="zoom-controls">
						<button class="zoom-btn" onclick="zoomOut()" id="zoomOutBtn" title="Zoom Out (Ctrl + -)">üîç-</button>
						<span class="zoom-display" id="zoomDisplay">100%</span>
						<button class="zoom-btn" onclick="zoomIn()" id="zoomInBtn" title="Zoom In (Ctrl + +)">üîç+</button>
						<button class="zoom-reset-btn" onclick="resetZoom()" title="Reset Zoom (Ctrl + 0)">‚Üª</button>
					</div>
                </div>
            </div>

            <div class="tab-container" id="tabContainer">
                <button class="tab active" data-tab="1" onclick="switchTab(1)">
                    Canvas 1
                    <span class="close-btn" onclick="event.stopPropagation(); closeTab(event, 1)">√ó</span>
                </button>
                <button class="new-tab-btn" onclick="createNewTab()">+</button>
				<button class="tab help-tab" data-tab="graph" onclick="switchTab('graph')">üìä Graph</button>
                <button class="tab help-tab" data-tab="settings" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
                <button class="tab help-tab" data-tab="help" onclick="switchTab('help')">‚ùî Help</button>
            </div>

            <div class="canvas-content" id="canvasContent">
                <div class="canvas-page active" id="canvas-1">
                    <div class="canvas-inner">
                        <svg class="connections-svg"></svg>
                    </div>
                </div>

<div class="canvas-page" id="canvas-graph">
    <div style="padding: 20px; height: 100%; display: flex; flex-direction: column; background: white; overflow: hidden;">
        <div class="network-container" style="flex: 1; min-height: 0;">
            <div class="network-sidebar">
                <div class="network-stats" id="networkStatsGraph"></div>
                <div class="metric-section">
                    <h3>üìç Degree Centrality</h3>
                    <div id="degreeCentralityGraph"></div>
                </div>
                <div class="metric-section">
                    <h3>üîÄ Betweenness Centrality</h3>
                    <div id="betweennessCentralityGraph"></div>
                </div>
                <div class="metric-section">
                    <h3>üéØ Closeness Centrality</h3>
                    <div id="closenessCentralityGraph"></div>
                </div>
                <div class="metric-section">
                    <h3>‚≠ê Eigenvector Centrality</h3>
                    <div id="eigenvectorCentralityGraph"></div>
                </div>
				<!-- ‚≠ê‚≠ê‚≠ê PHASE 3: COMMUNITY DETECTION SECTION ‚≠ê‚≠ê‚≠ê -->
				<div class="metric-section" id="communityDetectionSection" style="display: none;">
					<h3 onclick="sortCommunityTable('toggle')">
						üìä Community Detection
						<span class="sort-arrow" id="communitySortArrow"></span>
					</h3>
					<div id="communityDetectionStats" style="margin-bottom: 10px; font-size: 12px; color: #2e7d32;"></div>
					<div id="communityDetectionData"></div>
				</div>
				<!-- ============================================================================ -->
            </div>
            <div class="network-graph-container">
                <div id="networkGraphCanvas"></div>
            </div>
        </div>
    </div>
</div>


<div class="canvas-page" id="canvas-settings">
    <div class="settings-page">
        <h2 style="color: #2c3e50; margin-bottom: 25px;">‚öôÔ∏è Application Settings</h2>
        
        <!-- Network Visualization Settings Section -->
        <div class="settings-section">
            <h3>üìä Network Visualization Settings</h3>
            
<!-- Node Size Setting -->
<div class="setting-item">
    <div class="setting-info">
        <h4>Node Size</h4>
        <p>Choose which centrality metric determines node size in the network graph.</p>
    </div>
    <div style="display: flex; flex-direction: column; gap: 8px; min-width: 180px;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="radio" name="nodeSize" value="degree" checked 
                   onchange="updateNodeSizeSetting(this.value)" 
                   style="cursor: pointer;">
            <span>Degree Centrality</span>
        </label>
        <!-- ‚≠ê PHASE 1: ENABLED BETWEENNESS ‚≠ê -->
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="radio" name="nodeSize" value="betweenness" 
                   onchange="updateNodeSizeSetting(this.value)" 
                   style="cursor: pointer;">
            <span>Betweenness Centrality</span>
        </label>
        <!-- ‚≠ê PHASE 1: ENABLED CLOSENESS ‚≠ê -->
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="radio" name="nodeSize" value="closeness" 
                   onchange="updateNodeSizeSetting(this.value)" 
                   style="cursor: pointer;">
            <span>Closeness Centrality</span>
        </label>
        <!-- ‚≠ê PHASE 1: ENABLED EIGENVECTOR ‚≠ê -->
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="radio" name="nodeSize" value="eigenvector" 
                   onchange="updateNodeSizeSetting(this.value)" 
                   style="cursor: pointer;">
            <span>Eigenvector Centrality</span>
        </label>
    </div>
</div>

<!-- Node Color Setting -->
<div class="setting-item">
    <div class="setting-info">
        <h4>Node Color</h4>
        <p>Color nodes by source text or cluster membership.</p>
    </div>
    <div style="display: flex; flex-direction: column; gap: 8px; min-width: 180px;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="radio" name="nodeColor" value="none" checked 
                   onchange="updateNodeColorSetting(this.value)" 
                   style="cursor: pointer;">
            <span>None (single color)</span>
        </label>
        <!-- ‚≠ê PHASE 2: SOURCE TEXT COLORING ENABLED ‚≠ê -->
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="radio" name="nodeColor" value="source"
                   onchange="updateNodeColorSetting(this.value)" 
                   style="cursor: pointer;">
            <span>Source Text</span>
        </label>
        <!-- ‚≠ê PHASE 3: CLUSTER COLORING ENABLED ‚≠ê -->
		<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			<input type="radio" name="nodeColor" value="cluster-lpa"
				onchange="updateNodeColorSetting(this.value)" 
				style="cursor: pointer;">
			<span>Cluster (LPA - Fast)</span>
		</label>
		<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			<input type="radio" name="nodeColor" value="cluster-louvain"
				onchange="updateNodeColorSetting(this.value)" 
				style="cursor: pointer;">
			<span>Cluster (Louvain - Stable)</span>
		</label>
    </div>
</div>

<!-- Node Shape Setting -->
<div class="setting-item">
    <div class="setting-info">
        <h4>Node Shape</h4>
        <p>Use different shapes to represent source text or cluster membership.</p>
    </div>
    <div style="display: flex; flex-direction: column; gap: 8px; min-width: 180px;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="radio" name="nodeShape" value="circle" checked 
                   onchange="updateNodeShapeSetting(this.value)" 
                   style="cursor: pointer;">
            <span>Circle (default)</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; 
                      cursor: not-allowed; opacity: 0.5; 
                      pointer-events: none; user-select: none;">
            <input type="radio" name="nodeShape" value="source" disabled 
                   style="cursor: not-allowed;">
            <span>By Source Text (disabled)</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; 
                      cursor: not-allowed; opacity: 0.5; 
                      pointer-events: none; user-select: none;">
            <input type="radio" name="nodeShape" value="cluster" disabled 
                   style="cursor: not-allowed;">
            <span>By Cluster (disabled)</span>
        </label>
    </div>
</div>
</div>
        
        <!-- Experimental Features Section -->
        <div class="settings-section">
            <h3>üß™ Experimental Features</h3>
            
            <div class="setting-item">
                <div class="setting-info">
                    <h4>
                        Export Canvas as SVG 
                        <span class="setting-badge">EXPERIMENTAL</span>
                    </h4>
                    <p>Enable the "Export SVG" button to export your canvas as a scalable vector graphic file. This feature is under development and may have limitations with complex layouts.</p>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="exportSVGToggle" onchange="toggleExportSVG()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
		
		<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.1: TOKENIZATION SETTINGS ‚≠ê‚≠ê‚≠ê -->
<div class="settings-section">
    <h3>üî§ Tokenization Settings</h3>
    
    <!-- Tokenization Method -->
    <div class="setting-item">
        <div class="setting-info">
            <h4>Tokenization Method</h4>
            <p>Choose how to split text into tokens (words or characters).</p>
        </div>
        <div style="display: flex; flex-direction: column; gap: 8px; min-width: 200px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="radio" name="tokenizationMethod" value="character" 
                       onchange="updateTokenizationMethod(this.value)" 
                       style="cursor: pointer;">
                <span>By Character (add space between each character)</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="radio" name="tokenizationMethod" value="word" checked
                       onchange="updateTokenizationMethod(this.value)" 
                       style="cursor: pointer;">
                <span>By Word (use Jieba.js for Chinese/English)</span>
            </label>
        </div>
    </div>
    
    <!-- Separator Customization -->
    <div class="setting-item">
        <div class="setting-info">
            <h4>Token Separator</h4>
            <p>Define the separator to insert between tokens (default: space).</p>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
            <input type="text" id="tokenSeparatorInput" 
                   value=" " 
                   placeholder="e.g., space, |, /" 
                   style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; 
                          font-family: monospace; width: 100px; font-size: 14px;">
            <button class="btn btn-primary" onclick="updateTokenSeparator()" 
                    style="padding: 8px 16px; font-size: 14px;">
                Apply
            </button>
            <span id="separatorPreview" style="color: #7f8c8d; font-size: 13px; font-family: monospace;">
                Current: " " (space)
            </span>
        </div>
    </div>
</div>

<!-- Add after Tokenization Settings section -->
<div class="settings-section">
    <h3>üö´ Stopwords Settings</h3>
    
    <!-- Stopwords Mode Selection -->
    <div class="setting-item">
        <div class="setting-info">
            <h4>Stopwords Mode</h4>
            <p>Choose which stopwords to use for text processing and analysis.</p>
        </div>
        <div style="display: flex; flex-direction: column; gap: 8px; min-width: 250px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="radio" name="stopwordsMode" value="default" checked 
                       onchange="updateStopwordsMode(this.value)" 
                       style="cursor: pointer;">
                <span>Use only default embedded stopwords</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="radio" name="stopwordsMode" value="custom" 
                       onchange="updateStopwordsMode(this.value)" 
                       style="cursor: pointer;">
                <span>Use only custom stopwords</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="radio" name="stopwordsMode" value="both" 
                       onchange="updateStopwordsMode(this.value)" 
                       style="cursor: pointer;">
                <span>Use both default and custom stopwords</span>
            </label>
        </div>
    </div>
    
    <!-- Custom Stopwords Input -->
    <div class="setting-item" style="flex-direction: column; align-items: stretch;">
        <div class="setting-info" style="margin-bottom: 10px;">
            <h4>Custom Stopwords</h4>
            <p>Enter custom stopwords (one per line) or upload a text file.</p>
        </div>
        <textarea id="customStopwordsInput" 
                  placeholder="Enter stopwords here (one per line)..."
                  style="width: 100%; min-height: 150px; padding: 10px; 
                         border: 1px solid #ddd; border-radius: 4px; 
                         font-family: 'Courier New', monospace; font-size: 13px;
                         resize: vertical;"></textarea>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button class="btn btn-primary" onclick="document.getElementById('stopwordsFileInput').click()">
                üìÇ Upload Stopwords File
            </button>
            <button class="btn btn-success" onclick="applyStopwordsSettings()">
                ‚úÖ Apply
            </button>
            <button class="btn btn-secondary" onclick="clearCustomStopwords()">
                üóëÔ∏è Clear
            </button>
        </div>
        <input type="file" id="stopwordsFileInput" accept=".txt" onchange="loadStopwordsFile(event)" style="display: none;">
    </div>
    
    <!-- Show Stopwords Button -->
    <div class="setting-item">
        <div class="setting-info">
            <h4>Display Stopwords</h4>
            <p>View all active stopwords in the Info tab.</p>
        </div>
        <button class="btn btn-warning" onclick="showStopwordsInInfo()" style="min-width: 200px;">
            üìã Show Stopwords in Info
        </button>
    </div>
</div>

<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.2: SEGMENT-TO-WORD NETWORK SETTINGS ‚≠ê‚≠ê‚≠ê -->
<div class="settings-section">
    <h3>üìä Segment-to-Word Network Settings</h3>
    
    <!-- Segmentation Method Selection -->
    <div class="setting-item">
        <div class="setting-info">
            <h4>Segmentation Method</h4>
            <p>Choose how to split text into segments for network analysis.</p>
        </div>
        <div style="display: flex; flex-direction: column; gap: 8px; min-width: 250px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="radio" name="segmentationMethod" value="symbol" checked 
                       onchange="updateSegmentationMethod(this.value)" 
                       style="cursor: pointer;">
                <span>By Symbols (sentence boundaries)</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="radio" name="segmentationMethod" value="window" 
                       onchange="updateSegmentationMethod(this.value)" 
                       style="cursor: pointer;">
                <span>By Window Range (sliding window)</span>
            </label>
        </div>
    </div>
    
    <!-- Symbol-Based Settings -->
    <div class="setting-item" id="symbolSettings" style="flex-direction: column; align-items: stretch;">
        <div class="setting-info" style="margin-bottom: 10px;">
            <h4>Segment Boundary Symbols</h4>
            <p>Enter symbols that mark segment boundaries (one per line). Text will be split at these punctuation marks.</p>
        </div>
        <textarea id="boundarySymbolsInput" 
                  placeholder="Enter boundary symbols (one per line)..."
                  style="width: 100%; min-height: 120px; padding: 10px; 
                         border: 1px solid #ddd; border-radius: 4px; 
                         font-family: 'Courier New', monospace; font-size: 14px;
                         resize: vertical;"></textarea>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button class="btn btn-success" onclick="applySymbolSettings()">
                ‚úÖ Apply Symbols
            </button>
            <button class="btn btn-secondary" onclick="resetDefaultSymbols()">
                üîÑ Reset to Default
            </button>
        </div>
    </div>
    
    <!-- Window-Based Settings -->
    <div class="setting-item" id="windowSettings" style="display: none;">
        <div class="setting-info">
            <h4>Window Parameters</h4>
            <p>Configure sliding window size and step for segmentation.</p>
        </div>
        <div style="display: flex; flex-direction: column; gap: 15px; min-width: 300px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="min-width: 150px;">Window Size (tokens):</label>
                <input type="number" id="windowSizeInput" value="5" min="1" max="50" 
                       style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; width: 80px;">
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="min-width: 150px;">Window Step (advance):</label>
                <input type="number" id="windowStepInput" value="5" min="1" max="50" 
                       style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; width: 80px;">
            </div>
            <button class="btn btn-success" onclick="applyWindowSettings()" style="align-self: flex-start;">
                ‚úÖ Apply Window Settings
            </button>
        </div>
    </div>
</div>

<!-- About Segment-to-Word Network Info -->
<div class="settings-section">
    <h3>‚ÑπÔ∏è About Segment-to-Word Network</h3>
    <p style="line-height: 1.8; color: #555;">
        <strong>What is it?</strong> A document-to-term (2-mode) network where segments (documents) connect to the words (terms) they contain. This reveals thematic structure and word co-occurrence patterns.
    </p>
    
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Symbol-Based Method:</strong>
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li>Splits text at punctuation marks (e.g., periods, question marks, semicolons)</li>
        <li>Each sentence/clause becomes a segment</li>
        <li>Segments are tokenized using your tokenization settings</li>
        <li>Stopwords are removed AFTER tokenization</li>
        <li><strong>Use case:</strong> Natural language structure, sentence-level analysis</li>
    </ul>
    
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Window-Based Method:</strong>
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li>Creates fixed-size overlapping windows of tokens</li>
        <li>Text is tokenized and stopwords removed FIRST</li>
        <li>Each window becomes a segment with exactly N tokens</li>
        <li>Windows slide by step size (e.g., size=5, step=5 = non-overlapping)</li>
        <li><strong>Use case:</strong> Context windows, topic modeling, controlled segment sizes</li>
    </ul>
    
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Why different stopword removal order?</strong>
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li><strong>Symbol method:</strong> Boundary symbols (,;.!?) are often stopwords. Removing them first would prevent splitting!</li>
        <li><strong>Window method:</strong> Need consistent token counts per window. Stopwords removed first ensures predictable window sizes.</li>
    </ul>
    
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Output:</strong> Nodelist CSV with variable-length rows (no headers). Each row = segment ID + words in that segment.
    </p>
</div>
<!-- ============================================================================ -->


<!-- About Stopwords Info Section -->
<div class="settings-section">
    <h3>‚ÑπÔ∏è About Stopwords</h3>
    <p style="line-height: 1.8; color: #555;">
        <strong>What are stopwords?</strong> Common words that are typically filtered out during text processing because they carry little semantic meaning (e.g., "the", "is", "and" in English, "ÁöÑ", "‰∫Ü", "Âú®" in Chinese).
    </p>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Embedded stopwords:</strong> The platform includes comprehensive stopword lists:
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li><strong>English:</strong> ~${STOPWORDS_EN.size} common English stopwords</li>
        <li><strong>Chinese:</strong> ~${STOPWORDS_ZH.size} common Chinese stopwords and punctuation</li>
    </ul>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Custom stopwords:</strong> Add your own domain-specific stopwords (e.g., technical terms, proper nouns, or words specific to your research context).
    </p>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>File format:</strong> Text file (.txt) with one stopword per line, matching the format of the embedded stopwords.
    </p>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Use cases:</strong>
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li>Text preprocessing before tokenization</li>
        <li>Filtering out noise from word frequency analysis</li>
        <li>Cleaning data for network analysis (future feature)</li>
        <li>Focusing on content words in document-term networks</li>
    </ul>
</div>


<!-- About Tokenization Info -->
<div class="settings-section">
    <h3>‚ÑπÔ∏è About Tokenization</h3>
    <p style="line-height: 1.8; color: #555;">
        <strong>By Character:</strong> Splits text at each character level. For English, this means "hello" ‚Üí "h e l l o". For Chinese, "‰Ω†Â•Ω" ‚Üí "‰Ω† Â•Ω". Useful for character-level analysis.
    </p>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>By Word (Jieba):</strong> Uses intelligent word segmentation for both Chinese and English. For example:
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li>Chinese: "ÊàëÁà±Ëá™ÁÑ∂ËØ≠Ë®ÄÂ§ÑÁêÜ" ‚Üí "Êàë Áà± Ëá™ÁÑ∂ ËØ≠Ë®Ä Â§ÑÁêÜ"</li>
        <li>English: "natural language processing" ‚Üí "natural language processing" (preserved)</li>
        <li>Mixed: "I love NLPËá™ÁÑ∂ËØ≠Ë®ÄÂ§ÑÁêÜ" ‚Üí "I love NLP Ëá™ÁÑ∂ ËØ≠Ë®Ä Â§ÑÁêÜ"</li>
    </ul>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Separator:</strong> The character(s) inserted between tokens. Common choices:
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li><code>" "</code> (space) - Default, most readable</li>
        <li><code>"|"</code> (pipe) - Clear visual separation for analysis</li>
        <li><code>"/"</code> (slash) - Alternative visual separator</li>
        <li><code>","</code> (comma) - For CSV-like output</li>
    </ul>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Formatting Preservation:</strong> The tokenization process preserves:
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li>‚úÖ Paragraph breaks (original line structure maintained)</li>
        <li>‚úÖ Images and videos (kept in their original positions)</li>
        <li>‚úÖ HTML formatting (bold, italic, colors, etc.)</li>
        <li>‚úÖ Lists, tables, and other structural elements</li>
    </ul>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Editable Results:</strong> After tokenization, the text tab remains fully editable, allowing you to manually refine the results if needed.
    </p>
</div>
<!-- ============================================================================ -->
        
 <div class="settings-section">
    <h3>‚ÑπÔ∏è About Network Visualization Settings</h3>
    <p style="line-height: 1.8; color: #555;">
        <strong>Node Color (‚úÖ ACTIVE - PHASE 2):</strong> Source text coloring is now enabled! Nodes will be colored based on their origin text (Text 1, Text 2, etc.) using a 10-color palette. Enable "Source Text" in Settings, then click "üìä Network Analysis" to see colored nodes.<br/>
		<strong>Node Size (‚úÖ ACTIVE):</strong> All four centrality metrics are now available! Choose:
    </p>
    <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
        <li><strong>Degree:</strong> Node size based on number of connections (default)</li>
        <li><strong>Betweenness:</strong> Size reflects "bridge" importance between other nodes</li>
        <li><strong>Closeness:</strong> Size shows how quickly a node can reach all others</li>
        <li><strong>Eigenvector:</strong> Size indicates influence (connected to other important nodes)</li>
    </ul>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
    <strong>Node Color (‚úÖ ACTIVE - Clustering):</strong> Choose between source text coloring or community detection:
	</p>
	<ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
    <li><strong>Source Text:</strong> Colors nodes by their origin text (Text 1 = Red, Text 2 = Blue, etc.)</li>
    <li><strong>Cluster (LPA - Fast):</strong> Label Propagation Algorithm - fast community detection, results may vary between runs due to randomization</li>
    <li><strong>Cluster (Louvain - Stable):</strong> Louvain Method - stable, reproducible communities through modularity optimization (recommended for research)</li>
	</ul>
	<p style="line-height: 1.8; color: #555; margin-top: 10px;">
    <strong>Algorithm Comparison:</strong>
	</p>
	<ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
    <li><strong>LPA:</strong> Very fast, good for exploration, non-deterministic (different results each run)</li>
    <li><strong>Louvain:</strong> Fast, optimal modularity, deterministic (same results each run), better for small graphs, research-standard</li>
	</ul>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>Node Shape (‚è≥ Coming Soon):</strong> Will support different shapes (squares, triangles, etc.) based on source text or cluster membership.
    </p>
    <p style="line-height: 1.8; color: #555; margin-top: 10px;">
        <strong>How to Use:</strong> Select your preferred metric in Settings, then click "üìä Network Analysis" in the Edgelist tab. The graph will replot with nodes sized according to your choice.
    </p>
</div>
        
        <div class="settings-section">
            <h3>‚ÑπÔ∏è About SVG Export</h3>
            <p style="line-height: 1.8; color: #555;">
                <strong>What it does:</strong> Exports all textboxes and connections on the current canvas to an SVG file that can be opened in vector graphics editors like Adobe Illustrator, Inkscape, or imported into other applications.
            </p>
            <p style="line-height: 1.8; color: #555; margin-top: 10px;">
                <strong>Current limitations:</strong>
            </p>
            <ul style="margin-left: 25px; margin-top: 8px; line-height: 1.8; color: #555;">
                <li>HTML content is converted to plain text</li>
                <li>Text wrapping may differ from canvas display</li>
                <li>Very long text may overflow textbox boundaries</li>
                <li>Complex formatting may be simplified</li>
            </ul>
            <p style="line-height: 1.8; color: #555; margin-top: 10px;">
                <strong>Recommended use:</strong> For creating vector diagrams, presentations, or further editing in design software.
            </p>
        </div>
        
        <div class="settings-section">
            <h3>üí° Tips</h3>
            <ul style="margin-left: 25px; line-height: 1.8; color: #555;">
                <li>Test the export on a simple canvas first before exporting complex diagrams</li>
                <li>SVG files can be edited in free tools like Inkscape</li>
                <li>For presentations, consider using PNG export for more reliable results</li>
                <li>Settings are saved with your project files</li>
                <li>Network visualization settings will be expanded in future updates</li>
            </ul>
        </div>
    </div>
</div>

<div class="canvas-page" id="canvas-help">
<div class="help-content">
    <h2>üìñ How to Use This Platform</h2>
    
    <h3>Overview</h3>
    <p>This is a text structure analysis application based on Bonnie Meyer's Theory of Prose Organisation (Text Structure). Users can read text, segment surface-level content, and make segments coherent by relating them through various structural relationships. The platform includes advanced network analysis capabilities powered by Cytoscape.js for visualizing and analyzing the structure of your text as an interconnected network, with built-in community detection algorithms for discovering hidden thematic clusters.</p>

    <h3>Getting Started</h3>
    <ol>
        <li><strong>Add Your Texts:</strong> Paste HTML content or upload HTML/text files in different text tabs for intertextual analysis. Each text tab receives a unique ID (1, 2, 3...) that helps you track sources.</li>
        <li><strong>Mark Key Information (Optional):</strong> Select important text and click the üñåÔ∏è button to mark it in red bold.</li>
        <li><strong>Select Content:</strong> Highlight any portion of text (including HTML elements) you want to analyze from any text tab.</li>
        <li><strong>Drag to Canvas (Primary Method):</strong> Drag the selected content to the canvas for precise positioning. The textbox will automatically display which text tab it came from (e.g., "Source: Text 1").</li>
        <li><strong>Or Use Segment Button (Alternative):</strong> Select content and click the ‚úÇÔ∏è button to create a textbox at a default position.</li>
        <li><strong>Move & Resize Textboxes:</strong> Drag textboxes to reposition them, or use the resize handle in the bottom-right corner.</li>
        <li><strong>Highlight with Custom Colors:</strong> Click the ‚≠ê button on any textbox to open the color palette and choose from 10 colors (yellow is default). Right-click the ‚≠ê button for instant highlight toggle.</li>
        <li><strong>Connect Textboxes:</strong> Click üîó on first textbox ‚Üí Click üîó on second textbox (or drag between them) ‚Üí Select relation type.</li>
        <li><strong>Grey Out Supporting Details:</strong> Click the üëÅÔ∏è button to mark textboxes as supporting details. Greyed-out textboxes are excluded from network analysis.</li>
        <li><strong>Analyze Network Structure:</strong> Go to the Edgelist tab and click "üìä Network Analysis" to visualize your text structure in the Graph tab with automatic community detection.</li>
        <li><strong>Save Your Work:</strong> Click "üíæ Save Project" regularly to preserve your analysis, including all source text IDs, highlight colors, grey-out states, canvas zoom levels, and network visualization settings.</li>
    </ol>

    <h3>Working with HTML Content</h3>
    <ul>
        <li><strong>Upload HTML Files:</strong> Click the üåê button to upload HTML files (.html, .htm).</li>
        <li><strong>Upload Plain Text:</strong> Click the üìÑ button to upload plain text files (.txt).</li>
        <li><strong>Paste HTML:</strong> Directly paste HTML code into the text area - it will render properly with images, tables, and formatting preserved.</li>
        <li><strong>Paste Plain Text:</strong> Line breaks are automatically preserved when pasting plain text.</li>
        <li><strong>Paste Protection:</strong> Content from Word documents and other sources is automatically sanitized to prevent style pollution.</li>
        <li><strong>Drag to Canvas:</strong> Select and drag any HTML content (including images) to create textboxes.</li>
        <li><strong>Multimodal Analysis:</strong> Leverage HTML support for analyzing documents with images, videos, and rich formatting.</li>
    </ul>
	
	<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.1: Tokenization documentation ‚≠ê‚≠ê‚≠ê -->
<h3>üî§ Text Tokenization</h3>
<p>The platform includes intelligent word segmentation powered by Jieba.js, supporting both Chinese and English text processing.</p>

<h4>How to Tokenize Text</h4>
<ol>
    <li><strong>Configure Settings:</strong> Go to Settings ‚Üí Tokenization Settings</li>
    <li><strong>Choose Method:</strong>
        <ul style="margin-top: 5px;">
            <li><strong>By Word (recommended):</strong> Uses Jieba.js for intelligent Chinese/English word segmentation</li>
            <li><strong>By Character:</strong> Splits text at character level (useful for character-level analysis)</li>
        </ul>
    </li>
    <li><strong>Set Separator:</strong> Choose the character(s) to insert between tokens (default: space)</li>
    <li><strong>Click Tokenize:</strong> Click the üî§ button in the text panel</li>
    <li><strong>Edit if Needed:</strong> The tokenized text remains editable for manual refinement</li>
</ol>

<h4>Tokenization Methods</h4>
<ul>
    <li><strong>By Word (Jieba.js):</strong>
        <ul style="margin-top: 5px;">
            <li>Intelligently segments Chinese text: "ÊàëÁà±Ëá™ÁÑ∂ËØ≠Ë®ÄÂ§ÑÁêÜ" ‚Üí "Êàë Áà± Ëá™ÁÑ∂ ËØ≠Ë®Ä Â§ÑÁêÜ"</li>
            <li>Preserves English words: "natural language processing" ‚Üí "natural language processing"</li>
            <li>Handles mixed text: "I love NLPËá™ÁÑ∂ËØ≠Ë®ÄÂ§ÑÁêÜ" ‚Üí "I love NLP Ëá™ÁÑ∂ ËØ≠Ë®Ä Â§ÑÁêÜ"</li>
            <li>Uses Hidden Markov Model (HMM) for unknown words</li>
            <li>Best for: Semantic analysis, NLP preprocessing, word frequency studies</li>
        </ul>
    </li>
    <li><strong>By Character:</strong>
        <ul style="margin-top: 5px;">
            <li>Splits every character: "hello‰Ω†Â•Ω" ‚Üí "h e l l o ‰Ω† Â•Ω"</li>
            <li>Useful for: Character-level models, morphological analysis, educational tools</li>
        </ul>
    </li>
</ul>

<h4>Separator Options</h4>
<ul>
    <li><strong>Space " ":</strong> Most readable, standard for natural language (default)</li>
    <li><strong>Pipe "|":</strong> Clear visual separation for data analysis</li>
    <li><strong>Slash "/":</strong> Alternative separator for linguistic annotation</li>
    <li><strong>Comma ",":</strong> CSV-compatible output for spreadsheet analysis</li>
    <li><strong>Custom:</strong> Enter any character(s) you need</li>
</ul>

<h4>Format Preservation</h4>
<p>Tokenization intelligently preserves all formatting and structure:</p>
<ul>
    <li>‚úÖ <strong>Paragraph breaks:</strong> Original line structure is maintained</li>
    <li>‚úÖ <strong>HTML formatting:</strong> Bold, italic, colors, headings preserved</li>
    <li>‚úÖ <strong>Images & videos:</strong> Kept in their original positions (not tokenized)</li>
    <li>‚úÖ <strong>Lists & tables:</strong> Structural elements remain intact</li>
    <li>‚úÖ <strong>Links & buttons:</strong> Interactive elements preserved</li>
</ul>

<h4>Use Cases</h4>
<ul>
    <li><strong>Chinese NLP:</strong> Prepare Chinese text for word frequency analysis, concordance, or word cloud generation</li>
    <li><strong>Corpus Linguistics:</strong> Create space-separated tokens for concordancers like AntConc or Sketch Engine</li>
    <li><strong>Language Learning:</strong> Visualize word boundaries for language learners</li>
    <li><strong>Data Preprocessing:</strong> Prepare text for downstream NLP tasks (sentiment analysis, topic modeling, etc.)</li>
    <li><strong>Multilingual Analysis:</strong> Process mixed Chinese-English texts while maintaining language-specific segmentation</li>
</ul>

<h4>Tips</h4>
<ul>
    <li><strong>Editable Results:</strong> Always review and manually adjust tokenization if Jieba makes errors (especially with domain-specific terms)</li>
    <li><strong>Save Before Tokenizing:</strong> Tokenization modifies your text in-place. Save your project first if you want to preserve the original</li>
    <li><strong>Multiple Passes:</strong> You can tokenize the same text multiple times with different settings (but each pass modifies the previous result)</li>
    <li><strong>Export Options:</strong> After tokenization, you can export the text tab content or create segments on canvas for further analysis</li>
</ul>
<!-- ============================================================================ -->

<h3>üìä Document-to-Term Semantic Network</h3>
<p>Create 2-mode networks where segments (documents) connect to the words (terms) they contain. This reveals thematic structure and word co-occurrence patterns.</p>

<h4>How to Create Networks</h4>
<ol>
    <li><strong>Configure Method:</strong> Go to Settings ‚Üí Segment-to-Word Network Settings</li>
    <li><strong>Choose Segmentation:</strong>
        <ul style="margin-top: 5px;">
            <li><strong>By Symbols:</strong> Split at punctuation (natural sentence boundaries)</li>
            <li><strong>By Window:</strong> Fixed-size sliding windows (controlled segment sizes)</li>
        </ul>
    </li>
    <li><strong>Configure Parameters:</strong>
        <ul style="margin-top: 5px;">
            <li>Symbols: Enter boundary characters (e.g., ,.!?Ôºå„ÄÇÔºÅÔºü)</li>
            <li>Window: Set size (tokens per segment) and step (advance distance)</li>
        </ul>
    </li>
    <li><strong>Click Button:</strong> Click üìä in the text panel to generate network</li>
    <li><strong>View Results:</strong> Nodelist tab opens automatically with segment-to-word mappings</li>
</ol>

<h4>Segmentation Methods</h4>
<ul>
    <li><strong>Symbol-Based:</strong>
        <ul style="margin-top: 5px;">
            <li>Splits text at specified punctuation marks</li>
            <li>Each sentence/clause becomes a segment</li>
            <li><strong>Processing order:</strong> Split ‚Üí Tokenize ‚Üí Remove stopwords</li>
            <li><strong>Why this order?</strong> Boundary symbols (,.!?) are often stopwords. Removing them first would destroy split points!</li>
            <li><strong>Use case:</strong> Natural language analysis, sentence-level topics, discourse analysis</li>
        </ul>
    </li>
    <li><strong>Window-Based:</strong>
        <ul style="margin-top: 5px;">
            <li>Creates fixed-size overlapping windows of tokens</li>
            <li>Each window = exactly N clean tokens (after stopword removal)</li>
            <li><strong>Processing order:</strong> Tokenize ‚Üí Remove stopwords ‚Üí Create windows</li>
            <li><strong>Why this order?</strong> Need consistent token counts per window. Stopwords removed first ensures predictable sizes.</li>
            <li><strong>Parameters:</strong> Size = tokens per window, Step = advance distance (size=step = non-overlapping)</li>
            <li><strong>Use case:</strong> Topic modeling, context windows, controlled segment analysis</li>
        </ul>
    </li>
</ul>

<h4>Nodelist Output Format</h4>
<ul>
    <li><strong>CSV format (no headers):</strong> Each row = segment ID + words in that segment</li>
    <li><strong>Example:</strong>
        <pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; font-family: 'Courier New', monospace;">1,"machine","learning","powerful","tool"
2,"natural","language","processing","NLP"
3,"deep","learning","neural","networks"</pre>
    </li>
    <li><strong>Variable-length rows:</strong> Different segments contain different numbers of words (no unified header possible)</li>
    <li><strong>Export options:</strong> Copy to clipboard or download as CSV</li>
</ul>

<h4>Analysis Workflow</h4>
<ol style="margin-left: 20px; margin-top: 5px;">
    <li><strong>Tokenize:</strong> Use üî§ button to segment text into words (optional but recommended)</li>
    <li><strong>Configure Stopwords:</strong> Set active stopwords in Settings (removes noise)</li>
    <li><strong>Create Network:</strong> Click üìä to generate segment-to-word mappings</li>
    <li><strong>Export Data:</strong> Download nodelist CSV for external analysis (Gephi, NetworkX, igraph, etc.)</li>
    <li><strong>Visualize:</strong> Import CSV into network visualization tools to see document-term relationships</li>
</ol>

<h4>Use Cases</h4>
<ul>
    <li><strong>Topic Discovery:</strong> Identify recurring word clusters across segments</li>
    <li><strong>Thematic Analysis:</strong> See which words co-occur in same segments</li>
    <li><strong>Comparative Analysis:</strong> Compare word distributions across different texts</li>
    <li><strong>Context Windows:</strong> Analyze word co-occurrence within fixed-size contexts</li>
    <li><strong>Document Clustering:</strong> Find similar segments based on shared vocabulary</li>
</ul>

<h4>Tips</h4>
<ul>
    <li><strong>Symbol vs. Window:</strong> Use symbols for natural structure, windows for controlled analysis</li>
    <li><strong>Stopword Importance:</strong> Always configure stopwords to remove noise (the, is, of, etc.)</li>
    <li><strong>Window Parameters:</strong> Larger size = more context, smaller step = more overlap</li>
    <li><strong>Non-overlapping Windows:</strong> Set size = step (e.g., size=5, step=5)</li>
    <li><strong>Overlapping Windows:</strong> Set step < size (e.g., size=5, step=2)</li>
    <li><strong>Export Format:</strong> CSV is compatible with all major network analysis tools</li>
</ul>

<h3>üî§ Word-to-Word Semantic Network (W-Network)</h3>
<p>Transform 2-mode segment-to-word data into 1-mode word co-occurrence networks for advanced semantic analysis.</p>

<h4>How to Create Word Networks</h4>
<ol>
    <li><strong>Generate 2-Mode Network:</strong> First, create segment-to-word network using üìä button in text panel (see "Document-to-Term Semantic Network" section above)</li>
    <li><strong>View W-Network Tab:</strong> Switch to "W-Network" tab in left panel</li>
    <li><strong>Click Analysis:</strong> Click "üìä Network Analysis" button</li>
    <li><strong>Auto-Conversion:</strong> System automatically:
        <ul style="margin-top: 5px;">
            <li>Converts 2-mode ‚Üí 1-mode word network</li>
            <li>Calculates co-occurrence weights (how often words appear together)</li>
            <li>Displays edgelist with 7 columns (includes weights)</li>
            <li>Switches view to show word-to-word edges</li>
        </ul>
    </li>
    <li><strong>View Graph:</strong> Graph tab opens automatically with word network visualization</li>
    <li><strong>Analyze Metrics:</strong> Sidebar shows all 4 centrality metrics for each word</li>
    <li><strong>Detect Communities:</strong> If clustering enabled, word clusters are detected and colored</li>
</ol>

<h4>Understanding Word Networks</h4>
<ul>
    <li><strong>Nodes:</strong> Individual words (after stopword removal)</li>
    <li><strong>Edges:</strong> Co-occurrence relationships (words that appeared in same segments)</li>
    <li><strong>Edge Weight:</strong> Number of segments where both words co-occurred
        <ul style="margin-top: 5px;">
            <li>Higher weight = stronger semantic relationship</li>
            <li>Visualized as thicker edges in graph</li>
            <li>Shown as numeric labels on connections</li>
        </ul>
    </li>
    <li><strong>Network Type:</strong> Undirected graph (word relationships are bidirectional)</li>
</ul>

<h4>Edgelist Format (1-Mode)</h4>
<ul>
    <li><strong>7 columns with header:</strong>
        <pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; font-family: 'Courier New', monospace;">From_Node,To_Node,From_TextID,To_TextID,From_Cluster,To_Cluster,Weight</pre>
    </li>
    <li><strong>Example rows:</strong>
        <pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; font-family: 'Courier New', monospace;">"machine","learning",1,1,1,1,3
"natural","language",1,1,2,2,5
"deep","neural",1,1,1,1,2</pre>
    </li>
    <li><strong>Weight column:</strong> Co-occurrence count (how many segments contain both words)</li>
    <li><strong>Cluster columns:</strong> Populated when clustering enabled, otherwise 0</li>
</ul>

<h4>Analysis Features</h4>
<ul>
    <li><strong>Centrality Metrics:</strong> Same 4 metrics as T-network (degree, betweenness, closeness, eigenvector)</li>
    <li><strong>Community Detection:</strong> LPA or Louvain algorithms detect thematic word clusters</li>
    <li><strong>Weighted Edges:</strong> Edge thickness reflects semantic strength (co-occurrence frequency)</li>
    <li><strong>Interactive Graph:</strong> Click nodes for metrics, click edges for co-occurrence counts</li>
    <li><strong>Sortable Tables:</strong> All metric tables support 3-way sorting (desc/asc/original)</li>
    <li><strong>Export Options:</strong>
        <ul style="margin-top: 5px;">
            <li>üìã Copy edgelist to clipboard (CSV with header)</li>
            <li>üíæ Download as CSV file (timestamped filename)</li>
            <li>üñºÔ∏è Export graph as PNG (2x resolution, labeled "w-network-...")</li>
        </ul>
    </li>
</ul>

<h4>Interpreting Word Network Metrics</h4>
<ul>
    <li><strong>High Degree Words:</strong> Core vocabulary - appear with many different words across segments</li>
    <li><strong>High Betweenness Words:</strong> Bridge terms connecting different topics/themes</li>
    <li><strong>High Closeness Words:</strong> Central concepts that relate to all parts of the text</li>
    <li><strong>High Eigenvector Words:</strong> Key terms connected to other important terms</li>
    <li><strong>Word Clusters:</strong> Thematic vocabularies that co-occur frequently
        <ul style="margin-top: 5px;">
            <li>Each cluster represents a semantic field or topic</li>
            <li>Cross-cluster edges = bridge terms linking different themes</li>
            <li>Cluster size = number of related words in that theme</li>
        </ul>
    </li>
</ul>

<h4>Use Cases</h4>
<ul>
    <li><strong>Topic Modeling:</strong> Discover thematic vocabularies through word clustering</li>
    <li><strong>Semantic Field Analysis:</strong> Identify related terms that co-occur frequently</li>
    <li><strong>Keyword Extraction:</strong> Find high-centrality words representing core concepts</li>
    <li><strong>Comparative Semantics:</strong> Compare word networks from different texts to see vocabulary differences</li>
    <li><strong>Discourse Analysis:</strong> Analyze how specialized terminology clusters around topics</li>
    <li><strong>Terminology Mapping:</strong> Visualize technical vocabulary networks in specialized texts</li>
</ul>

<h4>Workflow: 2-Mode ‚Üí 1-Mode</h4>
<ol style="margin-left: 20px; margin-top: 5px;">
    <li><strong>Start:</strong> Tokenize text ‚Üí Configure stopwords ‚Üí Generate 2-mode network</li>
    <li><strong>View 2-Mode:</strong> W-Network tab shows segment-to-word nodelist (variable-length rows)</li>
    <li><strong>Convert:</strong> Click "üìä Network Analysis" ‚Üí Auto-converts to 1-mode word edgelist</li>
    <li><strong>View 1-Mode:</strong> Tab now shows word-to-word edges with weights and clusters</li>
    <li><strong>Toggle Back:</strong> Click "üîÑ Back to Nodelist" to return to 2-mode view</li>
    <li><strong>Re-analyze:</strong> Can click "üìä Network Analysis" again to replot graph with different settings</li>
    <li><strong>Export:</strong> Download CSV or PNG at any time (format auto-detects current view mode)</li>
</ol>

<h4>Tips</h4>
<ul>
    <li><strong>Edge Weights:</strong> Higher weights = stronger semantic associations. Filter low-weight edges in external tools (Gephi, NetworkX) for clearer visualization</li>
    <li><strong>Cluster Interpretation:</strong> Use community detection to find semantic fields (e.g., Cluster 1 = technical terms, Cluster 2 = methodological vocabulary)</li>
    <li><strong>Comparative Analysis:</strong> Generate W-networks from multiple texts, export CSVs, compare cluster structures</li>
    <li><strong>Centrality Focus:</strong> Sort by betweenness to find bridge terms linking different topics</li>
    <li><strong>Algorithm Choice:</strong> Use Louvain for stable, reproducible word clusters (research publications)</li>
    <li><strong>View Modes:</strong> Toggle between 2-mode (segment-word) and 1-mode (word-word) for different analytical perspectives</li>
</ul>


    <h3>Multiple Texts for Intertextual Analysis</h3>
    <p>The application supports multiple text tabs for intertextual analysis. The numbering system (Text 1, Text 2, Text 3, etc.) is crucial for tracking which source text each segment originates from, helping readers maintain coherence across multiple texts and preventing confusion in complex intertextual analyses.</p>
    <ul>
        <li><strong>Create Text Tabs:</strong> Click the <strong>+</strong> button in the text panel to create new tabs. Each tab is numbered sequentially starting from 1.</li>
        <li><strong>Source Tracking:</strong> When you create textboxes from different text tabs, each textbox displays its source ID (e.g., "1", "2", "3") in the bottom-right corner of the control panel.</li>
        <li><strong>Main Idea Tab:</strong> Shows all highlighted segments from all texts combined, with source IDs clearly displayed. Drag to reorder items into a coherent narrative.</li>
        <li><strong>Edgelist Tab:</strong> Shows all connections across all canvases in CSV format, with source text IDs and community cluster IDs (when enabled) included for each textbox - crucial for quantitative analysis of intertextual relationships and thematic clustering.</li>
        <li><strong>Network Graph:</strong> Nodes in the network visualization can be colored by source text OR community membership (enable in Settings), allowing you to see which text each idea originates from or which thematic cluster it belongs to.</li>
        <li><strong>Close Text Tabs:</strong> Click the <strong>√ó</strong> on a text tab to close it (you must keep at least one tab). Note: Closing a tab does not delete textboxes already created from that source - they retain their source ID for reference.</li>
        <li><strong>Why Numbering Matters:</strong> The consistent ID numbering (1, 2, 3...) across all features (textboxes, main idea list, edgelist, network nodes) makes it easy to trace relationships between different source texts and maintain coherence in complex analyses.</li>
    </ul>

    <h3>Control Buttons in Text Panel</h3>
    <ul>
        <li><strong>üìÑ Upload TXT:</strong> Load a plain text file (.txt) into the current text tab</li>
        <li><strong>üåê Upload HTML:</strong> Load an HTML file (.html, .htm) into the current text tab</li>
        <li><strong>‚úÇÔ∏è Segment:</strong> Create a textbox on the canvas from selected text (alternative to dragging)</li>
        <!-- ‚≠ê‚≠ê‚≠ê PHASE 4.1: Tokenize button documentation ‚≠ê‚≠ê‚≠ê -->
		<li><strong>üî§ Tokenize:</strong> Perform word segmentation on the entire text in the current tab using Jieba.js (for Chinese/English) or character-level splitting. Results are editable. Configure method and separator in Settings.</li>
		<!-- ============================================================================ -->
		<li><strong>üñåÔ∏è Mark Key:</strong> Mark/unmark selected text as key information (red bold color in the source text)</li>
        <li><strong>üóëÔ∏è Clear:</strong> Remove all text from the current text tab</li>
    </ul>

    <h3>Textbox Control Buttons (2√ó3 Grid)</h3>
    <p><em>Hover over any textbox to reveal the control panel in the top-right corner:</em></p>
    <ul>
        <li><strong>Row 1, Column 1 (üîó):</strong> Connect - Click to start connection OR drag to another textbox to connect</li>
        <li><strong>Row 1, Column 2 (üëÅÔ∏è):</strong> Grey Out - Mark as supporting detail (excluded from network analysis when greyed; click again to un-grey)</li>
        <li><strong>Row 2, Column 1 (‚≠ê):</strong> Highlight - Left-click to open color palette; Right-click to toggle highlight on/off instantly</li>
        <li><strong>Row 2, Column 2 (üóëÔ∏è):</strong> Delete - Remove the textbox and all its connections</li>
        <li><strong>Row 3, Column 1 (üí≠):</strong> Infer - Mark as inferred content (dashed border; click again to remove)</li>
        <li><strong>Row 3, Column 2 (Number):</strong> Source Text ID - Shows which text tab this segment came from (1, 2, 3, etc.)</li>
    </ul>

    <h3>Highlighting Textboxes with Custom Colors</h3>
    <ul>
        <li><strong>Method 1 - Color Palette (Left-Click):</strong>
            <ol style="margin-top: 5px; margin-left: 20px;">
                <li>Left-click the ‚≠ê button on any textbox</li>
                <li>A color palette appears with 10 color options plus a remove option</li>
                <li>Click any color to apply it as the highlight background</li>
                <li>The palette closes automatically after color selection</li>
            </ol>
        </li>
        <li><strong>Method 2 - Quick Toggle (Right-Click):</strong>
            <ol style="margin-top: 5px; margin-left: 20px;">
                <li>Right-click the ‚≠ê button on any textbox</li>
                <li>The highlight toggles on/off instantly (uses default yellow or last selected color)</li>
                <li>Fastest method for quick highlighting without opening the palette</li>
            </ol>
        </li>
        <li><strong>Method 3 - Remove Highlight (Palette):</strong>
            <ol style="margin-top: 5px; margin-left: 20px;">
                <li>Left-click the ‚≠ê button on a highlighted textbox</li>
                <li>Click the ‚úñ icon (striped square) in the color palette</li>
                <li>The highlight is removed and the textbox returns to white background</li>
            </ol>
        </li>
        <li><strong>Method 4 - Close Palette:</strong>
            <ol style="margin-top: 5px; margin-left: 20px;">
                <li>Click the √ó button in the top-right corner of the palette to close it without making changes</li>
                <li>Click anywhere outside the palette to close it</li>
            </ol>
        </li>
        <li><strong>Available Colors:</strong>
            <ul style="margin-top: 5px;">
                <li>üü° Yellow (default) - General highlights / Main arguments</li>
                <li>üü† Apricot - Warnings or important notes</li>
                <li>üü° Beige - Background information</li>
                <li>üíô Light Blue - Methodology / Processes</li>
                <li>üü† Light Orange - Examples / Case studies</li>
                <li>üü£ Light Purple - Theoretical concepts</li>
                <li>üíô Cyan - Data / Statistics</li>
                <li>üíö Mint - Evidence / Support</li>
                <li>üíö Lime - Conclusions / Findings</li>
                <li>ü©∑ Pink - Counterarguments / Critiques</li>
            </ul>
        </li>
        <li><strong>Color Strategy Tip:</strong> Develop a consistent color-coding system across your analysis (e.g., yellow for main arguments, blue for evidence, pink for counterarguments) to visually organize your textboxes.</li>
        <li><strong>Saved with Project:</strong> Your color choices are automatically saved in project files and restored when you load them.</li>
        <li><strong>Main Idea Tab:</strong> Only highlighted textboxes (any color) appear in the Main Idea tab. Un-highlighting a textbox removes it from the list.</li>
    </ul>

    <h3>Creating Connections Between Textboxes</h3>
    <ul>
        <li><strong>Method 1 - Click to Connect:</strong>
            <ol style="margin-top: 5px; margin-left: 20px;">
                <li>Hover over the first textbox to reveal its control buttons</li>
                <li>Click the üîó (connect) button - the textbox border turns green</li>
                <li>Hover over the second textbox and click its üîó button</li>
                <li>Select the relationship type from the dialog</li>
                <li>The connection appears as a colored line between the textboxes</li>
            </ol>
        </li>
        <li><strong>Method 2 - Drag to Connect:</strong>
            <ol style="margin-top: 5px; margin-left: 20px;">
                <li>Hover over the first textbox to reveal its control buttons</li>
                <li>Click and drag from the üîó button</li>
                <li>A green temporary line follows your cursor</li>
                <li>Drop anywhere on the target textbox (it highlights when you hover over it)</li>
                <li>Select the relationship type from the dialog</li>
                <li>The connection appears as a colored line between the textboxes</li>
            </ol>
        </li>
        <li><strong>Important:</strong> To move a textbox, drag from the textbox border or background (NOT from the üîó icon). To connect textboxes, drag FROM the üîó icon.</li>
        <li><strong>Editing Connections:</strong> Click on any connection line or label to edit the relationship type or delete the connection.</li>
        <li><strong>Directional Connections:</strong> For directional relationships (sequence, cause, etc.), click the ‚áÑ button on the connection label to reverse the direction.</li>
        <li><strong>Custom Labels:</strong> Choose "Custom" in the relation dialog to enter your own relationship label.</li>
    </ul>

    <h3>Relation Types & Connection Lines</h3>
    <p>Each relation type is visualized with a distinct line style and color:</p>
    <ul class="relation-list">
        <li style="border-left-color: #e74c3c;">
            <strong style="color: #e74c3c;">Description (Directional)</strong>
            Provides attributes, characteristics, or details about a topic.
            <div class="line-type-demo">Visual: Red half-dotted, half-solid line (¬∑¬∑¬∑¬∑¬∑‚îÄ‚îÄ‚îÄ)</div>
        </li>
        <li style="border-left-color: #3498db;">
            <strong style="color: #3498db;">Comparison (Non-directional)</strong>
            Shows similarities between two or more things.
            <div class="line-type-demo">Visual: Blue double-headed arrow (‚Üî)</div>
        </li>
        <li style="border-left-color: #9b59b6;">
            <strong style="color: #9b59b6;">Contrast (Directional)</strong>
            Shows differences between two or more things.
            <div class="line-type-demo">Visual: Purple directional double arrow (‚ü®¬∑¬∑¬∑¬∑¬∑‚Üê‚Üí‚îÄ‚îÄ‚îÄ‚ñ∂)</div>
        </li>
        <li style="border-left-color: #e91e63;">
            <strong style="color: #e91e63;">Analogy (Non-directional)</strong>
            Draws parallels or comparisons to explain concepts.
            <div class="line-type-demo">Visual: Pink double parallel lines (‚ïë)</div>
        </li>
        <li style="border-left-color: #2ecc71;">
            <strong style="color: #2ecc71;">Sequence (Directional)</strong>
            Indicates order, steps, or temporal relationships.
            <div class="line-type-demo">Visual: Green arrow (‚îÄ‚îÄ‚ñ∂)</div>
        </li>
        <li style="border-left-color: #f39c12;">
            <strong style="color: #f39c12;">Cause (Directional)</strong>
            Shows cause-and-effect relationships.
            <div class="line-type-demo">Visual: Orange arrow (‚îÄ‚îÄ‚ñ∂)</div>
        </li>
        <li style="border-left-color: #e67e22;">
            <strong style="color: #e67e22;">Solution (Directional)</strong>
            Presents a solution to a problem.
            <div class="line-type-demo">Visual: Dark orange arrow (‚îÄ‚îÄ‚ñ∂)</div>
        </li>
        <li style="border-left-color: #1abc9c;">
            <strong style="color: #1abc9c;">Source (Directional)</strong>
            Indicates the origin or attribution of information.
            <div class="line-type-demo">Visual: Teal half-dotted, half-solid line (¬∑¬∑¬∑¬∑¬∑‚îÄ‚îÄ‚îÄ)</div>
        </li>
        <li style="border-left-color: #34495e;">
            <strong style="color: #34495e;">Custom Connection (Directional)</strong>
            User-defined relationship with customizable label.
            <div class="line-type-demo">Visual: Dark grey dotted-solid line with dot endings (‚óè¬∑¬∑¬∑¬∑¬∑‚îÄ‚îÄ‚îÄ‚óè)</div>
        </li>
    </ul>

    <h3>üìä Network Analysis & Visualization</h3>
    
    <h4>Accessing Network Visualization</h4>
    <ol>
        <li><strong>Create Connections:</strong> First, create connections between textboxes using the üîó button (you must have at least one connection).</li>
        <li><strong>Navigate to Edgelist:</strong> Click on the "Edgelist" tab in the text panel.</li>
        <li><strong>Click Network Analysis:</strong> Click the "üìä Network Analysis" button.</li>
        <li><strong>View Graph:</strong> The visualization appears in the "Graph" tab on the canvas panel, which opens automatically.</li>
        <li><strong>Community Detection:</strong> If you enabled cluster coloring in Settings (LPA or Louvain), communities are automatically detected and displayed in the sidebar.</li>
    </ol>

    <h4>Understanding the Network Graph</h4>
    <ul>
        <li><strong>Node Labels:</strong> Each node displays the first 4 characters of its textbox content (or full text if shorter).</li>
        <li><strong>Node Sizes:</strong> Node size reflects the selected centrality metric (default: degree centrality). Configure in Settings.</li>
        <li><strong>Node Colors:</strong> Can be colored by source text (Text 1, Text 2, etc.) OR community membership (LPA/Louvain algorithms) when enabled in Settings. Each source/cluster uses a different color from a 10-color palette.</li>
        <li><strong>Edge Labels:</strong> Connection lines show the relationship type (e.g., "description", "cause", "sequence").</li>
        <li><strong>Layout Algorithm:</strong> Uses automatic force-directed layout (Cytoscape.js cose algorithm) that positions highly connected nodes centrally and groups communities together.</li>
        <li><strong>Grey-Out Integration:</strong> Only non-greyed textboxes appear in the network. Grey out supporting details to focus on main ideas, then replot the network.</li>
    </ul>

    <h4>Interacting with the Graph</h4>
    <ul>
        <li><strong>Zoom:</strong> Use mouse wheel or trackpad to zoom in/out.</li>
        <li><strong>Pan:</strong> Click and drag on empty space to move the entire graph.</li>
        <li><strong>View Node Details:</strong> Click on any node to see a popup with all four centrality metrics (degree, betweenness, closeness, eigenvector) and cluster assignment (if clustering is enabled).</li>
        <li><strong>Rearrange Nodes:</strong> Click and drag individual nodes to reposition them manually (optional - the layout automatically optimizes positions).</li>
        <li><strong>Export Graph:</strong> Click "üñºÔ∏è Snap PNG" in the canvas header to export the current network visualization as a high-resolution PNG image (2x scale for publication quality).</li>
    </ul>

    <h4>Understanding Centrality Metrics</h4>
    <p>Four different centrality metrics are automatically calculated for each node:</p>
    <ul>
        <li><strong>Degree Centrality:</strong> Number of direct connections a node has.
            <ul style="margin-top: 5px;">
                <li><em>High degree:</em> Central hubs in your text structure - ideas that connect to many other ideas</li>
                <li><em>Low degree:</em> Peripheral ideas with few connections</li>
                <li><em>Use case:</em> Identify main topics or frequently referenced concepts</li>
            </ul>
        </li>
        <li><strong>Betweenness Centrality:</strong> How often a node appears on the shortest path between other nodes.
            <ul style="margin-top: 5px;">
                <li><em>High betweenness:</em> Bridge concepts that connect different parts of your argument</li>
                <li><em>Low betweenness:</em> Ideas that don't serve as connectors</li>
                <li><em>Use case:</em> Find transitional or linking concepts between themes</li>
            </ul>
        </li>
        <li><strong>Closeness Centrality:</strong> How close a node is to all other nodes in the network.
            <ul style="margin-top: 5px;">
                <li><em>High closeness:</em> Ideas that can quickly reach all other parts of the structure</li>
                <li><em>Low closeness:</em> Ideas that are more distant from the overall structure</li>
                <li><em>Use case:</em> Identify central organizing ideas or frameworks</li>
            </ul>
        </li>
        <li><strong>Eigenvector Centrality:</strong> Influence based on connections to other influential nodes.
            <ul style="margin-top: 5px;">
                <li><em>High eigenvector:</em> Ideas connected to other important ideas (influence measure)</li>
                <li><em>Low eigenvector:</em> Ideas connected to less central concepts</li>
                <li><em>Use case:</em> Find authoritative or influential concepts in the network</li>
            </ul>
        </li>
    </ul>

    <h4>üìä Community Detection (Clustering)</h4>
    <p>Two powerful algorithms are available to automatically discover thematic communities (clusters) in your network:</p>
    
    <h5>Label Propagation Algorithm (LPA - Fast)</h5>
    <ul>
        <li><strong>How it works:</strong> Nodes "vote" on their cluster membership based on their neighbors' labels, iteratively converging to stable communities</li>
        <li><strong>Speed:</strong> Very fast (typically 5-20 iterations)</li>
        <li><strong>Stability:</strong> Non-deterministic - results may vary slightly between runs due to randomization</li>
        <li><strong>Best for:</strong> Exploratory analysis, quick insights, large networks</li>
        <li><strong>Enable:</strong> Settings ‚Üí Node Color ‚Üí "Cluster (LPA - Fast)"</li>
    </ul>
    
    <h5>Louvain Method (Stable & Optimal)</h5>
    <ul>
        <li><strong>How it works:</strong> Optimizes modularity by moving nodes between communities to maximize within-cluster connections</li>
        <li><strong>Speed:</strong> Fast and efficient</li>
        <li><strong>Stability:</strong> Deterministic - produces identical results on the same network every time</li>
        <li><strong>Quality:</strong> Maximizes modularity (research-standard quality metric)</li>
        <li><strong>Best for:</strong> Research publications, reproducible analysis, comparing different network versions</li>
        <li><strong>Enable:</strong> Settings ‚Üí Node Color ‚Üí "Cluster (Louvain - Stable)"</li>
    </ul>
    
    <h5>Using Community Detection</h5>
    <ol style="margin-left: 20px; margin-top: 5px;">
        <li>Go to Settings tab ‚Üí Node Color ‚Üí Select "Cluster (LPA - Fast)" or "Cluster (Louvain - Stable)"</li>
        <li>Return to Edgelist tab ‚Üí Click "üìä Network Analysis"</li>
        <li>Graph tab opens with nodes colored by detected communities (10-color palette)</li>
        <li>Sidebar shows "üìä Community Detection" section with:
            <ul style="margin-top: 5px;">
                <li>Total number of communities detected</li>
                <li>Sortable table of all nodes with their cluster assignments</li>
                <li>Click header to sort by cluster ID (ascending/descending/original order)</li>
            </ul>
        </li>
        <li>Click on any node to see its cluster assignment in the popup</li>
        <li>Export graph as PNG to capture community structure visually</li>
        <li>Download edgelist CSV - cluster IDs are included in the last two columns for quantitative analysis</li>
    </ol>
    
    <h5>Community Table Features</h5>
    <ul>
        <li><strong>Sortable:</strong> Click "üìä Community Detection" header to cycle through:
            <ul style="margin-top: 5px;">
                <li>‚ñº Descending (highest cluster ID first)</li>
                <li>‚ñ≤ Ascending (lowest cluster ID first)</li>
                <li>(No arrow) Original order (as detected)</li>
            </ul>
        </li>
        <li><strong>Node Labels:</strong> Shows first 4 characters of each node's content (hover for full text)</li>
        <li><strong>Cluster IDs:</strong> Numbers 1, 2, 3... representing different communities</li>
        <li><strong>Color-Coded:</strong> Each cluster uses consistent color in both graph and table</li>
    </ul>
    
    <h5>Interpreting Communities</h5>
    <ul>
        <li><strong>What are communities?</strong> Groups of nodes that are more densely connected to each other than to the rest of the network</li>
        <li><strong>Thematic clusters:</strong> Often represent:
            <ul style="margin-top: 5px;">
                <li>Main themes or topics in your text</li>
                <li>Coherent argument chains</li>
                <li>Related concepts that form a logical unit</li>
                <li>Different perspectives or viewpoints</li>
            </ul>
        </li>
        <li><strong>Bridge nodes:</strong> Nodes that connect multiple communities (high betweenness) are key linking concepts</li>
        <li><strong>Isolated communities:</strong> May indicate independent themes or disconnected arguments</li>
        <li><strong>Community size:</strong> Check sidebar table to see how many nodes belong to each cluster</li>
    </ul>

    <h4>Network Statistics Panel</h4>
    <p>The left sidebar in the Graph tab displays overall network metrics and top-ranked nodes:</p>
    <ul>
        <li><strong>Network Statistics:</strong> Total nodes (excluding greyed-out textboxes), total edges (connections), average degree, and network density (0-1 scale).</li>
        <li><strong>Centrality Rankings (Sortable):</strong> Top 10 nodes ranked by each of the four centrality metrics, with scores displayed to 3 decimal places. Click any section header to sort ascending/descending/original order.</li>
        <li><strong>Community Detection Section:</strong> Appears when cluster coloring is enabled. Shows total communities detected and sortable table of all node-cluster assignments.</li>
        <li><strong>Real-time Updates:</strong> All statistics update automatically when you replot the network after greying out textboxes or changing settings.</li>
    </ul>

    <h4>üîÑ Replotting the Network (Grey-Out Workflow)</h4>
    <ul>
        <li><strong>Purpose:</strong> Focus your network analysis on main ideas by excluding supporting details, then compare metrics and community structure between full and filtered networks.</li>
        <li><strong>How to Use:</strong>
            <ol style="margin-top: 5px; margin-left: 20px;">
                <li>In any canvas tab, click the üëÅÔ∏è button on textboxes you want to exclude (supporting details, tangential points, examples, etc.)</li>
                <li>Greyed-out textboxes become semi-transparent (50% opacity) and are marked as inactive</li>
                <li>Go to the Edgelist tab and click "üìä Network Analysis" again</li>
                <li>The network graph regenerates with only non-greyed textboxes and their connections</li>
                <li>Compare centrality metrics, network statistics, and community structure between runs</li>
            </ol>
        </li>
        <li><strong>Reverting:</strong> Click the üëÅÔ∏è button again on any greyed-out textbox to reactivate it, then replot the network to include it again.</li>
        <li><strong>Use Cases:</strong>
            <ul style="margin-top: 5px;">
                <li>Compare network structure with vs. without supporting evidence</li>
                <li>Focus on main argumentative flow by excluding examples</li>
                <li>Identify core vs. peripheral concepts in a literature review</li>
                <li>Progressive refinement: Start full, grey out gradually, observe metric changes and community reorganization</li>
            </ul>
        </li>
        <li><strong>Preserved in Projects:</strong> Grey-out states are saved in project files, so you can resume your filtering strategy when you reload your work.</li>
    </ul>

    <h3>‚öôÔ∏è Network Visualization Settings</h3>
    <p>Configure how nodes are displayed in the network graph via the Settings tab:</p>
    
    <h4>Node Size (‚úÖ Fully Functional)</h4>
    <ul>
        <li><strong>Degree Centrality (Default):</strong> Node size reflects number of connections</li>
        <li><strong>Betweenness Centrality:</strong> Node size reflects "bridge" importance between other nodes</li>
        <li><strong>Closeness Centrality:</strong> Node size shows how quickly a node can reach all others</li>
        <li><strong>Eigenvector Centrality:</strong> Node size indicates influence (connected to other important nodes)</li>
        <li><strong>How to Use:</strong> Select your preferred metric in Settings ‚Üí Click "üìä Network Analysis" to replot the graph with nodes sized according to your choice.</li>
    </ul>

    <h4>Node Color (‚úÖ Fully Functional with Community Detection)</h4>
    <ul>
        <li><strong>None (Default):</strong> All nodes use single blue color (#3498db)</li>
        <li><strong>Source Text:</strong> Nodes are colored based on their origin text using a 10-color palette:
            <ul style="margin-top: 5px;">
                <li>Text 1: Red (#e74c3c)</li>
                <li>Text 2: Blue (#3498db)</li>
                <li>Text 3: Green (#27ae60)</li>
                <li>Text 4: Purple (#9b59b6)</li>
                <li>Text 5: Orange (#e67e22)</li>
                <li>Text 6: Pink (#e91e63)</li>
                <li>Text 7: Yellow (#f39c12)</li>
                <li>Text 8: Cyan (#1abc9c)</li>
                <li>Text 9: Brown (#795548)</li>
                <li>Text 10+: Grey (#95a5a6)</li>
            </ul>
        </li>
        <li><strong>Cluster (LPA - Fast):</strong> Nodes are colored by community membership using Label Propagation Algorithm:
            <ul style="margin-top: 5px;">
                <li>Automatically detects communities when you click "üìä Network Analysis"</li>
                <li>Uses same 10-color palette (Cluster 1-10)</li>
                <li>Fast convergence (5-20 iterations typical)</li>
                <li>Non-deterministic (results may vary between runs)</li>
                <li>Best for exploratory analysis and quick insights</li>
                <li>Community table appears in Graph tab sidebar</li>
                <li>Cluster IDs exported in edgelist CSV (last two columns)</li>
            </ul>
        </li>
        <li><strong>Cluster (Louvain - Stable):</strong> Nodes are colored by community membership using Louvain Method:
            <ul style="margin-top: 5px;">
                <li>Automatically detects communities via modularity optimization</li>
                <li>Uses same 10-color palette (Cluster 1-10)</li>
                <li>Deterministic (same results every time on same network)</li>
                <li>Optimal modularity (research-standard quality)</li>
                <li>Best for reproducible research and publications</li>
                <li>Community table appears in Graph tab sidebar</li>
                <li>Cluster IDs exported in edgelist CSV (last two columns)</li>
            </ul>
        </li>
        <li><strong>How to Use:</strong> Select your preferred coloring in Settings ‚Üí Click "üìä Network Analysis" ‚Üí Nodes appear colored by source or cluster ‚Üí Click node to view details ‚Üí Export graph/edgelist for analysis.</li>
    </ul>

    <h4>Node Shape (‚è≥ Coming Soon)</h4>
    <ul>
        <li><strong>Circle (Current Default):</strong> All nodes are circles</li>
        <li><strong>By Source Text (Planned):</strong> Different shapes (squares, triangles, diamonds, etc.) for each source text</li>
        <li><strong>By Cluster (Planned):</strong> Different shapes for each detected cluster/community</li>
    </ul>

    <h3>Research Features & Data Export</h3>
    <ul>
        <li><strong>Main Idea Tab:</strong> View and reorder all highlighted segments from all texts. Each segment displays its source text ID (1, 2, 3...), making it easy to track which text each main idea comes from. Drag and drop to arrange them into a coherent narrative. Click "üîÑ Refresh" to update the list, "üìã Copy" to copy to clipboard.</li>
        <li><strong>Edgelist Tab:</strong> View the edgelist of all connections across all canvases in CSV format. Each row includes:
            <ul style="margin-top: 5px;">
                <li>Source node text</li>
                <li>Target node text</li>
                <li>Relation type</li>
                <li>Source text ID (both nodes)</li>
                <li><strong>Cluster IDs (when clustering enabled):</strong> Community membership for both nodes (Source_Cluster, Target_Cluster columns)</li>
            </ul>
            Click "üîÑ Refresh" to update, "üìã Copy" to copy to clipboard, "üíæ Download CSV" to save as a file, or "üìä Network Analysis" to visualize the network.
        </li>
        <li><strong>Network Analysis (Graph Tab):</strong> Interactive network visualization with:
            <ul style="margin-top: 5px;">
                <li>Automatic centrality calculations (4 metrics)</li>
                <li>Community detection (LPA or Louvain algorithms)</li>
                <li>Sortable tables for all metrics and cluster assignments</li>
                <li>Real-time statistics and community counts</li>
                <li>High-resolution PNG export (2x scale)</li>
            </ul>
            Use grey-out to focus on main ideas and replot the network for refined analysis. Configure node size and color in Settings.
        </li>
        <li><strong>Intertextual & Thematic Analysis:</strong> The consistent ID numbering (source text IDs AND cluster IDs) across all features makes it easy to:
            <ul style="margin-top: 5px;">
                <li>Trace relationships between different source texts</li>
                <li>Identify thematic clusters across multiple texts</li>
                <li>Compare community structure between text sources</li>
                <li>Analyze cross-cluster connections (bridge concepts)</li>
            </ul>
        </li>
        <li><strong>Quantitative Metrics:</strong> Export edgelist as CSV for advanced statistical analysis in R, Python, Excel, or network analysis tools. The CSV includes:
            <ul style="margin-top: 5px;">
                <li>7 columns total (source, target, relation, source_text_id, target_text_id, source_cluster, target_cluster)</li>
                <li>Cluster columns populated when clustering enabled (empty otherwise)</li>
                <li>Compatible with NetworkX, igraph, Gephi, and other network analysis software</li>
            </ul>
        </li>
    </ul>

    <h3>Save & Load Your Work</h3>
    <ul>
        <li><strong>üíæ Save Project:</strong> Export your entire work as a JSON file, including:
            <ul style="margin-top: 5px;">
                <li>All text tabs with HTML content and their IDs</li>
                <li>All canvases with textboxes, positions, and sizes</li>
                <li>All connections with relation types and directions</li>
                <li>Highlight colors for each textbox</li>
                <li>Grey-out states for each textbox</li>
                <li>Infer states (dashed borders)</li>
                <li>Network visualization settings (node size, color, shape preferences)</li>
                <li>Canvas zoom levels (per-canvas memory)</li>
                <li>Main idea ordering</li>
                <li>Font size and panel width settings</li>
            </ul>
        </li>
        <li><strong>üìÇ Load Project:</strong> Import a previously saved JSON file to continue your work. All text tabs, canvases, highlight colors, grey-out states, zoom levels, and network settings are restored exactly as saved. Old project files with IDs starting from 0 are automatically migrated to the new system (IDs starting from 1).</li>
        <li><strong>üì• Export SVG (Optional):</strong> Enable in Settings to export the current canvas as an SVG file for vector editing in tools like Adobe Illustrator or Inkscape. Note: HTML content is converted to plain text; text wrapping may differ; connection lines are preserved.</li>
        <li><strong>üñºÔ∏è Snap PNG (Smart Export):</strong> Context-aware PNG export that automatically detects your active tab:
            <ul style="margin-top: 5px;">
                <li><strong>Canvas tabs (1, 2, 3...):</strong> Exports canvas with textboxes and connections at 2x resolution</li>
                <li><strong>Graph tab:</strong> Exports network visualization at 2x resolution with:
                    <ul>
                        <li>All nodes colored and sized according to current settings</li>
                        <li>Community structure visible (if cluster coloring enabled)</li>
                        <li>Edge labels and layout preserved</li>
                        <li>White background for printing/publication</li>
                        <li>Filename includes algorithm name and size metric (e.g., "network-graph-Louvain-betweenness-2025-01-15.png")</li>
                    </ul>
                </li>
                <li><strong>Help/Settings tabs:</strong> Alert prompts you to switch to Canvas or Graph tab</li>
            </ul>
            Always available - no settings needed. Provides publication-quality images for presentations, papers, or sharing.
        </li>
        <li><strong>üíæ Download CSV (Edgelist):</strong> Export the connection data as CSV for quantitative analysis in R, Python, Excel, or other statistical software. CSV includes 7 columns:
            <ul style="margin-top: 5px;">
                <li>Source, Target, Relation, Source_Text_ID, Target_Text_ID</li>
                <li><strong>Source_Cluster, Target_Cluster (NEW):</strong> Community membership when clustering enabled (empty cells when clustering disabled)</li>
            </ul>
        </li>
        <li><strong>Collaborative Analysis:</strong> Share your saved projects (.json files) with colleagues - all source tracking information, color choices, grey-out states, zoom levels, network settings, and connections are preserved for collaborative analysis.</li>
    </ul>

    <h3>Managing Your Workspace</h3>
    <ul>
        <li><strong>Resize Panels:</strong> Drag the vertical separator between text and canvas panels to adjust their widths. Your preferred width is saved with projects.</li>
        <li><strong>Multiple Text Tabs:</strong> Create multiple text tabs for intertextual reading and analysis. Each tab is numbered sequentially (1, 2, 3...) for easy source tracking. Scroll horizontally if you have many tabs. Click the + button to create new tabs.</li>
        <li><strong>Multiple Canvas Tabs:</strong> Use canvas tabs to organize different sections or themes. Canvas tabs are also numbered starting from 1. Scroll horizontally if you have many tabs. Click the + button to create new canvases.</li>
        <li><strong>Graph Tab:</strong> A dedicated tab for network visualization that appears after running network analysis. Preserves your visualization (including community detection results) until you replot or close the application.</li>
        <li><strong>Settings Tab:</strong> Access ‚öôÔ∏è Settings to configure network visualization options (node size, color/clustering, shape) and enable experimental features like SVG export.</li>
        <li><strong>Help Tab:</strong> Access ‚ùî Help to view this comprehensive documentation at any time.</li>
        <li><strong>Collapse Text Panel:</strong> Click the ‚óÄ button on the left panel to hide it for more canvas space. Click the ‚ñ∂ button (appears on the left edge) to show it again.</li>
        <li><strong>Adjust Font Size:</strong> Use A- and A+ buttons in the canvas header to adjust font size throughout the application (10px - 32px range, 16px default). Affects both text tabs and textboxes.</li>
    </ul>
    
    <h3>üîç Canvas Zoom Controls</h3>
    <ul>
        <li><strong>Zoom Range:</strong> 30% to 200% in 10% increments (18 levels: 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%, 110%, 120%, 130%, 140%, 150%, 160%, 170%, 180%, 190%, 200%)</li>
        <li><strong>üîç- Button:</strong> Zoom out by 10%</li>
        <li><strong>üîç+ Button:</strong> Zoom in by 10%</li>
        <li><strong>‚Üª Reset:</strong> Return to 100% zoom</li>
        <li><strong>Keyboard Shortcuts:</strong>
            <ul style="margin-top: 5px;">
                <li><kbd>Ctrl</kbd> + <kbd>+</kbd> (or <kbd>=</kbd>) - Zoom in by 10%</li>
                <li><kbd>Ctrl</kbd> + <kbd>-</kbd> - Zoom out by 10%</li>
                <li><kbd>Ctrl</kbd> + <kbd>0</kbd> - Reset to 100%</li>
            </ul>
        </li>
        <li><strong>Mouse Wheel Zoom:</strong> Hold <kbd>Ctrl</kbd> and scroll to zoom in/out smoothly</li>
        <li><strong>Per-Canvas Memory:</strong> Each canvas remembers its own zoom level independently</li>
        <li><strong>Saved in Projects:</strong> Zoom levels are preserved when you save/load projects</li>
        <li><strong>Smooth Transitions:</strong> Zoom changes are animated for a smooth visual experience</li>
    </ul>

    <h4>Zoom Use Cases:</h4>
    <ul>
        <li><strong>Zoom Out (50%-90%):</strong> See the entire structure at a glance, ideal for presentations, overview mode, and understanding the big picture</li>
        <li><strong>Normal View (100%):</strong> Default editing mode with full detail and comfortable reading</li>
        <li><strong>Zoom In (110%-200%):</strong> Read small text easily, precise positioning of elements, detailed connection editing, and fine-tuning layouts</li>
        <li><strong>Presentation Mode:</strong> Zoom out to 60-70% to fit complex structures on screen for sharing with others</li>
        <li><strong>Detail Work:</strong> Zoom in to 150-200% for working with dense textboxes or intricate connection patterns</li>
    </ul>

    <h3>üí° Tips for Effective Analysis</h3>
    <ul>
        <li><strong>Save Frequently:</strong> Use "üíæ Save Project" regularly to preserve your work. The JSON file contains everything - you can resume exactly where you left off.</li>
        <li><strong>Color Strategy:</strong> Develop a consistent color-coding system (e.g., yellow for main arguments, blue for evidence, pink for counterarguments, green for definitions) to visually organize your analysis. Document your color scheme in a separate text tab for reference.</li>
        <li><strong>Highlight Removal:</strong> Remember you have two quick methods to remove highlights: (1) Right-click the ‚≠ê button to toggle off, or (2) Open the palette and click the ‚úñ striped square. Use whichever feels more natural.</li>
        <li><strong>Connection Methods:</strong> Use drag-to-connect for speed when creating many connections; use click-to-connect for precision when working with overlapping textboxes or small screens.</li>
        <li><strong>Grey-Out Workflow:</strong> Start with all textboxes visible, analyze the full network, then progressively grey out supporting details and replot to see how the core structure emerges. Compare centrality metrics and community structure between runs to identify truly central concepts and stable thematic clusters.</li>
        <li><strong>Community Detection Workflow:</strong>
            <ul style="margin-top: 5px;">
                <li><strong>Exploratory Phase:</strong> Use LPA for quick community discovery - run multiple times to see if stable clusters emerge despite randomization</li>
                <li><strong>Research Phase:</strong> Use Louvain for final analysis and publication - deterministic results ensure reproducibility</li>
                <li><strong>Comparison:</strong> Try both algorithms on same network to validate community structure - strong communities will appear in both</li>
                <li><strong>Iteration:</strong> Grey out textboxes ‚Üí Replot ‚Üí Observe community reorganization ‚Üí Refine structure ‚Üí Repeat</li>
            </ul>
        </li>
        <li><strong>Zoom Strategy:</strong> Use zoom levels strategically - zoom out (50-70%) for overview and planning, normal (100%) for editing, zoom in (130-200%) for detail work. Each canvas remembers its zoom, so you can maintain different zoom levels for different analytical perspectives.</li>
        <li><strong>Source Tracking:</strong> Pay attention to source IDs in textboxes (bottom-right corner of control panel) - they help maintain intertextual coherence and prevent confusion about which text a segment originates from. Enable source text coloring in network graphs for visual source tracking.</li>
        <li><strong>Network Analysis Workflow:</strong>
            <ul style="margin-top: 5px;">
                <li><strong>First run:</strong> See the complete structure with all textboxes</li>
                <li><strong>Community detection:</strong> Enable clustering (LPA or Louvain) to discover thematic groups</li>
                <li><strong>Identify peripheral details:</strong> Look for nodes in small clusters or with low centrality</li>
                <li><strong>Grey out peripheral textboxes</strong></li>
                <li><strong>Second run:</strong> Focus on core relationships and main ideas - observe community reorganization</li>
                <li><strong>Compare metrics:</strong> Analyze how centrality and modularity change between full and filtered networks</li>
                <li><strong>Export visualizations:</strong> Save both networks as PNG for comparison in presentations</li>
                <li><strong>Export data:</strong> Download edgelist CSV with cluster IDs for statistical analysis</li>
            </ul>
        </li>
        <li><strong>Centrality Interpretation:</strong> Use centrality metrics to identify:
            <ul style="margin-top: 5px;">
                <li>High degree nodes = main topics/themes (most connected)</li>
                <li>High betweenness nodes = transitional or linking concepts (bridges between communities)</li>
                <li>High closeness nodes = central organizing ideas (frameworks)</li>
                <li>High eigenvector nodes = influential/authoritative concepts (connected to other important ideas)</li>
            </ul>
        </li>
        <li><strong>Community Interpretation:</strong> Use cluster analysis to:
            <ul style="margin-top: 5px;">
                <li>Identify main themes or topics in your text(s)</li>
                <li>Discover coherent argument chains</li>
                <li>Find cross-cutting concepts (nodes that appear in multiple clusters when using different filtering)</li>
                <li>Locate bridge concepts (high betweenness nodes connecting different communities)</li>
                <li>Compare thematic organization across different source texts (source coloring vs. cluster coloring)</li>
            </ul>
        </li>
        <li><strong>Sortable Tables:</strong> Click any metric header (Degree, Betweenness, Closeness, Eigenvector, Community Detection) to cycle through sort orders (‚ñº descending ‚Üí ‚ñ≤ ascending ‚Üí no arrow/original). Use this to quickly find top-ranked nodes or largest clusters.</li>
        <li><strong>Panel Organization:</strong> Resize panels based on current task - more space for text when reading and annotating, more space for canvas when analyzing structure or building networks.</li>
        <li><strong>Canvas Organization:</strong> Use multiple canvas tabs for different analytical perspectives:
            <ul style="margin-top: 5px;">
                <li>Canvas 1: Chronological ordering of events/ideas (zoom out to 60%)</li>
                <li>Canvas 2: Thematic clustering of related concepts (zoom in to 120%)</li>
                <li>Canvas 3: Argumentative flow and logic (normal 100%)</li>
                <li>Canvas 4: Evidence and support mapping (zoom out to 70%)</li>
            </ul>
        </li>
        <li><strong>Infer Feature:</strong> Use the üí≠ infer button to distinguish between explicitly stated content and inferred/implied content - crucial for rigorous analysis and avoiding over-interpretation.</li>
        <li><strong>HTML Leverage:</strong> Use HTML support for multimodal analysis with images, tables, and rich formatting. Upload HTML files from web archives, course materials, or exported documents for comprehensive analysis.</li>
        <li><strong>Custom Connections:</strong> Use the custom connection type to define your own relationships beyond the standard types (e.g., "refutes", "extends", "exemplifies", "problematizes").</li>
        <li><strong>Export Strategy:</strong>
            <ul style="margin-top: 5px;">
                <li><strong>CSV edgelist (with clusters):</strong> For quantitative analysis in R/Python/Excel - includes community IDs when clustering enabled</li>
                <li><strong>PNG snapshots:</strong> For presentations, papers, and quick sharing:
                    <ul>
                        <li>Canvas tabs: Zoom out for full overview before exporting</li>
                        <li>Graph tab: Automatically exports current visualization with communities colored</li>
                    </ul>
                </li>
                <li><strong>SVG export (experimental):</strong> For vector editing and publication-quality diagrams</li>
                <li><strong>JSON project:</strong> For archiving, resuming work, and sharing complete analysis (includes zoom levels and settings)</li>
            </ul>
        </li>
        <li><strong>Collaborative Workflow:</strong> Share JSON project files with colleagues via email or cloud storage - all source tracking information, color choices, grey-out states, zoom levels, network settings, and connections are preserved. Everyone can resume work with identical states.</li>
        <li><strong>Incremental Analysis:</strong> Don't try to create all textboxes and connections at once. Read ‚Üí Segment key ideas ‚Üí Connect ‚Üí Analyze ‚Üí Detect communities ‚Üí Refine ‚Üí Repeat. Build your analysis progressively as you deepen your understanding.</li>
    </ul>

    <h3>üéì Pedagogical Applications</h3>
    <ul>
        <li><strong>Reading Comprehension:</strong> Segment texts to identify main ideas vs. supporting details using the grey-out feature. Visualize the hierarchical structure through network analysis. Use community detection to discover thematic organization. Use zoom to focus on specific sections.</li>
        <li><strong>Argument Analysis:</strong> Map argumentative structures using connection types (cause, solution, sequence, etc.). Identify premises, claims, and evidence through textbox highlighting and connection patterns. Use community detection to find coherent argument chains. Zoom out to see the full argumentative flow.</li>
        <li><strong>Intertextual Studies:</strong> Compare multiple texts side-by-side with clear source tracking. Use different text tabs for different sources, then analyze how ideas connect across texts using the network graph with source text coloring OR cluster coloring to see cross-text themes. Export edgelist with both source and cluster IDs for advanced analysis.</li>
        <li><strong>Network Thinking:</strong> Visualize how ideas interconnect and identify central concepts through centrality metrics. Develop graph literacy by comparing different network structures. Introduce students to community detection algorithms and modularity optimization.</li>
        <li><strong>Thematic Analysis:</strong> Use community detection (LPA or Louvain) to automatically discover thematic clusters in literary texts, research papers, or argumentative essays. Compare algorithm results to manual thematic coding. Analyze bridge concepts connecting different themes.</li>
        <li><strong>Academic Writing:</strong> Plan essay structures by arranging and connecting textboxes before writing. Use connection types to clarify logical relationships. Use community detection to ensure coherent thematic organization. Export the structure as PNG for reference while drafting. Zoom in for detailed outlining, zoom out to check overall coherence.</li>
        <li><strong>Literature Review:</strong> Organize and relate findings from multiple sources using different text tabs. Track which claims come from which sources. Use cluster detection to identify research themes and knowledge gaps. Locate bridge studies (high betweenness) that connect different research streams.</li>
        <li><strong>Discourse Analysis:</strong> Analyze how arguments develop across a text. Use sequence connections for temporal flow, cause connections for logical development, and custom connections for rhetorical moves. Apply community detection to identify discourse patterns.</li>
        <li><strong>Collaborative Learning:</strong> Share project files with students or peers for peer review and collaborative annotation. Build shared understanding of complex texts through joint analysis. Compare individual community detection results to develop consensus on thematic organization. Zoom levels help focus discussions on specific areas.</li>
        <li><strong>Presentation Preparation:</strong> Use zoom-out mode (50-70%) to create overview screenshots for slides. Zoom in (150%+) to create detailed close-ups of specific sections. Export network graphs with community coloring to illustrate thematic structure. Export multiple PNG files at different zoom levels for comprehensive presentations.</li>
        <li><strong>Research Methods Training:</strong> Teach network analysis concepts (centrality, modularity, community detection) with real student-generated data. Compare LPA vs. Louvain results to discuss algorithm trade-offs. Use sortable tables to teach data literacy and ranking interpretation.</li>
    </ul>

    <h3>Credits</h3>
    <div class="credits">
        <p><strong>Designer:</strong> LAM Wai Ip (HKU)</p>
        <p><strong>Developer:</strong> Claude 3.5 Sonnet (Anthropic)</p>
        <p><strong>Date:</strong> <span id="currentDateTime"></span></p>
        <p><strong>Version:</strong> 92.0 (Stable Release - Community Detection & Smart PNG Export)</p>
        <p><strong>Theoretical Framework:</strong> Bonnie Meyer's Theory of Prose Organisation</p>
        <p><strong>Network Visualization:</strong> Cytoscape.js 3.26.0</p>
        <p><strong>Community Detection Algorithms:</strong> Label Propagation Algorithm (LPA) & Louvain Method</p>
        <p><strong>Screenshot Capture:</strong> html2canvas 1.4.1</p>
    </div>

    <hr style="margin: 30px 0; border: none; border-top: 1px solid #ddd;">

    <h3>License & Citation</h3>
    <p>This application is provided free of charge for educational and research purposes.</p>
    <p>If you use this application in your research or teaching, please cite:</p>
    <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; border-left: 4px solid #3498db; font-family: 'Courier New', monospace; white-space: pre-wrap;">Lam, W. I. (2025). Text Structure Analysis Platform: Network-Based Intertextual 
Analysis Tool with Community Detection (Version 92.0) [Web Application]. 
The University of Hong Kong. Based on Meyer, B. J. F. (1975). The Organization 
of Prose and Its Effects on Memory.</pre>

    <hr style="margin: 30px 0; border: none; border-top: 1px solid #ddd;">

    <h3>Feedback & Support</h3>
    <p>For questions, bug reports, feature requests, or collaboration opportunities, please contact:</p>
    <p>
        üìß Official: <a href="mailto:jwilam@hku.hk" style="color: #3498db; text-decoration: none;">jwilam@hku.hk</a><br>
        üìß Personal: <a href="mailto:jwilam@gmail.com" style="color: #3498db; text-decoration: none;">jwilam@gmail.com</a>
    </p>
    <p style="margin-top: 15px;"><em>We welcome your feedback to improve this platform! Report bugs, suggest features, or share your use cases.</em></p>

    <hr style="margin: 30px 0; border: none; border-top: 1px solid #ddd;">

</div>
</div>
            </div>
        </div>
    </div>

    <div class="drag-preview" id="dragPreview"></div>
    <div class="success-message" id="successMessage">Copied to clipboard!</div>

    <div class="dialog-overlay" id="dialogOverlay">
        <div class="dialog">
            <h3 id="dialogTitle">Select Relation Type</h3>
            <div class="relation-options">
                <button class="relation-btn" onclick="selectRelation('description')">Description (Half dotted line ¬∑¬∑¬∑¬∑¬∑‚îÄ‚îÄ‚îÄ)</button>
                <button class="relation-btn" onclick="selectRelation('comparison')">Comparison (Double arrow ‚Üî)</button>
                <button class="relation-btn" onclick="selectRelation('contrast')">Contrast (Directional double arrow ‚ü®¬∑¬∑¬∑¬∑¬∑‚Üê‚Üí‚îÄ‚îÄ‚îÄ‚ñ∂)</button>
                <button class="relation-btn" onclick="selectRelation('analogy')">Analogy (Double line)</button>
                <button class="relation-btn" onclick="selectRelation('sequence')">Sequence (Arrow ‚îÄ‚îÄ‚ñ∂)</button>
                <button class="relation-btn" onclick="selectRelation('cause')">Cause (Arrow ‚îÄ‚îÄ‚ñ∂)</button>
                <button class="relation-btn" onclick="selectRelation('solution')">Solution (Arrow ‚îÄ‚îÄ‚ñ∂)</button>
                <button class="relation-btn" onclick="selectRelation('source')">Source (Half dotted line ¬∑¬∑¬∑¬∑¬∑‚îÄ‚îÄ‚îÄ)</button>
                <div class="custom-label-container">
                    <label>Custom:</label>
                    <input type="text" id="customLabelInput" class="custom-label-input" placeholder="Enter label" value="connection">
                    <button class="relation-btn" onclick="selectCustomRelation()" style="padding: 8px 16px; margin: 0;">Connect (‚óè¬∑¬∑¬∑¬∑¬∑‚îÄ‚îÄ‚îÄ‚óè)</button>
                </div>
            </div>
            <div class="dialog-actions">
                <button class="cancel-btn" onclick="cancelConnection()">Cancel</button>
                <button class="delete-connection-btn" id="deleteConnectionBtn" style="display: none;" onclick="deleteCurrentConnection()">Delete Connection</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
	
<!-- ‚≠ê‚≠ê‚≠ê PHASE 4.1: Jieba.js Dependencies ‚≠ê‚≠ê‚≠ê -->
<script src="https://jwilam.github.io/jieba/scripts_jieba/require.js"></script>
<script>
    // Global jieba instance - will be initialized after page load
    var jiebaInstance = null;
    
    // Load jieba module using RequireJS
    requirejs.config({
        baseUrl: 'https://jwilam.github.io/jieba/scripts_jieba',  // ‚úÖ Full GitHub URL
        paths: {
            'jieba': 'jieba',
            'finalseg': 'finalseg'
        }
    });
    
    // Initialize jieba when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        requirejs(['jieba'], function(jieba) {
            jiebaInstance = jieba;
            console.log('‚úÖ Jieba.js loaded successfully');
            console.log('üìö Dictionary size:', jieba.dict ? 'loaded' : 'loading...');
        });
    });
</script>
<!-- ============================================================================ -->	

    <script>
	
		
		// ============================================================================
		// ‚≠ê‚≠ê‚≠ê PHASE 4.2: STOPWORDS DATABASES ‚≠ê‚≠ê‚≠ê
		// ============================================================================

// English stopwords (from stopwords_en.txt - condensed for space)
const STOPWORDS_EN = new Set([
    "a", "about", "above", "after", "again", "against", "all", "am", "an", "and", 
    "any", "are", "aren't", "as", "at", "be", "because", "been", "before", "being",
    "below", "between", "both", "but", "by", "can", "cannot", "can't", "could",
    "couldn't", "did", "didn't", "do", "does", "doesn't", "doing", "don't", "down",
    "during", "each", "few", "for", "from", "further", "had", "hadn't", "has",
    "hasn't", "have", "haven't", "having", "he", "he'd", "he'll", "her", "here",
    "here's", "hers", "herself", "he's", "him", "himself", "his", "how", "how's",
    "i", "i'd", "if", "i'll", "i'm", "in", "into", "is", "isn't", "it", "it's",
    "its", "itself", "i've", "let's", "me", "more", "most", "mustn't", "my",
    "myself", "no", "nor", "not", "of", "off", "on", "once", "only", "or", "other",
    "ought", "our", "ours", "ourselves", "out", "over", "own", "same", "shan't",
    "she", "she'd", "she'll", "she's", "should", "shouldn't", "so", "some", "such",
    "than", "that", "that's", "the", "their", "theirs", "them", "themselves",
    "then", "there", "there's", "these", "they", "they'd", "they'll", "they're",
    "they've", "this", "those", "through", "to", "too", "under", "until", "up",
    "very", "was", "wasn't", "we", "we'd", "we'll", "were", "we're", "weren't",
    "we've", "what", "what's", "when", "when's", "where", "where's", "which",
    "while", "who", "whom", "who's", "why", "why's", "with", "won't", "would",
    "wouldn't", "you", "you'd", "you'll", "your", "you're", "yours", "yourself",
    "yourselves", "you've",
    // Punctuation
    "!", "#", "$", "%", "&", "(", ")", "*", ",", ".", ":", ";", "?", "@", "[", 
    "]", "{", "|", "}", "~", "^", "'", "\"", "¬•", "+", "<", ">", "0", "1", "2", 
    "3", "4", "5", "6", "7", "8", "9", "\\", "/", "=", "-", "_", "`"
]);

// Chinese stopwords (from stopwords_zh.txt - condensed)
const STOPWORDS_ZH = new Set([
    "ÔºÅ", "ÔºÉ", "ÔºÑ", "ÔºÖ", "ÔºÜ", "Ôºà", "Ôºâ", "Ôºä", "Ôºå", "„ÄÅ", "„ÄÇ", "Ôºö", "Ôºõ",
    "Ôºü", "Ôº†", "Ôºª", "ÔºΩ", "ÔΩõ", "ÔΩú", "ÔΩù", "ÔΩû", "„Äà", "Ô∏ø", "„Äâ", "„Ää", "„Äã",
    "Ôºá", "ÔºÇ", "„Äå", "„Äç", "„Äé", "„Äè", "Ôø•", "Ôºã", "Ôºú", "Ôºû", "Ôºê", "Ôºë",
    "Ôºí", "Ôºì", "Ôºî", "Ôºï", "Ôºñ", "Ôºó", "Ôºò", "Ôºô", "‰∏Ä", "‰∏Ä‰∏™", "‰∏Ä‰∫õ", "‰∏Ä‰Ωï",
    "‰∏Ä‰æÜ", "‰∏ÄÂÄã", "‰∏ÄÂàá", "‰∏ÄÂàô", "‰∏ÄÂâá", "‰∏ÄÊñπÈù¢", "‰∏ÄÊó¶", "‰∏ÄÊù•", "‰∏ÄÊ†∑",
    "‰∏ÄÊ®£", "‰∏ÄÁßç", "‰∏ÄÁ®Æ", "‰∏ÄËà¨", "‰∏ÄËΩâÁúº", "‰∏ÄËΩ¨Áúº", "‰∏É", "‰∏á‰∏Ä", "‰∏â", "‰∏ä",
    "‰∏ä‰∏ã", "‰∏ã", "‰∏ç", "‰∏ç‰ªÖ", "‰∏ç‰ΩÜ", "‰∏çÂÉÖ", "‰∏çÂÑòÁÑ∂", "‰∏çÂÖâ", "‰∏çÂçï", "‰∏çÂè™",
    "‰∏çÂïè", "‰∏çÂñÆ", "‰∏çÂ§ñ‰πé", "‰∏çÂ¶Ç", "‰∏çÂ¶®", "‰∏çÂ∞Ω", "‰∏çÂ∞ΩÁÑ∂", "‰∏çÂæó", "‰∏çÊÄï",
    "‰∏çÊÉü", "‰∏çÊàê", "‰∏çÊãò", "‰∏çÊñô", "‰∏çÊòØ", "‰∏çÊØî", "‰∏çÁÑ∂", "‰∏çÁâπ", "‰∏çÁã¨",
    "‰∏çÁç®", "‰∏çÁõ°", "‰∏çÁÆ°", "‰∏çËá≥‰∫é", "‰∏çËá≥Êñº", "‰∏çËã•", "‰∏çË´ñ", "‰∏çËÆ∫", "‰∏çËøá",
    "‰∏çÈÅé", "‰∏çÈóÆ", "‰∏é", "‰∏éÂÖ∂", "‰∏éÂÖ∂ËØ¥", "‰∏éÂê¶", "‰∏éÊ≠§ÂêåÊó∂", "‰∏î", "‰∏î‰∏çË™™",
    "‰∏î‰∏çËØ¥", "‰∏îË™™", "‰∏îËØ¥", "‰∏§ËÄÖ", "‰∏¶", "‰∏¶‰∏î", "‰∏™", "‰∏™Âà´", "‰∏≠", "‰∏¥",
    "‰∏∫", "‰∏∫‰∫Ü", "‰∏∫‰ªÄ‰πà", "‰∏∫‰Ωï", "‰∏∫Ê≠¢", "‰∏∫Ê≠§", "‰∏∫ÁùÄ", "‰πÉ", "‰πÉËá≥",
    "‰πÉËá≥‰∫é", "‰πÉËá≥Êñº", "‰πà", "‰πã", "‰πã‰∏Ä", "‰πãÊâÄ‰ª•", "‰πãÁ±ª", "‰πãÈ°û", "‰πå‰πé",
    "‰πé", "‰πò", "‰πù", "‰πü", "‰πüÂ•Ω", "‰πüÁΩ¢", "‰πüÁΩ∑", "‰∫Ü", "‰∫å", "‰∫å‰æÜ", "‰∫åÊù•",
    "‰∫é", "‰∫éÊòØ", "‰∫éÊòØ‰πé", "‰∫ë‰∫ë", "‰∫ëÂ∞î", "‰∫î", "‰∫õ", "‰∫¶", "‰∫∫", "‰∫∫‰ª¨",
    "‰∫∫ÂÄë", "‰∫∫ÂÆ∂", "‰ªÄ", "‰ªÄ‰πà", "‰ªÄ‰πàÊ†∑", "‰ªÄÈ∫º", "‰ªÄÈ∫ºÊ®£", "‰ªä", "‰ªã‰∫é",
    "‰ªãÊñº", "‰ªç", "‰ªçÊóß", "‰ªçËàä", "‰ªé", "‰ªéÊ≠§", "‰ªéËÄå", "‰ªñ", "‰ªñ‰∫∫", "‰ªñ‰ª¨",
    "‰ªñ‰ª¨‰ª¨", "‰ªñÂÄë", "‰ªñÂÄëÂÄë", "‰ª•", "‰ª•‰∏ä", "‰ª•‰∏∫", "‰ª•‰æÜ", "‰ª•‰æø", "‰ª•ÂÖç",
    "‰ª•Âèä", "‰ª•ÊïÖ", "‰ª•Êúü", "‰ª•Êù•", "‰ª•ÁÇ∫", "‰ª•Ëá≥", "‰ª•Ëá≥‰∫é", "‰ª•Ëá≥Êñº", "‰ª•Ëá¥",
    "‰ª¨", "‰ªª", "‰ªª‰Ωï", "‰ªªÂá≠", "‰ªªÊÜë", "‰ºö", "‰ººÁöÑ", "‰ΩÜ", "‰ΩÜÂá°", "‰ΩÜÊòØ",
    "‰Ωï", "‰Ωï‰ª•", "‰ΩïÂÜµ", "‰ΩïÂ§Ñ", "‰ΩïÊó∂", "‰ΩïÊôÇ", "‰ΩïÊ≥Å", "‰ΩïËôï", "‰ΩôÂ§ñ",
    "‰Ωú‰∏∫", "‰ΩúÁÇ∫", "‰Ω†", "‰Ω†‰ª¨", "‰Ω†ÂÄë", "‰Ωø", "‰ΩøÂæó", "‰æÜ", "‰æÜËá™", "‰æÜËëó",
    "‰æÜË™™", "‰æãÂ¶Ç", "‰æù", "‰æùÊçÆ", "‰æùÊìö", "‰æùÁÖß", "‰æø‰∫é", "‰æøÊñº", "‰ø∫", "‰ø∫‰ª¨",
    "‰ø∫ÂÄë", "ÂÄã", "ÂÄãÂà•", "ÂÄë", "ÂÄò", "ÂÄò‰Ωø", "ÂÄòÊàñ", "ÂÄòÁÑ∂", "ÂÄòËã•", "ÂÄü",
    "ÂÄüÂÇ•ÁÑ∂", "ÂÄüÂÑªÁÑ∂", "ÂÅá‰Ωø", "ÂÅáÂ¶Ç", "ÂÅáËã•", "ÂÅö", "ÂÉè", "ÂÑòÁÆ°", "ÂÑòÁÆ°Â¶ÇÊ≠§",
    "ÂÑø", "ÂÖà‰∏çÂÖà", "ÂÖâ", "ÂÖâÊòØ", "ÂÖí", "ÂÖß", "ÂÖ®‰Ωì", "ÂÖ®ÈÉ®", "ÂÖ®È´î", "ÂÖ©ËÄÖ",
    "ÂÖ´", "ÂÖ≠", "ÂÖÆ", "ÂÖ±", "ÂÖ≥‰∫é", "ÂÖ≥‰∫éÂÖ∑‰ΩìÂú∞ËØ¥", "ÂÖ∂", "ÂÖ∂‰∏Ä", "ÂÖ∂‰∏≠", "ÂÖ∂‰∫å",
    "ÂÖ∂‰ªñ", "ÂÖ∂‰Ωô", "ÂÖ∂ÂÆÉ", "ÂÖ∂Ê¨°", "ÂÖ∂È§ò", "ÂÖ∑‰ΩìÂú∞ËØ¥", "ÂÖ∑‰ΩìËØ¥Êù•", "ÂÖ∑È´îÂú∞Ë™™",
    "ÂÖ∑È´îË™™‰æÜ", "ÂÖº‰πã", "ÂÜÖ", "ÂÜç", "ÂÜçÂÖ∂Ê¨°", "ÂÜçÂàô", "ÂÜçÂâá", "ÂÜçÊúâ", "ÂÜçËÄÖ",
    "ÂÜçËÄÖË™™", "ÂÜçËÄÖËØ¥", "ÂÜçË™™", "ÂÜçËØ¥", "ÂÜí", "ÂÜ≤", "ÂÜµ‰∏î", "Âá†", "Âá†Êó∂", "Âá°",
    "Âá°ÊòØ", "Âá≠", "Âá≠ÂÄü", "Âá∫‰∫é", "Âá∫‰æÜ", "Âá∫Êñº", "Âá∫Êù•", "ÂàÜ", "ÂàÜÂà•", "ÂàÜÂà´",
    "Âàô", "ÂàôÁîö", "Âà•", "Âà•‰∫∫", "Âà•ÊòØ", "Âà•ÁöÑ", "Âà•ÁÆ°", "Âà•Ëôï", "Âà•Ë™™", "Âà´",
    "Âà´‰∫∫", "Âà´Â§Ñ", "Âà´ÊòØ", "Âà´ÁöÑ", "Âà´ÁÆ°", "Âà´ËØ¥", "Âà∞", "Ââá", "ÂâáÁîö", "ÂâçÂêé",
    "ÂâçÂæå", "ÂâçÊ≠§", "ÂâçËÄÖ", "Âä†‰πã", "Âä†‰ª•", "Âå∫", "ÂçÄ", "Âç≥", "Âç≥‰ª§", "Âç≥‰Ωø",
    "Âç≥‰æø", "Âç≥Â¶Ç", "Âç≥Êàñ", "Âç≥Ëã•", "Âç¥", "Âçª", "Âéª", "Âèà", "ÂèàÂèä", "Âèä",
    "ÂèäÂÖ∂", "ÂèäËá≥", "Âèç‰πã", "ÂèçËÄå", "ÂèçËøáÊù•", "ÂèçËøáÊù•ËØ¥", "ÂèçÈÅé‰æÜ", "ÂèçÈÅé‰æÜË™™",
    "ÂèóÂà∞", "Âè¶", "Âè¶‰∏ÄÊñπÈù¢", "Âè¶Â§ñ", "Âè¶ÊÇâ", "Âè™", "Âè™ÂΩì", "Âè™ÊÄï", "Âè™ÊòØ",
    "Âè™Êúâ", "Âè™Ê∂à", "Âè™Áï∂", "Âè™Ë¶Å", "Âè™Èôê", "Âè´", "ÂèÆÂíö", "ÂèØ", "ÂèØ‰ª•", "ÂèØÊòØ",
    "ÂèØË¶ã", "ÂèØËßÅ", "ÂêÑ", "ÂêÑ‰∏™", "ÂêÑ‰Ωç", "ÂêÑÂÄã", "ÂêÑÁßç", "ÂêÑÁ®Æ", "ÂêÑËá™", "Âêå",
    "ÂêåÊó∂", "ÂêåÊôÇ", "Âêé", "ÂêéËÄÖ", "Âêë", "Âêë‰Ωø", "ÂêëÁùÄ", "ÂêëËëó", "Âêì", "Âêó",
    "Âê¶Âàô", "Âê¶Ââá", "Âêß", "ÂêßÂìí", "ÂêßÂô†", "Âê´", "Âê±", "ÂëÄ", "ÂëÉ", "Âëï", "Âëó",
    "Âëú", "ÂëúÂëº", "Âë¢", "Âëµ", "ÂëµÂëµ", "Âë∏", "ÂëºÂìß", "Âíã", "Âíå", "Âíö", "Âí¶",
    "Âíß", "Âí±", "Âí±‰ª¨", "Âí±ÂÄë", "Âí≥", "Âìá", "Âìà", "ÂìàÂìà", "Âìâ", "Âìé", "ÂìéÂëÄ",
    "ÂìéÂìü", "ÂìéÂñ≤", "Âìó", "Âìü", "Âì¶", "Âì©", "Âì™", "Âì™‰∏™", "Âì™‰∫õ", "Âì™ÂÄã", "Âì™ÂÑø",
    "Âì™ÂÖí", "Âì™Â§©", "Âì™Âπ¥", "Âì™ÊÄï", "Âì™Ê†∑", "Âì™Ê®£", "Âì™Ë£°", "Âì™Ëæπ", "Âì™ÈÇä",
    "Âì™Èáå", "Âìº", "ÂìºÂî∑", "ÂîÑ", "Âîâ", "ÂîØÊúâ", "Âïä", "Âïê", "Âï•", "Âï¶", "Âï™Ëææ",
    "Âï™ÈÅî", "Âï∑ÂΩì", "Âï∑Áï∂", "ÂñÇ", "Âñè", "ÂñîÂî∑", "Âñ≤", "ÂñΩ", "Âóé", "Âóö", "ÂóöÂëº",
    "Âó°", "Âó°Âó°", "Âó¨", "ÂóØ", "Âó≥", "Âòç", "Âòé", "ÂòéÁôª", "Âòî", "Âòò", "Âòõ", "Âò©",
    "Âòª", "Âòø", "ÂòøÂòø", "Âôì", "ÂôØ", "Âöá", "Âõõ", "Âõ†", "Âõ†‰∏∫", "Âõ†‰∫Ü", "Âõ†Ê≠§",
    "Âõ†ÁÇ∫", "Âõ†ÁùÄ", "Âõ†ËÄå", "Âõ†Ëëó", "Âõ∫ÁÑ∂", "Âú®", "Âú®‰∏ã", "Âú®‰∫é", "Âú®Êñº", "Âú∞",
    "Âü∫‰∫é", "Âü∫Êñº", "Â§ÑÂú®", "Â§ö", "Â§ö‰πà", "Â§öÂ∞ë", "Â§öÈ∫º", "Â§ß", "Â§ßÂÆ∂", "Â•π",
    "Â•π‰ª¨", "Â•πÂÄë", "Â•Ω", "Â¶Ç", "Â¶Ç‰∏ä", "Â¶Ç‰∏äÊâÄËø∞", "Â¶Ç‰∏ã", "Â¶Ç‰Ωï", "Â¶ÇÂÖ∂",
    "Â¶ÇÂêå", "Â¶ÇÊòØ", "Â¶ÇÊûú", "Â¶ÇÊ≠§", "Â¶ÇËã•", "ÂßãËÄå", "Â≠∞Êñô", "Â≠∞Áü•", "ÂÆÅ", "ÂÆÅÂèØ",
    "ÂÆÅÊÑø", "ÂÆÅËÇØ", "ÂÆÉ", "ÂÆÉ‰ª¨", "ÂÆÉÂÄë", "ÂØß", "ÂØßÂèØ", "ÂØßËÇØ", "ÂØßÈ°ò", "ÂØπ",
    "ÂØπ‰∫é", "ÂØπÂæÖ", "ÂØπÊñπ", "ÂØπÊØî", "Â∞Ü", "Â∞á", "Â∞ç", "Â∞çÂæÖ", "Â∞çÊñπ", "Â∞çÊñº",
    "Â∞çÊØî", "Â∞è", "Â∞î", "Â∞îÂêé", "Â∞îÂ∞î", "Â∞ö‰∏î", "Â∞±", "Â∞±ÊòØ", "Â∞±ÊòØ‰∫Ü", "Â∞±ÊòØË™™",
    "Â∞±ÊòØËØ¥", "Â∞±ÁÆó", "Â∞±Ë¶Å", "Â∞Ω", "Â∞ΩÁÆ°", "Â∞ΩÁÆ°Â¶ÇÊ≠§", "Â≤Ç‰ΩÜ", "Â∑±", "Â∑≤",
    "Â∑≤Áü£", "Â∑¥", "Â∑¥Â∑¥", "Âπ¥", "Âπ∂", "Âπ∂‰∏î", "Âπæ", "ÂπæÊôÇ", "Â∫∂‰πé", "Â∫∂Âá†",
    "Â∫∂Âπæ", "ÂºÄÂ§ñ", "ÂºÄÂßã", "ÂΩí", "ÂΩíÈΩê", "ÂΩì", "ÂΩìÂú∞", "ÂΩìÁÑ∂", "ÂΩìÁùÄ", "ÂΩº",
    "ÂΩºÊó∂", "ÂΩºÊôÇ", "ÂΩºÊ≠§", "ÂæÄ", "ÂæÖ", "Âæà", "Âæå", "ÂæåËÄÖ", "Âæó", "Âæó‰∫Ü", "Âæû",
    "ÂæûÊ≠§", "ÂæûËÄå", "ÊÄé", "ÊÄé‰πà", "ÊÄé‰πàÂäû", "ÊÄé‰πàÊ†∑", "ÊÄéÂ•à", "ÊÄéÊ†∑", "ÊÄéÊ®£",
    "ÊÄéÈ∫º", "ÊÄéÈ∫ºÊ®£", "ÊÄéÈ∫ºËæ¶", "ÊÄª‰πã", "ÊÄªÁöÑÊù•Áúã", "ÊÄªÁöÑÊù•ËØ¥", "ÊÄªÁöÑËØ¥Êù•",
    "ÊÄªËÄåË®Ä‰πã", "ÊÅ∞ÊÅ∞Áõ∏Âèç", "ÊÇ®", "ÊÉüÂÖ∂", "ÊÖ¢Ë™™", "ÊÖ¢ËØ¥", "ÊÜë", "ÊÜëËóâ", "Êàë",
    "Êàë‰ª¨", "ÊàëÂÄë", "Êàñ", "ÊàñÂàô", "ÊàñÂâá", "ÊàñÊòØ", "ÊàñÊõ∞", "ÊàñËÄÖ", "Êà™Ëá≥", "ÊâÄ",
    "ÊâÄ‰ª•", "ÊâÄÂú®", "ÊâÄÂπ∏", "ÊâÄÊúâ", "Êâç", "ÊâçËÉΩ", "Êâì", "Êâì‰ªé", "ÊâìÂæû", "Êää",
    "ÊäëÊàñ", "Êãø", "Êåâ", "ÊåâÁÖß", "Êç¢Âè•ËØùËØ¥", "Êç¢Ë®Ä‰πã", "ÊçÆ", "ÊçÆÊ≠§", "Êé•ÁùÄ",
    "Êé•Ëëó", "ÊèõÂè•Ë©±Ë™™", "ÊèõË®Ä‰πã", "Êìö", "ÊìöÊ≠§", "ÊïÖ", "ÊïÖÊ≠§", "ÊïÖËÄå", "Êñº",
    "ÊñºÊòØ", "ÊñºÊòØ‰πé", "ÊóÅ‰∫∫", "Êó†", "Êó†ÂÆÅ", "Êó†ËÆ∫", "Êó¢", "Êó¢ÂæÄ", "Êó¢ÊòØ", "Êó¢ÁÑ∂",
    "Êó•", "Êó∂", "Êó∂ÂÄô", "ÊòØ", "ÊòØ‰ª•", "ÊòØÁöÑ", "ÊôÇ", "ÊôÇÂÄô", "Êõ¥", "Êõæ", "Êõø",
    "Êõø‰ª£", "ÊúÄ", "ÊúÉ", "Êúà", "Êúâ", "Êúâ‰∫õ", "ÊúâÂÖ≥", "ÊúâÂèä", "ÊúâÊó∂", "ÊúâÊôÇ",
    "ÊúâÁöÑ", "ÊúâÈóú", "Êúõ", "Êúù", "ÊúùÁùÄ", "ÊúùËëó", "Êú¨", "Êú¨‰∫∫", "Êú¨Âú∞", "Êú¨ÁùÄ",
    "Êú¨Ëëó", "Êú¨Ë∫´", "Êù•", "Êù•ÁùÄ", "Êù•Ëá™", "Êù•ËØ¥", "ÊûÅ‰∫Ü", "ÊûúÁÑ∂", "ÊûúÁúü", "Êüê",
    "Êüê‰∏™", "Êüê‰∫õ", "ÊüêÂÄã", "ÊüêÊüê", "Ê†πÊçÆ", "Ê†πÊìö", "Ê•µ‰∫Ü", "Ê¨§", "Ê≠ü", "Ê≠£ÂÄº",
    "Ê≠£Â¶Ç", "Ê≠£Â∑ß", "Ê≠£ÊòØ", "Ê≠§", "Ê≠§Âú∞", "Ê≠§Â§Ñ", "Ê≠§Â§ñ", "Ê≠§Êó∂", "Ê≠§ÊôÇ", "Ê≠§Ê¨°",
    "Ê≠§Ëôï", "Ê≠§Èñì", "Ê≠§Èó¥", "Ê≠∏", "Ê≠∏ÈΩä", "ÊØãÂÆÅ", "ÊØãÂØß", "ÊØè", "ÊØèÂΩì", "ÊØèÁï∂",
    "ÊØî", "ÊØîÂèä", "ÊØîÂ¶Ç", "ÊØîÊñπ", "Ê≤íÂ•à‰Ωï", "Ê≤ñ", "Ê≤°Â•à‰Ωï", "Ê≤ø", "Ê≤øÁùÄ", "Ê≤øËëó",
    "Ê≥Å‰∏î", "Êº´Ë™™", "Êº´ËØ¥", "ÁÇπ", "ÁÇ∫", "ÁÇ∫‰∫Ü", "ÁÇ∫‰ªÄÈ∫º", "ÁÇ∫‰Ωï", "ÁÇ∫Ê≠¢", "ÁÇ∫Ê≠§",
    "ÁÇ∫Ëëó", "ÁÉè‰πé", "ÁÑâ", "ÁÑ°", "ÁÑ°ÂØß", "ÁÑ°Ë´ñ", "ÁÑ∂Âàô", "ÁÑ∂Ââá", "ÁÑ∂Âêé", "ÁÑ∂Âæå",
    "ÁÑ∂ËÄå", "ÁÖß", "ÁÖßÁùÄ", "ÁÖßËëó", "Áàæ", "ÁàæÂæå", "ÁàæÁàæ", "Áäπ‰∏î", "ÁäπËá™", "Áå∂‰∏î",
    "Áå∂Ëá™", "Áîö‰∏î", "Áîö‰πà", "ÁîöÊàñ", "ÁîöËÄå", "ÁîöËá≥", "ÁîöËá≥‰∫é", "ÁîöËá≥Êñº", "ÁîöÈ∫º",
    "Áî®", "Áî®‰æÜ", "Áî®Êù•", "Áî±", "Áî±‰∫é", "Áî±Êñº", "Áî±ÊòØ", "Áî±Ê≠§", "Áî±Ê≠§ÂèØË¶ã",
    "Áî±Ê≠§ÂèØËßÅ", "Áï∂", "Áï∂Âú∞", "Áï∂ÁÑ∂", "Áï∂Ëëó", "ÁöÑ", "ÁöÑÁ°Æ", "ÁöÑÁ¢∫", "ÁöÑË©±",
    "ÁöÑËØù", "Áõ°", "Áõ¥Âà∞", "Áõ∏ÂØπËÄåË®Ä", "Áõ∏Â∞çËÄåË®Ä", "ÁúÅÂæó", "Áúã", "Áú®Áúº", "ÁùÄ",
    "ÁùÄÂë¢", "Áü£", "Áü£‰πé", "Áü£Âìâ", "Á¶ª", "Áßí", "Áß∞", "Á®±", "Á´üËÄå", "Á¨¨", "Á≠â",
    "Á≠âÂà∞", "Á≠âÁ≠â", "ÁÆÄË®Ä‰πã", "ÁÆ°", "Á∞°Ë®Ä‰πã", "Á±ªÂ¶Ç", "Á¥ßÊé•ÁùÄ", "ÁµêÊûú", "Áµ¶",
    "Á∂ì", "Á∂ìÈÅé", "Á∂ú‰∏äÊâÄËø∞", "Á∑äÊé•Ëëó", "Á∏±", "Á∏±‰ª§", "Á∏±‰Ωø", "Á∏±ÁÑ∂", "Á∏Ω‰πã",
    "Á∏ΩÁöÑ‰æÜÁúã", "Á∏ΩÁöÑ‰æÜË™™", "Á∏ΩÁöÑË™™‰æÜ", "Á∏ΩËÄåË®Ä‰πã", "Áπº‰πã", "ÁπºÂæå", "ÁπºËÄå",
    "Á∫µ", "Á∫µ‰ª§", "Á∫µ‰Ωø", "Á∫µÁÑ∂", "Áªè", "ÁªèËøá", "ÁªìÊûú", "Áªô", "Áªß‰πã", "ÁªßÂêé",
    "ÁªßËÄå", "Áªº‰∏äÊâÄËø∞", "ÁΩ¢‰∫Ü", "ÁΩ∑‰∫Ü", "ËÄÖ", "ËÄå", "ËÄå‰∏î", "ËÄåÂÜµ", "ËÄåÂêé",
    "ËÄåÂ§ñ", "ËÄåÂ∑≤", "ËÄåÂæå", "ËÄåÊòØ", "ËÄåÊ≥Å", "ËÄåË®Ä", "ËÉΩ", "ËÉΩÂê¶", "ËÖæ", "Ëá®",
    "Ëá™", "Ëá™‰∏™ÂÑø", "Ëá™‰ªé", "Ëá™ÂÄãÂÖí", "Ëá™ÂêÑÂÑø", "Ëá™ÂêÑÂÖí", "Ëá™Âêé", "Ëá™ÂÆ∂", "Ëá™Â∑±",
    "Ëá™Âæå", "Ëá™Âæû", "Ëá™Êâì", "Ëá™Ë∫´", "Ëá≥", "Ëá≥‰∫é", "Ëá≥‰ªä", "Ëá≥Êñº", "Ëá≥Ëã•", "Ëá¥",
    "Ëàá", "ËàáÂÖ∂", "ËàáÂÖ∂Ë™™", "ËàáÂê¶", "ËàáÊ≠§ÂêåÊôÇ", "Ëà¨ÁöÑ", "Ëã•", "Ëã•Â§´", "Ëã•ÊòØ",
    "Ëã•Êûú", "Ëã•Èùû", "Ëé´‰∏çÁÑ∂", "Ëé´Â¶Ç", "Ëé´Ëã•", "Ëê¨‰∏Ä", "Ëëó", "ËëóÂë¢", "ËôïÂú®",
    "ËôΩ", "ËôΩÂàô", "ËôΩÁÑ∂", "ËôΩËØ¥", "Ë¢´", "Ë¶Å", "Ë¶Å‰∏ç", "Ë¶Å‰∏çÊòØ", "Ë¶Å‰∏çÁÑ∂", "Ë¶Å‰πà",
    "Ë¶ÅÊòØ", "Ë¶ÅÈ∫º", "Ë®≠‰Ωø", "Ë®≠Êàñ", "Ë®≠Ëã•", "Ë®±Â§ö", "Ë©≤", "Ë™†Â¶Ç", "Ë™†ÁÑ∂", "Ë™™",
    "Ë™™‰æÜ", "Ë™∞", "Ë™∞‰∫∫", "Ë™∞Êñô", "Ë™∞Áü•", "Ë´ã", "Ë´ñ", "Ë´∏", "Ë´∏‰Ωç", "Ë´∏Â¶Ç",
    "Ë≠¨Âñª", "Ë≠¨Â¶Ç", "ËÆì", "ËÆ©", "ËÆ∏Â§ö", "ËÆ∫", "ËÆæ‰Ωø", "ËÆæÊàñ", "ËÆæËã•", "ËØöÂ¶Ç",
    "ËØöÁÑ∂", "ËØ•", "ËØ¥", "ËØ¥Êù•", "ËØ∑", "ËØ∏", "ËØ∏‰Ωç", "ËØ∏Â¶Ç", "Ë∞Å", "Ë∞Å‰∫∫", "Ë∞ÅÊñô",
    "Ë∞ÅÁü•", "Ë±à‰ΩÜ", "Ë≥äÊ≠ª", "Ë≥¥‰ª•", "Ë¥ºÊ≠ª", "Ëµñ‰ª•", "Ëµ∂", "Ëµ∑", "Ëµ∑Ë¶ã", "Ëµ∑ËßÅ",
    "Ë∂Å", "Ë∂ÅÁùÄ", "Ë∂ÅËëó", "Ë∂äÊòØ", "Ë∂ï", "Ë∑ù", "Ë∑ü", "ËºÉ", "ËºÉ‰πã", "ËæÉ", "ËæÉ‰πã",
    "Ëæπ", "Ëøá", "Ëøò", "ËøòÊòØ", "ËøòÊúâ", "ËøòË¶Å", "Ëøô", "Ëøô‰∏ÄÊù•", "Ëøô‰∏™", "Ëøô‰πà",
    "Ëøô‰πà‰∫õ", "Ëøô‰πàÊ†∑", "Ëøô‰πàÁÇπÂÑø", "Ëøô‰∫õ", "Ëøô‰ºöÂÑø", "ËøôÂÑø", "ËøôÂ∞±ÊòØËØ¥", "ËøôÊó∂",
    "ËøôÊ†∑", "ËøôÊ¨°", "ËøôËà¨", "ËøôËæπ", "ËøôÈáå", "ËøõËÄå", "Ëøû", "ËøûÂêå", "ÈÄêÊ≠•", "ÈÄô",
    "ÈÄô‰∏Ä‰æÜ", "ÈÄô‰∫õ", "ÈÄôÂÄã", "ÈÄôÂÖí", "ÈÄôÂ∞±ÊòØË™™", "ÈÄôÊôÇ", "ÈÄôÊúÉÂÖí", "ÈÄôÊ®£",
    "ÈÄôÊ¨°", "ÈÄôËà¨", "ÈÄôË£°", "ÈÄôÈÇä", "ÈÄôÈ∫º", "ÈÄôÈ∫º‰∫õ", "ÈÄôÈ∫ºÊ®£", "ÈÄôÈ∫ºÈªûÂÖí",
    "ÈÄöËøá", "ÈÄöÈÅé", "ÈÄ£", "ÈÄ£Âêå", "ÈÄ≤ËÄå", "ÈÅé", "ÈÅµÂæ™", "ÈÅµÁÖß", "ÈÇÑ", "ÈÇÑÊòØ",
    "ÈÇÑÊúâ", "ÈÇÑË¶Å", "ÈÇä", "ÈÇ£", "ÈÇ£‰∏™", "ÈÇ£‰πà", "ÈÇ£‰πà‰∫õ", "ÈÇ£‰πàÊ†∑", "ÈÇ£‰∫õ",
    "ÈÇ£‰ºöÂÑø", "ÈÇ£ÂÄã", "ÈÇ£ÂÑø", "ÈÇ£ÂÖí", "ÈÇ£Êó∂", "ÈÇ£ÊôÇ", "ÈÇ£ÊúÉÂÖí", "ÈÇ£Ê†∑", "ÈÇ£Ê®£",
    "ÈÇ£Ëà¨", "ÈÇ£Ë£°", "ÈÇ£Ëæπ", "ÈÇ£ÈÇä", "ÈÇ£Èáå", "ÈÇ£È∫º", "ÈÇ£È∫º‰∫õ", "ÈÇ£È∫ºÊ®£", "ÈÉΩ",
    "ÈÑô‰∫∫", "ÈáùÂ∞ç", "Èâ¥‰∫é", "ÈëíÊñº", "ÈíàÂØπ", "ÈñãÂ§ñ", "ÈñãÂßã", "ÈóúÊñº", "ÈóúÊñºÂÖ∑È´îÂú∞Ë™™",
    "Èòø", "Èô§", "Èô§‰∫Ü", "Èô§Â§ñ", "Èô§ÂºÄ", "Èô§Ê≠§‰πãÂ§ñ", "Èô§Èñã", "Èô§Èùû", "Èöè", "ÈöèÂêé",
    "ÈöèÊó∂", "ÈöèÁùÄ", "Èö®", "Èö®Âæå", "Èö®ÊôÇ", "Èö®Ëëó", "ÈöæÈÅìËØ¥", "Èõñ", "ÈõñÂâá", "ÈõñÁÑ∂",
    "ÈõñË™™", "Èõ¢", "Èõ£ÈÅìË™™", "Èõ≤Áàæ", "Èõ∂", "Èùû", "Èùû‰ΩÜ", "ÈùûÂæí", "ÈùûÁâπ", "ÈùûÁã¨",
    "ÈùûÁç®", "Èù†", "È†Ü", "È†ÜËëó", "È°ûÂ¶Ç", "È°∫", "È°∫ÁùÄ", "È§òÂ§ñ", "È¶ñÂÖà", "È®∞", "È∫º",
    "Èªû", "Ôºº", "Ôºè", "Ôºù", "‚Äî", "Ôºø", "‚Äµ"
]);

// Usage example:
// if (STOPWORDS_ZH.has(word)) { /* it's a stopword */ }
// 
// To filter out stopwords from an array:
// const filtered = words.filter(word => !STOPWORDS_ZH.has(word));

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê STOPWORDS SETTINGS & MANAGEMENT ‚≠ê‚≠ê‚≠ê
// ============================================================================

let stopwordsSettings = {
    mode: 'default',  // 'default', 'custom', 'both'
    customStopwords: new Set()
};

/**
 * Update stopwords mode
 */
function updateStopwordsMode(mode) {
    stopwordsSettings.mode = mode;
    console.log(`‚úÖ Stopwords mode set to: ${mode}`);
    
    if (mode === 'default') {
        showSuccessMessage('Using only embedded English and Chinese stopwords.');
    } else if (mode === 'custom') {
        showSuccessMessage('Using only custom stopwords. Enter them in the textarea below.');
    } else {
        showSuccessMessage('Using both embedded and custom stopwords.');
    }
}

/**
 * Load stopwords from uploaded file
 */
function loadStopwordsFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        const textarea = document.getElementById('customStopwordsInput');
        
        // Append to existing content or replace
        if (textarea.value.trim()) {
            if (confirm('Append to existing stopwords or replace them?')) {
                textarea.value += '\n' + content;
            } else {
                textarea.value = content;
            }
        } else {
            textarea.value = content;
        }
        
        showSuccessMessage('Stopwords file loaded successfully!');
    };
    
    reader.readAsText(file);
    event.target.value = '';
}

/**
 * Apply stopwords settings
 */
function applyStopwordsSettings() {
    const textarea = document.getElementById('customStopwordsInput');
    const customText = textarea.value.trim();
    
    // Parse custom stopwords (one per line)
    stopwordsSettings.customStopwords.clear();
    
    if (customText) {
        const lines = customText.split('\n');
        lines.forEach(line => {
            const word = line.trim();
            if (word && !word.startsWith('#')) {  // Skip empty lines and comments
                stopwordsSettings.customStopwords.add(word);
            }
        });
    }
    
    console.log(`‚úÖ Applied ${stopwordsSettings.customStopwords.size} custom stopwords`);
    showSuccessMessage(`Applied ${stopwordsSettings.customStopwords.size} custom stopwords in ${stopwordsSettings.mode} mode.`);
}

/**
 * Clear custom stopwords
 */
function clearCustomStopwords() {
    if (confirm('Clear all custom stopwords?')) {
        document.getElementById('customStopwordsInput').value = '';
        stopwordsSettings.customStopwords.clear();
        showSuccessMessage('Custom stopwords cleared.');
    }
}

/**
 * Get active stopwords based on current mode
 */
function getActiveStopwords() {
    const active = {
        english: new Set(),
        chinese: new Set(),
        custom: new Set(stopwordsSettings.customStopwords)
    };
    
    if (stopwordsSettings.mode === 'default' || stopwordsSettings.mode === 'both') {
        active.english = new Set(STOPWORDS_EN);
        active.chinese = new Set(STOPWORDS_ZH);
    }
    
    return active;
}

/**
 * Show stopwords in Info tab - REVISED with internal CSS
 */
function showStopwordsInInfo() {
    const infoDisplay = document.getElementById('infoDisplay');
    
    const active = getActiveStopwords();
    
    // ‚≠ê Use CSS classes instead of inline styles
    let html = '<div class="info-content-wrapper">';
    html += '<h2>üìã Active Stopwords</h2>';
    
    html += `<p><strong>Mode:</strong> ${stopwordsSettings.mode === 'default' ? 'Default Embedded Only' : 
                                  stopwordsSettings.mode === 'custom' ? 'Custom Only' : 
                                  'Both Default and Custom'}</p>`;
    
    // English Stopwords
    if (active.english.size > 0) {
        html += `<h3>üá¨üáß English Stopwords (${active.english.size})</h3>`;
        html += '<div class="info-stopwords-list">';
        html += Array.from(active.english).sort().join('\n');
        html += '</div>';
    }
    
    // Chinese Stopwords
    if (active.chinese.size > 0) {
        html += `<h3 class="stopwords-chinese">üá®üá≥ Chinese Stopwords (${active.chinese.size})</h3>`;
        html += '<div class="info-stopwords-list">';
        html += Array.from(active.chinese).sort().join('\n');
        html += '</div>';
    }
    
    // Custom Stopwords
    if (active.custom.size > 0) {
        html += `<h3 class="stopwords-custom">‚úèÔ∏è Custom Stopwords (${active.custom.size})</h3>`;
        html += '<div class="info-stopwords-list">';
        html += Array.from(active.custom).sort().join('\n');
        html += '</div>';
    }
    
    if (active.english.size === 0 && active.chinese.size === 0 && active.custom.size === 0) {
        html += '<p class="info-no-data">No stopwords are currently active. Configure them in Settings.</p>';
    }
    
    html += '</div>';
    
    infoDisplay.innerHTML = html;
    
    // Switch to Info tab
    switchUnifiedTab('info', null);
    
    showSuccessMessage('Stopwords displayed in Info tab!');
}

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.2: SEGMENTATION SETTINGS FUNCTIONS ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Update segmentation method and toggle settings visibility
 */
function updateSegmentationMethod(method) {
    doc2termSettings.method = method;
    
    const symbolSettings = document.getElementById('symbolSettings');
    const windowSettings = document.getElementById('windowSettings');
    
    if (method === 'symbol') {
        symbolSettings.style.display = 'flex';
        windowSettings.style.display = 'none';
        showSuccessMessage('Symbol-based segmentation selected. Configure boundary symbols below.');
    } else {
        symbolSettings.style.display = 'none';
        windowSettings.style.display = 'flex';
        showSuccessMessage('Window-based segmentation selected. Configure window size and step.');
    }
    
    console.log(`‚úÖ Segmentation method set to: ${method}`);
}

/**
 * Apply boundary symbols from textarea
 */
function applySymbolSettings() {
    const textarea = document.getElementById('boundarySymbolsInput');
    const text = textarea.value.trim();
    
    if (!text) {
        alert('Please enter at least one boundary symbol.');
        return;
    }
    
    // Parse symbols (one per line, skip empty lines and comments)
    const symbols = text.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'));
    
    if (symbols.length === 0) {
        alert('No valid symbols found. Please enter symbols (one per line).');
        return;
    }
    
    doc2termSettings.boundarySymbols = symbols;
    
    console.log(`‚úÖ Applied ${symbols.length} boundary symbols:`, symbols);
    showSuccessMessage(`Applied ${symbols.length} boundary symbols.`);
}

/**
 * Reset boundary symbols to default
 */
function resetDefaultSymbols() {
    const defaultSymbols = [',', ';', '.', '!', '?', 'Ôºå', 'Ôºõ', '„ÄÇ', 'ÔºÅ', 'Ôºü'];
    doc2termSettings.boundarySymbols = defaultSymbols;
    
    const textarea = document.getElementById('boundarySymbolsInput');
    textarea.value = defaultSymbols.join('\n');
    
    showSuccessMessage('Reset to default boundary symbols (10 symbols).');
    console.log('‚úÖ Reset to default symbols:', defaultSymbols);
}

/**
 * Apply window settings
 */
function applyWindowSettings() {
    const sizeInput = document.getElementById('windowSizeInput');
    const stepInput = document.getElementById('windowStepInput');
    
    const size = parseInt(sizeInput.value);
    const step = parseInt(stepInput.value);
    
    if (isNaN(size) || size < 1 || size > 50) {
        alert('Window size must be between 1 and 50.');
        return;
    }
    
    if (isNaN(step) || step < 1 || step > 50) {
        alert('Window step must be between 1 and 50.');
        return;
    }
    
    doc2termSettings.windowSize = size;
    doc2termSettings.windowStep = step;
    
    console.log(`‚úÖ Window settings: size=${size}, step=${step}`);
    showSuccessMessage(`Window settings applied: size=${size}, step=${step}`);
}

/**
 * Initialize default symbols on page load
 */
document.addEventListener('DOMContentLoaded', function() {
    const textarea = document.getElementById('boundarySymbolsInput');
    if (textarea) {
        textarea.value = doc2termSettings.boundarySymbols.join('\n');
    }
});

// ============================================================================

// ============================================================================
	
        function setCurrentDateTime() {
            const now = new Date();
            const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            };
            const dateTimeString = now.toLocaleString('en-US', options);
            const dateElement = document.getElementById('currentDateTime');
            if (dateElement) {
                dateElement.textContent = dateTimeString;
            }
        }

        window.addEventListener('load', setCurrentDateTime);

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 2: SOURCE TEXT COLOR PALETTE ‚≠ê‚≠ê‚≠ê
// ============================================================================
// Define a 10-color palette for source text coloring (Text 1-10+)
const sourceTextColors = [
    '#e74c3c',  // Text 1 - Red
    '#3498db',  // Text 2 - Blue
    '#27ae60',  // Text 3 - Green
    '#9b59b6',  // Text 4 - Purple
    '#e67e22',  // Text 5 - Orange
    '#e91e63',  // Text 6 - Pink
    '#f39c12',  // Text 7 - Yellow
    '#1abc9c',  // Text 8 - Cyan
    '#795548',  // Text 9 - Brown
    '#95a5a6'   // Text 10+ - Gray (default for unknown)
];
// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 2: NODE-TO-SOURCE MAPPING FUNCTIONS ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Build a map of node text ‚Üí source text ID
 * This allows us to determine which text each node originated from
 */
function buildNodeToSourceMap(allConnections) {
    const nodeToSourceMap = {};
    
    canvasPages.forEach(canvas => {
        if (typeof canvas.id === 'number') {
            canvas.textboxes.forEach(tb => {
                if (!tb.isGreyed) {  // Only include non-greyed textboxes
                    const nodeText = getPlainText(tb.text);
                    
                    // Only add if not already in map (first occurrence wins)
                    if (!nodeToSourceMap[nodeText]) {
                        nodeToSourceMap[nodeText] = tb.sourceTextId;
                    }
                }
            });
        }
    });
    
    console.log('üìä Phase 2: Node-to-Source Map:', nodeToSourceMap);
    return nodeToSourceMap;
}

/**
 * Get the color for a node based on its source text ID
 * Uses the sourceTextColors palette defined above
 */
function getNodeColorBySource(nodeText, nodeToSourceMap) {
    const sourceId = nodeToSourceMap[nodeText];
    
    // If sourceId is null/undefined, use gray (index 9)
    if (sourceId === null || sourceId === undefined) {
        return sourceTextColors[9]; // Gray for unknown source
    }
    
    // Map sourceId (1, 2, 3...) to color index (0, 1, 2...)
    // Cap at index 9 for Text 10+
    const colorIndex = Math.min(sourceId - 1, 9);
    return sourceTextColors[colorIndex];
}
// ============================================================================



        // Color palette colors
        const highlightColors = [
            '#fff59d', // Yellow (default)
            '#ffd8b1', // Apricot
            '#fffac8', // Beige
            '#90caf9', // Light Blue
            '#ffcc80', // Light Orange
            '#ce93d8', // Light Purple
            '#42d4f4', // Cyan
            '#aaffc3', // Mint
            '#bfef45', // Lime
            '#fabed4'  // Pink
        ];

        const defaultHighlightColor = '#fff59d'; // Yellow

        let textPages = [
            {
                id: 1,
                content: ''
            }
        ];
        let currentTextPageId = 1;
        let textPageIdCounter = 2;

        let canvasPages = [
            {
                id: 1,
                textboxes: [],
                connections: [],
                textboxIdCounter: 0
            }
        ];
        let currentCanvasId = 1;
        let canvasIdCounter = 2;
        
        let draggedTextbox = null;
        let connectingFrom = null;
        let pendingConnection = null;
        let editingConnectionIndex = null;
        
        let currentFontSize = 16;
        let isPanelCollapsed = false;
        let currentLeftPageType = 'text';

        let isDraggingText = false;
        let draggedText = '';
        let draggedTextSourceId = null;

        let mainIdeaOrder = [];
        let draggedMainIdeaIndex = null;
        
        let exportSVGEnabled = false;

        let isDraggingConnection = false;
        let connectionDragFrom = null;
        let tempConnectionLine = null;

        let cyInstance = null;
        let networkAnalysisVisible = false;
		
		let nodeVisualizationSettings = {
			size: 'degree',      // 'degree', 'betweenness', 'closeness', 'eigenvector'
			color: 'none',       // 'none', 'source', 'cluster-lpa', 'cluster-louvain'
			shape: 'circle'      // 'circle', 'source', 'cluster'
		};

let clusterAssignments = {}; // Will store node -> cluster mappings

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.2: DOC2TERM NETWORK STATE ‚≠ê‚≠ê‚≠ê
// ============================================================================

let doc2termSettings = {
    method: 'symbol',              // 'symbol' or 'window'
    boundarySymbols: [',', ';', '.', '!', '?', 'Ôºå', 'Ôºõ', '„ÄÇ', 'ÔºÅ', 'Ôºü'],
    windowSize: 5,
    windowStep: 5
};

let nodelistData = [];  // Stores generated nodelist: [{segment: 1, tokens: [...]}, ...]

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: W-NETWORK VIEW STATE ‚≠ê‚≠ê‚≠ê
// ============================================================================

let wNetworkViewMode = '2mode'; // '2mode' or '1mode'
let wordEdgelistData = [];      // Stores 1-mode word-to-word edgelist

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.2: WORD NETWORK ANALYSIS STATE ‚≠ê‚≠ê‚≠ê
// ============================================================================

let wordNetworkMetrics = {};      // Stores centrality metrics for word network
let wordClusterAssignments = {};   // Stores cluster assignments for word network
let wordCyInstance = null;         // Separate Cytoscape instance for word network

// ============================================================================

// ‚≠ê‚≠ê‚≠ê PHASE 4.3.2: ACTIVE NETWORK TRACKER ‚≠ê‚≠ê‚≠ê
let activeNetworkType = null; // 'T-network' or 'W-network' - tracks which was analyzed last

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.1: TOKENIZATION SETTINGS & STATE ‚≠ê‚≠ê‚≠ê
// ============================================================================

let tokenizationSettings = {
    method: 'word',      // 'character' or 'word'
    separator: ' '       // Default separator (space)
};

/**
 * Update tokenization method setting
 */
function updateTokenizationMethod(value) {
    tokenizationSettings.method = value;
    console.log(`‚úÖ Tokenization method set to: ${value}`);
    
    if (value === 'character') {
        showSuccessMessage('Character-level tokenization selected. Each character will be separated.');
    } else {
        showSuccessMessage('Word-level tokenization selected. Jieba.js will be used for intelligent segmentation.');
    }
}

/**
 * Update token separator
 */
function updateTokenSeparator() {
    const input = document.getElementById('tokenSeparatorInput');
    const preview = document.getElementById('separatorPreview');
    
    const newSeparator = input.value;
    tokenizationSettings.separator = newSeparator;
    
    // Update preview display
    const displaySeparator = newSeparator === ' ' ? '" " (space)' : 
                            newSeparator === '' ? '(no separator)' : 
                            `"${newSeparator}"`;
    preview.textContent = `Current: ${displaySeparator}`;
    
    console.log(`‚úÖ Token separator updated to: "${newSeparator}"`);
    showSuccessMessage(`Separator set to: ${displaySeparator}`);
}

/**
 * ‚≠ê‚≠ê‚≠ê MAIN TOKENIZATION FUNCTION ‚≠ê‚≠ê‚≠ê
 * Tokenizes text in the focused text tab while preserving formatting
 */
/**
 * ‚≠ê‚≠ê‚≠ê MAIN TOKENIZATION FUNCTION ‚≠ê‚≠ê‚≠ê
 * Tokenizes text in the focused text tab while preserving formatting
 */
function tokenizeText() {
    // ‚≠ê BUG FIX 1: Check if a text tab is focused
    if (currentLeftPageType !== 'text') {
        alert('‚ö†Ô∏è Please switch to a Text tab first before tokenizing.');
        return;
    }
    
    // Check if jieba is loaded
    if (!jiebaInstance && tokenizationSettings.method === 'word') {
        alert('‚ö†Ô∏è Jieba.js is still loading. Please wait a moment and try again.');
        console.error('Jieba instance not ready');
        return;
    }
    
    const textArea = getCurrentTextArea();
    if (!textArea) {
        alert('No text tab is currently focused.');
        return;
    }
    
    const currentPage = getCurrentTextPage();
    if (!currentPage) return;
    
    console.log(`üî§ Starting tokenization (method: ${tokenizationSettings.method}, separator: "${tokenizationSettings.separator}")`);
    
    // Create a clone of the text area to work with
    const clone = textArea.cloneNode(true);
    
    // Process all text nodes recursively while preserving structure
    processTextNodes(clone, tokenizationSettings.method, tokenizationSettings.separator);
    
    // Update the original text area
    textArea.innerHTML = clone.innerHTML;
    
    // Update stored content
    currentPage.content = textArea.innerHTML;
    
    showSuccessMessage(`‚úÖ Text tokenized successfully using ${tokenizationSettings.method} method!`);
    console.log('‚úÖ Tokenization complete');
}

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.2: DOCUMENT-TO-TERM NETWORK CREATION ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Main function: Create document-to-term semantic network
 * Called by üìä button in text panel
 */
/**
 * Main function: Create document-to-term semantic network
 * Called by üìä button in text panel
 */
function createDoc2TermNetwork() {
    // ‚≠ê BUG FIX 1: Check if a text tab is focused
    if (currentLeftPageType !== 'text') {
        alert('‚ö†Ô∏è Please switch to a Text tab first before creating semantic network.');
        return;
    }
    
    // Get current text content
    const textArea = getCurrentTextArea();
    if (!textArea) {
        alert('No text tab is currently focused.');
        return;
    }
    
    const plainText = extractPlainTextFromHTML(textArea.innerHTML);
    
    if (!plainText.trim()) {
        alert('Text is empty. Please add content first.');
        return;
    }
    
    console.log(`üìä Creating doc-to-term network using ${doc2termSettings.method} method...`);
    
    // Get active stopwords
    const activeStopwords = getActiveStopwords();
    
    // Create network based on method
    if (doc2termSettings.method === 'symbol') {
        nodelistData = createNetworkBySymbols(plainText, activeStopwords);
    } else {
        nodelistData = createNetworkByWindow(plainText, activeStopwords);
    }
    
    // ‚≠ê BUG FIX 2: Reset view mode to 2-mode when new network is created
    wNetworkViewMode = '2mode';
    wordEdgelistData = []; // Clear old 1-mode data
    
    // Display nodelist
    displayNodelist();
    
    // Switch to nodelist tab
    switchUnifiedTab('nodelist', null);
    
    showSuccessMessage(`‚úÖ Created ${nodelistData.length} segments using ${doc2termSettings.method} method!`);
}


/**
 * Symbol-based segmentation - FULLY FIXED
 * Order: Split by symbols ‚Üí Tokenize ‚Üí Remove stopwords
 * ‚≠ê FIX 1: Remove tokenization separator from boundary symbols
 * ‚≠ê FIX 2: Correctly build regex pattern for character class
 */
function createNetworkBySymbols(text, activeStopwords) {
    const segments = [];
    
    // ‚≠ê FIX 1: Remove tokenization separator from boundary symbols
    const effectiveBoundarySymbols = doc2termSettings.boundarySymbols.filter(
        s => s !== tokenizationSettings.separator
    );
    
    console.log(`üîç Effective boundary symbols (excluding separator "${tokenizationSettings.separator}"):`, effectiveBoundarySymbols);
    
    // ‚≠ê FIX 2: Build pattern correctly for character class
    // Escape each symbol INDIVIDUALLY, then concatenate (no | needed!)
    const escapedSymbols = effectiveBoundarySymbols.map(s => escapeRegExp(s)).join('');
    
    let rawSegments;
    if (escapedSymbols.length > 0) {
        // Use character class [...] to match ANY of the symbols
        rawSegments = text.split(new RegExp(`[${escapedSymbols}]`));
        console.log(`üìÑ Symbol method: Using regex pattern: /[${escapedSymbols}]/`);
    } else {
        // If no boundary symbols (all were filtered out), treat entire text as one segment
        rawSegments = [text];
        console.log('‚ö†Ô∏è Warning: All boundary symbols are the same as separator. Using entire text as one segment.');
    }
    
    console.log(`üìÑ Symbol method: Split into ${rawSegments.length} raw segments`);
    
    // Step 2: Process each segment
    let segmentId = 1;
    
    rawSegments.forEach((rawSeg, idx) => {
        console.log(`üîç Processing raw segment ${idx + 1}: "${rawSeg.substring(0, 50)}${rawSeg.length > 50 ? '...' : ''}"`);
        
        // Tokenize using current separator
        const tokens = rawSeg.split(tokenizationSettings.separator)
            .map(t => t.trim())
            .filter(t => t.length > 0);
        
        console.log(`  ‚Üí Tokens (before stopword removal): ${tokens.length} tokens`);
        
        if (tokens.length === 0) {
            console.log(`  ‚Üí Skipped (no tokens)`);
            return; // Skip empty segments
        }
        
        // Remove stopwords
        const cleanTokens = tokens.filter(t => !isStopwordActive(t, activeStopwords));
        
        console.log(`  ‚Üí Clean tokens (after stopword removal): ${cleanTokens.length} tokens`);
        console.log(`  ‚Üí Clean tokens: [${cleanTokens.join(', ')}]`);
        
        if (cleanTokens.length === 0) {
            console.log(`  ‚Üí Skipped (all stopwords)`);
            return; // Skip if all stopwords
        }
        
        segments.push({
            segment: segmentId,
            tokens: cleanTokens
        });
        
        console.log(`  ‚úÖ Added as segment ${segmentId}`);
        segmentId++;
    });
    
    console.log(`‚úÖ Symbol method: Generated ${segments.length} segments`);
    return segments;
}

/**
 * Window-based segmentation
 * Order: Tokenize ‚Üí Remove stopwords ‚Üí Create windows
 */
function createNetworkByWindow(text, activeStopwords) {
    const segments = [];
    
    // Step 1: Tokenize entire text
    const allTokens = text.split(tokenizationSettings.separator)
        .map(t => t.trim())
        .filter(t => t.length > 0);
    
    console.log(`üìÑ Window method: Extracted ${allTokens.length} tokens`);
    
    // Step 2: Remove stopwords FIRST
    const cleanTokens = allTokens.filter(t => !isStopwordActive(t, activeStopwords));
    
    console.log(`üö´ Removed stopwords: ${cleanTokens.length} tokens remaining`);
    
    // Step 3: Create sliding windows
    const size = doc2termSettings.windowSize;
    const step = doc2termSettings.windowStep;
    
    let segmentId = 1;
    
    for (let i = 0; i < cleanTokens.length; i += step) {
        const windowTokens = cleanTokens.slice(i, i + size);
        
        if (windowTokens.length > 0) {
            segments.push({
                segment: segmentId,
                tokens: windowTokens
            });
            segmentId++;
        }
    }
    
    console.log(`‚úÖ Window method: Generated ${segments.length} windows (size=${size}, step=${step})`);
    return segments;
}

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.2: NODELIST DISPLAY & EXPORT ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Display nodelist in the Nodelist tab
 */
function displayNodelist() {
    const display = document.getElementById('nodelistDisplay');
    
    if (nodelistData.length === 0) {
        display.innerHTML = '<span style="color: #999;">No nodelist data. Click "üìä Create Semantic Network" to generate.</span>';
        return;
    }
    
    display.innerHTML = '';
    
    nodelistData.forEach(item => {
        const line = document.createElement('div');
        line.className = 'data-line';
        
        // Format: segment_id,"token1","token2","token3",...
        const csvLine = `${item.segment},${item.tokens.map(t => `"${t}"`).join(',')}`;
        line.textContent = csvLine;
        
        display.appendChild(line);
    });
    
    console.log(`üìã Displayed ${nodelistData.length} segments in Nodelist tab`);
}

/**
 * Copy nodelist to clipboard (old)
 */
/**
 * Copy nodelist or word edgelist to clipboard (auto-detect mode)
 */
function copyNodelist() {
    let csvText = '';
    
    if (wNetworkViewMode === '2mode') {
        // Copy 2-mode nodelist
        if (nodelistData.length === 0) {
            alert('No nodelist data to copy. Generate network first using "üìä Create Semantic Network".');
            return;
        }
        
        const csvLines = nodelistData.map(item => {
            return `${item.segment},${item.tokens.map(t => `"${t}"`).join(',')}`;
        });
        
        csvText = csvLines.join('\n');
        console.log('üìã Copying 2-mode nodelist');
        
    } else {
        // Copy 1-mode word edgelist
        if (wordEdgelistData.length === 0) {
            alert('No word edgelist to copy. Click "üìä Network Analysis" first.');
            return;
        }
        
        const header = 'From_Node,To_Node,From_TextID,To_TextID,From_Cluster,To_Cluster,Weight\n';
        const rows = wordEdgelistData.map(edge => 
            `"${edge.fromNode}","${edge.toNode}",${edge.fromTextID},${edge.toTextID},${edge.fromCluster},${edge.toCluster},${edge.weight}`
        );
        
        csvText = header + rows.join('\n');
        console.log('üìã Copying 1-mode word edgelist');
    }
    
    navigator.clipboard.writeText(csvText).then(() => {
        showSuccessMessage('Copied to clipboard!');
    }).catch(err => {
        alert('Failed to copy to clipboard.');
        console.error(err);
    });
}

/**
 * Download nodelist as CSV file
 */
/**
 * Download nodelist or word edgelist as CSV (auto-detect mode)
 */
function downloadNodelist() {
    let csvContent = '';
    let filename = '';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    
    if (wNetworkViewMode === '2mode') {
        // Download 2-mode nodelist
        if (nodelistData.length === 0) {
            alert('No nodelist data to download. Generate network first using "üìä Create Semantic Network".');
            return;
        }
        
        const csvLines = nodelistData.map(item => {
            return `${item.segment},${item.tokens.map(t => `"${t}"`).join(',')}`;
        });
        
        csvContent = csvLines.join('\n');
        filename = `w-network-2mode-${timestamp}.csv`;
        console.log('üíæ Downloading 2-mode nodelist');
        
    } else {
        // Download 1-mode word edgelist
        if (wordEdgelistData.length === 0) {
            alert('No word edgelist to download. Click "üìä Network Analysis" first.');
            return;
        }
        
        const header = 'From_Node,To_Node,From_TextID,To_TextID,From_Cluster,To_Cluster,Weight\n';
        const rows = wordEdgelistData.map(edge => 
            `"${edge.fromNode}","${edge.toNode}",${edge.fromTextID},${edge.toTextID},${edge.fromCluster},${edge.toCluster},${edge.weight}`
        );
        
        csvContent = header + rows.join('\n');
        filename = `w-network-edgelist-${timestamp}.csv`;
        console.log('üíæ Downloading 1-mode word edgelist');
    }
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.download = filename;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
    
    showSuccessMessage('CSV downloaded!');
}

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: TOGGLE BETWEEN 2-MODE AND 1-MODE VIEW ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Toggle between 2-mode nodelist and 1-mode word edgelist
 */
/**
 * Toggle between 2-mode nodelist and 1-mode word edgelist
 */
function toggleWNetworkView() {
    const display = document.getElementById('nodelistDisplay');
    const toggleBtn = document.getElementById('backToNodelistBtn');
    
    if (wNetworkViewMode === '1mode') {
        // Switch to 2-mode view
        wNetworkViewMode = '2mode';
        displayNodelist(); // Show segment-to-word nodelist
        toggleBtn.style.display = 'none'; // ‚≠ê BUG FIX 3: Hide when in nodelist mode
        console.log('üîÑ Switched to 2-mode nodelist view');
    } else {
        // Switch to 1-mode view
        wNetworkViewMode = '1mode';
        displayWordEdgelist(); // Show word-to-word edgelist
        toggleBtn.style.display = 'inline-block'; // ‚≠ê Show when in edgelist mode
        console.log('üîÑ Switched to 1-mode word edgelist view');
    }
}

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: CONVERT 2-MODE TO 1-MODE WORD NETWORK ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Convert 2-mode nodelist to 1-mode word-to-word edgelist
 * Co-occurrence logic: words in same segment are connected
 */
function convertTo1ModeWordNetwork() {
    if (nodelistData.length === 0) {
        alert('No nodelist data found. Generate 2-mode network first.');
        return;
    }
    
    console.log('üîÑ Converting 2-mode ‚Üí 1-mode word network...');
    
    // Build co-occurrence map
    const cooccurrenceMap = new Map(); // Key: "word1|word2", Value: weight
    
    nodelistData.forEach(segment => {
        const tokens = segment.tokens;
        
        // For each pair of words in the segment (undirected edges)
        for (let i = 0; i < tokens.length; i++) {
            for (let j = i + 1; j < tokens.length; j++) {
                const word1 = tokens[i];
                const word2 = tokens[j];
                
                // Create undirected edge key (alphabetical order for consistency)
                const key = word1 < word2 ? `${word1}|${word2}` : `${word2}|${word1}`;
                
                // Increment co-occurrence count
                cooccurrenceMap.set(key, (cooccurrenceMap.get(key) || 0) + 1);
            }
        }
    });
    
    // Convert to edge list with 7 columns
    wordEdgelistData = [];
    
    cooccurrenceMap.forEach((weight, key) => {
        const [source, target] = key.split('|');
        
        wordEdgelistData.push({
            fromNode: source,
            toNode: target,
            fromTextID: 1,      // Placeholder (future: track source text)
            toTextID: 1,        // Placeholder
            fromCluster: 0,     // Placeholder (future: community detection)
            toCluster: 0,       // Placeholder
            weight: weight
        });
    });
    
    console.log(`‚úÖ Generated ${wordEdgelistData.length} word-to-word edges`);
    console.log(`üìä Total unique word pairs: ${cooccurrenceMap.size}`);
}

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: DISPLAY 1-MODE WORD EDGELIST ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Display 1-mode word edgelist in W-Network tab
 */
function displayWordEdgelist() {
    const display = document.getElementById('nodelistDisplay');
    
    if (wordEdgelistData.length === 0) {
        display.innerHTML = '<span style="color: #999;">No word edgelist generated yet. Click "üìä Network Analysis" first.</span>';
        return;
    }
    
    display.innerHTML = '';
    
    // Add CSV header
    const header = document.createElement('div');
    header.className = 'data-line';
    header.style.fontWeight = 'bold';
    header.style.borderLeftColor = '#27ae60';
    header.textContent = 'From_Node,To_Node,From_TextID,To_TextID,From_Cluster,To_Cluster,Weight';
    display.appendChild(header);
    
    // Add data rows
    wordEdgelistData.forEach(edge => {
        const line = document.createElement('div');
        line.className = 'data-line';
        line.style.borderLeftColor = '#27ae60';
        
        const csvLine = `"${edge.fromNode}","${edge.toNode}",${edge.fromTextID},${edge.toTextID},${edge.fromCluster},${edge.toCluster},${edge.weight}`;
        line.textContent = csvLine;
        
        display.appendChild(line);
    });
    
    console.log(`üìã Displayed ${wordEdgelistData.length} word edges in 1-mode view`);
}

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: NETWORK ANALYSIS BUTTON HANDLER ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Main handler for "üìä Network Analysis" button in W-Network tab
 * Does TWO things:
 * 1. Convert 2-mode ‚Üí 1-mode and display (Phase 4.3.1)
 * 2. Calculate metrics and visualize (Phase 4.3.2 - placeholder)
 */
// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.2: COMPLETE NETWORK ANALYSIS WITH VISUALIZATION ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Main handler for "üìä Network Analysis" button in W-Network tab
 * Complete implementation:
 * 1. Convert 2-mode ‚Üí 1-mode and display (Phase 4.3.1)
 * 2. Calculate metrics and visualize (Phase 4.3.2)
 */
function performNetworkAnalysis() {
    if (nodelistData.length === 0) {
        alert('No nodelist data found. Generate 2-mode network first using "üìä Create Semantic Network".');
        return;
    }
    
    console.log('üìä Starting complete W-network analysis...');
    
    // ‚≠ê BUG FIX 2: ALWAYS regenerate 1-mode network (don't check if it exists)
    // This ensures fresh data when user creates new nodelist
    console.log('üîÑ Converting 2-mode ‚Üí 1-mode network...');
    convertTo1ModeWordNetwork();
    
    // ‚≠ê BUG FIX 3: Switch to edgelist view automatically
    wNetworkViewMode = '1mode';
    displayWordEdgelist();
    
    // Show toggle button
    const toggleBtn = document.getElementById('backToNodelistBtn');
    toggleBtn.style.display = 'inline-block';
    
    console.log('‚úÖ Phase 4.3.1: Converted to 1-mode network');
    
    if (wordEdgelistData.length === 0) {
        alert('No word edges to analyze.');
        return;
    }
    
    console.log(`üìä Phase 4.3.2: Analyzing ${wordEdgelistData.length} word edges...`);
    
    const wordNodes = new Set();
    const wordEdges = [];
    
    wordEdgelistData.forEach((edge, index) => {
        wordNodes.add(edge.fromNode);
        wordNodes.add(edge.toNode);
        
        wordEdges.push({
            data: {
                id: `we${index}`,
                source: edge.fromNode,
                target: edge.toNode,
                weight: edge.weight,
                label: `${edge.weight}`
            }
        });
    });
    
    const wordNodeElements = Array.from(wordNodes).map(word => ({
        data: {
            id: word,
            label: word.length <= 4 ? word : word.substring(0, 4)
        }
    }));
    
    console.log(`üìä Word network: ${wordNodeElements.length} nodes, ${wordEdges.length} edges`);
    
    wordNetworkMetrics = calculateCentralityMetrics(wordNodeElements, wordEdges);
    console.log('‚úÖ Calculated centrality metrics for word network');
    
    // Run community detection
    const nodeIds = Array.from(wordNodes);
    const adjacencyList = {};
    nodeIds.forEach(id => adjacencyList[id] = []);
    
    wordEdges.forEach(edge => {
        const src = edge.data.source;
        const tgt = edge.data.target;
        
        if (!adjacencyList[src].includes(tgt)) adjacencyList[src].push(tgt);
        if (!adjacencyList[tgt].includes(src)) adjacencyList[tgt].push(src);
    });
    
    let wordNodeToClusterMap = {};
    
    if (nodeVisualizationSettings.color === 'cluster-lpa') {
        console.log('üî¨ Running LPA on word network...');
        wordNodeToClusterMap = detectCommunitiesLPA(nodeIds, adjacencyList);
        
        wordEdgelistData.forEach(edge => {
            edge.fromCluster = wordNodeToClusterMap[edge.fromNode] || 0;
            edge.toCluster = wordNodeToClusterMap[edge.toNode] || 0;
        });
        
    } else if (nodeVisualizationSettings.color === 'cluster-louvain') {
        console.log('üî¨ Running Louvain on word network...');
        wordNodeToClusterMap = detectCommunitiesLouvain(nodeIds, adjacencyList);
        
        wordEdgelistData.forEach(edge => {
            edge.fromCluster = wordNodeToClusterMap[edge.fromNode] || 0;
            edge.toCluster = wordNodeToClusterMap[edge.toNode] || 0;
        });
    }
    
    // ‚≠ê FIX: Store in W-network global variable
    wordClusterAssignments = wordNodeToClusterMap;
    console.log('‚úÖ Word cluster assignments stored');

    // ‚≠ê CRITICAL FIX: Set active network type
    activeNetworkType = 'W-network';
    console.log('üéØ Active network set to: W-network');
    
    if (wNetworkViewMode === '1mode') {
        displayWordEdgelist();
    }
    
    // ‚≠ê FIX 1: Switch to Graph tab FIRST
    switchTab('graph');
    
    // ‚≠ê FIX 2: Use longer delay + requestAnimationFrame
    requestAnimationFrame(() => {
        setTimeout(() => {
            // ‚≠ê Render metrics AFTER tab is active
            displayWordNetworkMetricsGraph(wordNetworkMetrics, wordNodeElements.length, wordEdges.length);
            
            // ‚≠ê Then initialize graph
            setTimeout(() => {
                initializeWordNetworkGraph(wordNodeElements, wordEdges, wordNetworkMetrics, wordNodeToClusterMap);
                showSuccessMessage('‚úÖ Word network visualized in Graph tab!');
            }, 100);
        }, 100);
    });
}

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.2: DISPLAY WORD NETWORK METRICS ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Display word network metrics in Graph tab sidebar
 */
function displayWordNetworkMetricsGraph(metrics, nodeCount, edgeCount) {
    const statsDiv = document.getElementById('networkStatsGraph');
    
    // Calculate weighted statistics
    let totalWeight = 0;
    wordEdgelistData.forEach(edge => totalWeight += edge.weight);
    const avgWeight = (totalWeight / edgeCount).toFixed(2);
    const avgDegree = (2 * edgeCount / nodeCount).toFixed(2);
    const density = (2 * edgeCount / (nodeCount * (nodeCount - 1))).toFixed(3);
    
    statsDiv.innerHTML = `
        <h3>Word Network Statistics</h3>
        <div class="stat-line"><strong>Words (Nodes):</strong> ${nodeCount}</div>
        <div class="stat-line"><strong>Co-occurrences (Edges):</strong> ${edgeCount}</div>
        <div class="stat-line"><strong>Average Degree:</strong> ${avgDegree}</div>
        <div class="stat-line"><strong>Network Density:</strong> ${density}</div>
        <div class="stat-line"><strong>Average Weight:</strong> ${avgWeight}</div>
    `;
    
    // Display sortable metric tables
    displayTopMetricGraphSortable('degreeCentralityGraph', metrics, 'degree');
    displayTopMetricGraphSortable('betweennessCentralityGraph', metrics, 'betweenness');
    displayTopMetricGraphSortable('closenessCentralityGraph', metrics, 'closeness');
    displayTopMetricGraphSortable('eigenvectorCentralityGraph', metrics, 'eigenvector');
    
    // ‚≠ê Display community detection section
    const communitySection = document.getElementById('communityDetectionSection');
    
    if ((nodeVisualizationSettings.color === 'cluster-lpa' || 
         nodeVisualizationSettings.color === 'cluster-louvain') && 
        Object.keys(wordClusterAssignments).length > 0) {
        
        communitySection.style.display = 'block';
        
        const uniqueClusters = [...new Set(Object.values(wordClusterAssignments))];
        const numCommunities = uniqueClusters.length;
        
        const communityStats = document.getElementById('communityDetectionStats');
        communityStats.textContent = `Communities Detected: ${numCommunities}`;
        
        // Set initial sort state and render
        sortState.community = 'desc';
        
        // Render community table using GLOBAL wordClusterAssignments
        const communityData = document.getElementById('communityDetectionData');
        let entries = Object.entries(wordClusterAssignments);
        
        // Sort descending by default
        entries.sort((a, b) => b[1] - a[1]);
        
        communityData.innerHTML = entries.map(([node, clusterId]) => `
            <div class="metric-item">
                <span class="metric-node" title="${node}">${getNodeLabel(node)}</span>
                <span class="metric-value">${clusterId}</span>
            </div>
        `).join('');
        
        // Update arrow
        const arrow = document.getElementById('communitySortArrow');
        if (arrow) arrow.textContent = '‚ñº';
        
        console.log(`üìä Word network communities displayed: ${numCommunities} clusters`);
    } else {
        communitySection.style.display = 'none';
    }
}

// ============================================================================

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 4.3.2: INITIALIZE WORD NETWORK CYTOSCAPE GRAPH ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Initialize Cytoscape.js graph for word network
 */
function initializeWordNetworkGraph(nodes, edges, metrics, nodeToClusterMap) {
    const container = document.getElementById('networkGraphCanvas');
    
    // ‚≠ê FIX: Destroy BOTH instances to avoid conflicts
    if (cyInstance) {
        cyInstance.destroy();
        cyInstance = null;
    }
    
    if (wordCyInstance) {
        wordCyInstance.destroy();
        wordCyInstance = null;
    }
    
    // Ensure container has dimensions
    if (container.offsetHeight === 0) {
        container.style.minHeight = '400px';
    }
    
    // Calculate node sizes based on selected metric
    const sizeMetric = nodeVisualizationSettings.size;
    const metricValues = Object.values(metrics).map(m => m[sizeMetric]);
    const maxMetricValue = Math.max(...metricValues, 0.0001);
    
    console.log(`üìä Word network node sizing: ${sizeMetric}, max value: ${maxMetricValue.toFixed(4)}`);
    
    // ‚≠ê Apply node coloring
    const colorSetting = nodeVisualizationSettings.color;
    console.log(`üé® Word network coloring mode: ${colorSetting}`);
    
    const elements = [
        ...nodes.map(node => {
            let nodeColor = '#3498db'; // Default blue
            
            // Apply cluster coloring if enabled
            if (colorSetting === 'cluster-lpa' || colorSetting === 'cluster-louvain') {
                nodeColor = getNodeColorByCluster(node.data.id, nodeToClusterMap);
                const clusterId = nodeToClusterMap[node.data.id];
                const algorithm = colorSetting === 'cluster-lpa' ? 'LPA' : 'Louvain';
                console.log(`üé® Word "${node.data.label}" ‚Üí ${algorithm} Cluster ${clusterId} Color: ${nodeColor}`);
            }
            
            return {
                ...node,
                data: {
                    ...node.data,
                    size: 20 + (metrics[node.data.id][sizeMetric] / maxMetricValue) * 40,
                    color: nodeColor
                }
            };
        }),
        ...edges
    ];
    
    // Create Cytoscape instance for word network
    wordCyInstance = cytoscape({
        container: container,
        elements: elements,
        style: [
            {
                selector: 'node',
                style: {
                    'background-color': 'data(color)',
                    'label': 'data(label)',
                    'width': 'data(size)',
                    'height': 'data(size)',
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '12px',
                    'color': '#2c3e50',
                    'text-outline-width': 2,
                    'text-outline-color': '#fff',
                    'border-width': 2,
                    'border-color': '#2c3e50'
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': 'data(weight)',  // Edge thickness = co-occurrence count
                    'line-color': '#95a5a6',
                    'curve-style': 'bezier',
                    'label': 'data(label)',   // Show weight as label
                    'font-size': '9px',
                    'text-rotation': 'autorotate',
                    'text-margin-y': -8,
                    'color': '#7f8c8d',
                    'text-background-color': '#fff',
                    'text-background-opacity': 0.7,
                    'text-background-padding': '2px'
                }
            }
        ],
        layout: {
            name: 'cose',
            idealEdgeLength: 100,
            nodeOverlap: 20,
            refresh: 20,
            fit: true,
            padding: 30,
            randomize: false,
            componentSpacing: 100,
            nodeRepulsion: 400000,
            edgeElasticity: 100,
            nestingFactor: 5,
            gravity: 80,
            numIter: 1000,
            initialTemp: 200,
            coolingFactor: 0.95,
            minTemp: 1.0
        }
    });
    
    // Force resize after layout completes
    wordCyInstance.on('layoutstop', function() {
        wordCyInstance.resize();
        wordCyInstance.fit();
    });
    
    // Add click interaction to show node details
    wordCyInstance.on('tap', 'node', function(evt) {
        const node = evt.target;
        const nodeId = node.id();
        const nodeMetrics = metrics[nodeId];
        
        // Build cluster info if enabled
        let clusterInfo = '';
        if ((colorSetting === 'cluster-lpa' || colorSetting === 'cluster-louvain') && nodeToClusterMap[nodeId]) {
            const algorithm = colorSetting === 'cluster-lpa' ? 'LPA' : 'Louvain';
            clusterInfo = `Cluster (${algorithm}): ${nodeToClusterMap[nodeId]}\n\n`;
        }
        
        // Show alert with all metrics
        alert(`Word: ${nodeId}\n\n` +
              clusterInfo +
              `Degree: ${nodeMetrics.degree.toFixed(3)}\n` +
              `Betweenness: ${nodeMetrics.betweenness.toFixed(3)}\n` +
              `Closeness: ${nodeMetrics.closeness.toFixed(3)}\n` +
              `Eigenvector: ${nodeMetrics.eigenvector.toFixed(3)}`);
    });
    
    // Add edge click to show co-occurrence count
    wordCyInstance.on('tap', 'edge', function(evt) {
        const edge = evt.target;
        const source = edge.data('source');
        const target = edge.data('target');
        const weight = edge.data('weight');
        
        alert(`Co-occurrence:\n\n"${source}" ‚Üî "${target}"\n\nCount: ${weight}`);
    });
    
    console.log('‚úÖ Phase 4.3.2 complete: Word network visualized with metrics and clustering!');
}

// ============================================================================


/**
 * Helper: Extract plain text from HTML (same as getPlainText but standalone)
 */
function extractPlainTextFromHTML(html) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    return tempDiv.textContent || tempDiv.innerText || '';
}

/**
 * Helper: Escape regex special characters
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Helper: Check if token is stopword (considering active mode)
 */
function isStopwordActive(token, activeStopwords) {
    return activeStopwords.english.has(token) || 
           activeStopwords.chinese.has(token) || 
           activeStopwords.custom.has(token);
}

// ============================================================================


/**
 * Recursively process text nodes while preserving HTML structure
 */
function processTextNodes(element, method, separator) {
    // Iterate through child nodes
    const childNodes = Array.from(element.childNodes);
    
    for (let node of childNodes) {
        if (node.nodeType === Node.TEXT_NODE) {
            // This is a text node - tokenize it
            const originalText = node.textContent;
            
            if (originalText.trim().length === 0) {
                // Skip whitespace-only nodes
                continue;
            }
            
            let tokenizedText;
            
            if (method === 'character') {
                // Character-level tokenization
                tokenizedText = tokenizeByCharacter(originalText, separator);
            } else {
                // Word-level tokenization using Jieba
                tokenizedText = tokenizeByWord(originalText, separator);
            }
            
            // Replace node content
            node.textContent = tokenizedText;
            
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            // Skip images, videos, and other non-text elements
            if (node.tagName === 'IMG' || node.tagName === 'VIDEO' || 
                node.tagName === 'IFRAME' || node.tagName === 'SVG') {
                continue;
            }
            
            // Recursively process child elements
            processTextNodes(node, method, separator);
        }
    }
}

/**
 * Character-level tokenization
 * Adds separator between each character (including spaces if they exist)
 */
function tokenizeByCharacter(text, separator) {
    // ‚≠ê BUG FIX: Don't tokenize the separator itself
    // Split into characters, filter out separator, then join
    const chars = Array.from(text);
    
    // Remove any occurrence of the separator character from the character array
    const filteredChars = chars.filter(char => char !== separator);
    
    // Join with separator
    return filteredChars.join(separator);
}

/**
 * Word-level tokenization using Jieba.js
 * Handles both Chinese and English text intelligently
 */
function tokenizeByWord(text, separator) {
    if (!jiebaInstance) {
        console.error('Jieba instance not available');
        return text; // Return original if jieba not loaded
    }
    
    try {
        // Use Jieba to cut the text
        // This handles both Chinese and English intelligently
        const words = jiebaInstance.cut(text);
        
        // ‚≠ê BUG FIX: Remove separator from word list before joining
        // Filter out any word that equals the separator exactly
        const filteredWords = words.filter(word => word !== separator);
        
        // Join with the specified separator
        return filteredWords.join(separator);
        
    } catch (error) {
        console.error('Error during Jieba tokenization:', error);
        return text; // Return original on error
    }
}

// ============================================================================


// ‚≠ê‚≠ê‚≠ê PHASE 3: SORTING STATE FOR TABLES (ALIGNED) ‚≠ê‚≠ê‚≠ê
let sortState = {
    degree: 'desc',      // Current sort: 'asc', 'desc', 'none'
    betweenness: 'desc',
    closeness: 'desc',
    eigenvector: 'desc',
    community: 'desc'    // ‚≠ê ALIGNED: Same as centrality metrics
};
// ============================================================================


        const relationColors = {
            'description': '#e74c3c',
            'comparison': '#3498db',
            'contrast': '#9b59b6',
            'analogy': '#e91e63',
            'sequence': '#2ecc71',
            'cause': '#f39c12',
            'solution': '#e67e22',
            'source': '#1abc9c',
            'custom': '#34495e'
        };

// ============================================================================
// ‚≠ê‚≠ê‚≠ê ZOOM FUNCTIONALITY - FIXED ‚≠ê‚≠ê‚≠ê
// ============================================================================

// Zoom levels: 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%, 110%, 120%, 130%, 140%, 150%, 160%, 170%, 180%, 190%, 200%
const zoomLevels = [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0];
const defaultZoomIndex = 7; // 100%

// Per-canvas zoom tracking
let canvasZoomLevels = {}; // { canvasId: zoomIndex }

/**
 * Get current zoom index for active canvas
 * ‚≠ê FIX: Added safeguard to prevent stale reads
 */
function getCurrentZoomIndex() {
    if (currentCanvasId === 'help' || currentCanvasId === 'settings' || currentCanvasId === 'graph') {
        return defaultZoomIndex;
    }
    
    if (canvasZoomLevels[currentCanvasId] === undefined) {
        canvasZoomLevels[currentCanvasId] = defaultZoomIndex;
    }
    
    return canvasZoomLevels[currentCanvasId];
}

/**
 * Get current zoom level (0.5 - 2.0)
 */
function getCurrentZoomLevel() {
    return zoomLevels[getCurrentZoomIndex()];
}

/**
 * Apply zoom to current canvas
 * ‚≠ê FIX: Store zoom FIRST, then apply visual changes
 */
function applyZoom(zoomIndex) {
    if (currentCanvasId === 'help' || currentCanvasId === 'settings' || currentCanvasId === 'graph') {
        return; // Don't zoom special pages
    }
    
    // ‚≠ê CRITICAL FIX: Validate zoom index bounds
    if (zoomIndex < 0 || zoomIndex >= zoomLevels.length) {
        console.error(`Invalid zoom index: ${zoomIndex}`);
        return;
    }
    
    // ‚≠ê CRITICAL FIX: Store zoom level FIRST before any other operations
    canvasZoomLevels[currentCanvasId] = zoomIndex;
    
    const canvasPage = document.getElementById('canvas-' + currentCanvasId);
    if (!canvasPage) return;
    
    const canvasInner = canvasPage.querySelector('.canvas-inner');
    if (!canvasInner) return;
    
    const zoomLevel = zoomLevels[zoomIndex];
    
    // Apply transform
    canvasInner.classList.add('zoomed');
    canvasInner.style.transform = `scale(${zoomLevel})`;
    
    // Update display
    const zoomDisplay = document.getElementById('zoomDisplay');
    if (zoomDisplay) {
        zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
    }
    
    // Update button states
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    
    if (zoomOutBtn) {
        zoomOutBtn.disabled = (zoomIndex === 0);
    }
    
    if (zoomInBtn) {
        zoomInBtn.disabled = (zoomIndex === zoomLevels.length - 1);
    }
    
    console.log(`üîç Canvas ${currentCanvasId} zoomed to ${Math.round(zoomLevel * 100)}% (index: ${zoomIndex})`);
}

/**
 * Zoom in (increase zoom level)
 * ‚≠ê FIX: Calculate target index directly without intermediate calls
 */
function zoomIn() {
    // ‚≠ê Read current index once
    const currentIndex = canvasZoomLevels[currentCanvasId] !== undefined 
        ? canvasZoomLevels[currentCanvasId] 
        : defaultZoomIndex;
    
    // ‚≠ê Calculate target index
    const targetIndex = Math.min(currentIndex + 1, zoomLevels.length - 1);
    
    console.log(`üìà Zoom In: ${currentIndex} ‚Üí ${targetIndex} (${Math.round(zoomLevels[currentIndex] * 100)}% ‚Üí ${Math.round(zoomLevels[targetIndex] * 100)}%)`);
    
    // ‚≠ê Apply directly
    applyZoom(targetIndex);
}

/**
 * Zoom out (decrease zoom level)
 * ‚≠ê FIX: Calculate target index directly without intermediate calls
 */
function zoomOut() {
    // ‚≠ê Read current index once
    const currentIndex = canvasZoomLevels[currentCanvasId] !== undefined 
        ? canvasZoomLevels[currentCanvasId] 
        : defaultZoomIndex;
    
    // ‚≠ê Calculate target index
    const targetIndex = Math.max(currentIndex - 1, 0);
    
    console.log(`üìâ Zoom Out: ${currentIndex} ‚Üí ${targetIndex} (${Math.round(zoomLevels[currentIndex] * 100)}% ‚Üí ${Math.round(zoomLevels[targetIndex] * 100)}%)`);
    
    // ‚≠ê Apply directly
    applyZoom(targetIndex);
}

/**
 * Reset zoom to 100%
 */
function resetZoom() {
    console.log(`üîÑ Reset Zoom to 100%`);
    applyZoom(defaultZoomIndex);
}

/**
 * Keyboard shortcuts for zoom
 */
document.addEventListener('keydown', function(e) {
    // Ctrl/Cmd + Plus/Equals = Zoom In
    if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
        e.preventDefault();
        zoomIn();
    }
    
    // Ctrl/Cmd + Minus = Zoom Out
    if ((e.ctrlKey || e.metaKey) && e.key === '-') {
        e.preventDefault();
        zoomOut();
    }
    
    // Ctrl/Cmd + 0 = Reset Zoom
    if ((e.ctrlKey || e.metaKey) && e.key === '0') {
        e.preventDefault();
        resetZoom();
    }
});

/**
 * Mouse wheel zoom (Ctrl + Scroll)
 */
document.getElementById('canvasContent').addEventListener('wheel', function(e) {
    if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        
        if (e.deltaY < 0) {
            zoomIn(); // Scroll up = Zoom in
        } else {
            zoomOut(); // Scroll down = Zoom out
        }
    }
}, { passive: false });

// ============================================================================

        // Network Analysis Functions
function analyzeNetwork() {
    const allConnections = getAllConnections();
    
    if (allConnections.length === 0) {
        alert('No connections found. Create connections between textboxes first.');
        return;
    }

    // Build graph data
    const nodes = new Set();
    const edges = [];
    
    allConnections.forEach((conn, index) => {
        nodes.add(conn.source);
        nodes.add(conn.target);
        edges.push({
            data: {
                id: `e${index}`,
                source: conn.source,
                target: conn.target,
                label: conn.relation
            }
        });
    });

    const nodeElements = Array.from(nodes).map(node => ({
        data: {
            id: node,
            label: getNodeLabel(node)
        }
    }));

    // Calculate centrality metrics
    const metrics = calculateCentralityMetrics(nodeElements, edges);

    // Build source mapping
    const nodeToSourceMap = buildNodeToSourceMap(allConnections);
    
    // Run cluster detection
    const nodeIds = Array.from(nodes);
    const adjacencyList = {};
    nodeIds.forEach(id => adjacencyList[id] = []);
    
    edges.forEach(edge => {
        const src = edge.data.source;
        const tgt = edge.data.target;
        
        if (!adjacencyList[src].includes(tgt)) adjacencyList[src].push(tgt);
        if (!adjacencyList[tgt].includes(src)) adjacencyList[tgt].push(src);
    });
    
    let nodeToClusterMap = {};
    
    if (nodeVisualizationSettings.color === 'cluster-lpa') {
        console.log('üî¨ Running LPA on T-network...');
        nodeToClusterMap = detectCommunitiesLPA(nodeIds, adjacencyList);
    } else if (nodeVisualizationSettings.color === 'cluster-louvain') {
        console.log('üî¨ Running Louvain on T-network...');
        nodeToClusterMap = detectCommunitiesLouvain(nodeIds, adjacencyList);
    }
    
    // ‚≠ê FIX: Store in T-network global variable
    clusterAssignments = nodeToClusterMap;
    console.log('‚úÖ T-network cluster assignments stored');

    // ‚≠ê CRITICAL FIX: Set active network type
    activeNetworkType = 'T-network';
    console.log('üéØ Active network set to: T-network');

    // ‚≠ê FIX 1: Switch to Graph tab FIRST
    switchTab('graph');

    // ‚≠ê FIX 2: Use longer delay + requestAnimationFrame for metrics rendering
    requestAnimationFrame(() => {
        setTimeout(() => {
            // ‚≠ê Render metrics AFTER tab is active
            displayNetworkMetricsGraph(metrics, nodeElements.length, edges.length);
            
            // ‚≠ê Then initialize graph
            setTimeout(() => {
                initializeCytoscapeGraph(nodeElements, edges, metrics, nodeToSourceMap, nodeToClusterMap);
                showSuccessMessage('‚úÖ T-network visualized in Graph tab!');
            }, 100); // Additional delay for community section rendering
        }, 100);
    });
}

        function getAllConnections() {
            const allConnections = [];
            
            canvasPages.forEach(canvas => {
                if (typeof canvas.id === 'number') {
canvas.connections.forEach(conn => {
    const fromBox = canvas.textboxes.find(tb => tb.id === conn.from);
    const toBox = canvas.textboxes.find(tb => tb.id === conn.to);
    
    // Skip connections where either textbox is greyed out
    if (fromBox && toBox && !fromBox.isGreyed && !toBox.isGreyed) {
                            const fromText = getPlainText(fromBox.text);
                            const toText = getPlainText(toBox.text);
                            
                            let sourceText, targetText;
                            
                            if (['sequence', 'cause', 'solution', 'contrast', 'description', 'source', 'custom'].includes(conn.relation)) {
                                if (conn.reversed) {
                                    sourceText = toText;
                                    targetText = fromText;
                                } else {
                                    sourceText = fromText;
                                    targetText = toText;
                                }
                            } else {
                                sourceText = fromText;
                                targetText = toText;
                            }
                            
                            const displayLabel = conn.relation === 'custom' ? conn.customLabel : conn.relation;
                            
                            allConnections.push({
                                source: sourceText,
                                target: targetText,
                                relation: displayLabel
                            });
                        }
                    });
                }
            });
            
            return allConnections;
        }

        function getNodeLabel(nodeText) {
            // Return first 4 characters or full text if shorter
            return nodeText.length <= 4 ? nodeText : nodeText.substring(0, 4);
        }

        function getPlainText(html) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            return tempDiv.textContent || tempDiv.innerText || '';
        }

        function calculateCentralityMetrics(nodes, edges) {
            const nodeIds = nodes.map(n => n.data.id);
            const nodeMap = {};
            nodeIds.forEach(id => {
                nodeMap[id] = {
                    degree: 0,
                    betweenness: 0,
                    closeness: 0,
                    eigenvector: 0
                };
            });

            // Build adjacency list
            const adjacency = {};
            nodeIds.forEach(id => adjacency[id] = []);
            
            edges.forEach(edge => {
                const src = edge.data.source;
                const tgt = edge.data.target;
                
                if (!adjacency[src].includes(tgt)) adjacency[src].push(tgt);
                if (!adjacency[tgt].includes(src)) adjacency[tgt].push(src);
                
                nodeMap[src].degree++;
                nodeMap[tgt].degree++;
            });

            // Calculate betweenness centrality
            const betweenness = calculateBetweenness(nodeIds, adjacency);
            Object.keys(betweenness).forEach(id => {
                nodeMap[id].betweenness = betweenness[id];
            });

            // Calculate closeness centrality
            const closeness = calculateCloseness(nodeIds, adjacency);
            Object.keys(closeness).forEach(id => {
                nodeMap[id].closeness = closeness[id];
            });

            // Calculate eigenvector centrality
            const eigenvector = calculateEigenvector(nodeIds, adjacency);
            Object.keys(eigenvector).forEach(id => {
                nodeMap[id].eigenvector = eigenvector[id];
            });

            return nodeMap;
        }

        function calculateBetweenness(nodes, adjacency) {
            const betweenness = {};
            nodes.forEach(n => betweenness[n] = 0);

            nodes.forEach(s => {
                const stack = [];
                const paths = {};
                const sigma = {};
                const delta = {};
                const dist = {};

                nodes.forEach(w => {
                    paths[w] = [];
                    sigma[w] = 0;
                    dist[w] = -1;
                    delta[w] = 0;
                });

                sigma[s] = 1;
                dist[s] = 0;
                const queue = [s];

                while (queue.length > 0) {
                    const v = queue.shift();
                    stack.push(v);

                    adjacency[v].forEach(w => {
                        if (dist[w] < 0) {
                            queue.push(w);
                            dist[w] = dist[v] + 1;
                        }
                        if (dist[w] === dist[v] + 1) {
                            sigma[w] += sigma[v];
                            paths[w].push(v);
                        }
                    });
                }

                while (stack.length > 0) {
                    const w = stack.pop();
                    paths[w].forEach(v => {
                        delta[v] += (sigma[v] / sigma[w]) * (1 + delta[w]);
                    });
                    if (w !== s) {
                        betweenness[w] += delta[w];
                    }
                }
            });

            // Normalize
            const n = nodes.length;
            const normFactor = n > 2 ? 2 / ((n - 1) * (n - 2)) : 1;
            Object.keys(betweenness).forEach(k => {
                betweenness[k] *= normFactor;
            });

            return betweenness;
        }

        function calculateCloseness(nodes, adjacency) {
            const closeness = {};

            nodes.forEach(s => {
                const dist = {};
                nodes.forEach(n => dist[n] = Infinity);
                dist[s] = 0;

                const queue = [s];
                while (queue.length > 0) {
                    const v = queue.shift();
                    adjacency[v].forEach(w => {
                        if (dist[w] === Infinity) {
                            dist[w] = dist[v] + 1;
                            queue.push(w);
                        }
                    });
                }

                let sum = 0;
                let reachable = 0;
                nodes.forEach(n => {
                    if (n !== s && dist[n] !== Infinity) {
                        sum += dist[n];
                        reachable++;
                    }
                });

                closeness[s] = reachable > 0 ? reachable / sum : 0;
            });

            return closeness;
        }

        function calculateEigenvector(nodes, adjacency, iterations = 100) {
            const eigenvector = {};
            nodes.forEach(n => eigenvector[n] = 1);

            for (let i = 0; i < iterations; i++) {
                const newScores = {};
                nodes.forEach(n => newScores[n] = 0);

                nodes.forEach(n => {
                    adjacency[n].forEach(neighbor => {
                        newScores[neighbor] += eigenvector[n];
                    });
                });

                // Normalize
                let norm = 0;
                nodes.forEach(n => norm += newScores[n] * newScores[n]);
                norm = Math.sqrt(norm);

                if (norm > 0) {
                    nodes.forEach(n => eigenvector[n] = newScores[n] / norm);
                }
            }

            return eigenvector;
        }
		
		// ============================================================================
		// ‚≠ê‚≠ê‚≠ê LABEL PROPAGATION ALGORITHM (LPA) FOR COMMUNITY DETECTION ‚≠ê‚≠ê‚≠ê
		// ============================================================================

/**
 * Detect communities using Label Propagation Algorithm
 * @param {Array} nodeIds - Array of node IDs
 * @param {Object} adjacencyList - Adjacency list { nodeId: [neighbor1, neighbor2, ...] }
 * @returns {Object} - { nodeId: clusterId } mapping
 */
function detectCommunitiesLPA(nodeIds, adjacencyList) {
    console.log('üî¨ LPA: Starting community detection...');
    console.log(`üìä LPA Input: ${nodeIds.length} nodes`);
    
    // Handle edge case: no nodes
    if (nodeIds.length === 0) {
        console.log('‚ö†Ô∏è LPA: No nodes to cluster');
        return {};
    }
    
    // Handle edge case: single node
    if (nodeIds.length === 1) {
        const result = {};
        result[nodeIds[0]] = 1;
        console.log('‚úÖ LPA: Single node assigned to cluster 1');
        return result;
    }
    
    // Step 1: Initialize each node with unique label
    const labels = {};
    nodeIds.forEach((id, index) => {
        labels[id] = index + 1; // 1-based cluster IDs
    });
    
    console.log('‚úÖ LPA: Initialized labels');
    
    // Step 2: Iterate until convergence
    let changed = true;
    let iterations = 0;
    const MAX_ITER = 100;
    
    while (changed && iterations < MAX_ITER) {
        changed = false;
        iterations++;
        
        // Randomize node order (important for quality)
        const shuffled = [...nodeIds].sort(() => Math.random() - 0.5);
        
        for (let node of shuffled) {
            const neighbors = adjacencyList[node] || [];
            
            // Skip isolated nodes
            if (neighbors.length === 0) continue;
            
            // Count neighbor labels
            const neighborLabels = {};
            neighbors.forEach(neighbor => {
                const label = labels[neighbor];
                if (label !== undefined) {
                    neighborLabels[label] = (neighborLabels[label] || 0) + 1;
                }
            });
            
            // Skip if no valid neighbors
            if (Object.keys(neighborLabels).length === 0) continue;
            
            // Find most common label (with random tie-breaking)
            let maxCount = 0;
            let bestLabels = [];
            
            Object.entries(neighborLabels).forEach(([label, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    bestLabels = [parseInt(label)];
                } else if (count === maxCount) {
                    bestLabels.push(parseInt(label));
                }
            });
            
            // Random tie-breaking
            const bestLabel = bestLabels[Math.floor(Math.random() * bestLabels.length)];
            
            // Update if changed
            if (bestLabel !== labels[node]) {
                labels[node] = bestLabel;
                changed = true;
            }
        }
        
        console.log(`üîÑ LPA Iteration ${iterations}: ${changed ? 'Labels changed' : 'Converged'}`);
    }
    
    console.log(`‚úÖ LPA: Converged after ${iterations} iterations`);
    
    // Step 3: Renumber communities sequentially (1, 2, 3, ...)
    const uniqueLabels = [...new Set(Object.values(labels))].sort((a, b) => a - b);
    const labelMap = {};
    uniqueLabels.forEach((oldLabel, index) => {
        labelMap[oldLabel] = index + 1;
    });
    
    const renumbered = {};
    Object.keys(labels).forEach(node => {
        renumbered[node] = labelMap[labels[node]];
    });
    
    console.log('üé® LPA: Final cluster assignments:', renumbered);
    console.log(`üìä LPA: Found ${uniqueLabels.length} communities`);
    
    // Log cluster distribution
    const clusterCounts = {};
    Object.values(renumbered).forEach(clusterId => {
        clusterCounts[clusterId] = (clusterCounts[clusterId] || 0) + 1;
    });
    console.log('üìä LPA: Cluster sizes:', clusterCounts);
    
    return renumbered;
}


// ============================================================================
// ‚≠ê‚≠ê‚≠ê LOUVAIN METHOD FOR COMMUNITY DETECTION ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Detect communities using Louvain Method (modularity optimization)
 * @param {Array} nodeIds - Array of node IDs
 * @param {Object} adjacencyList - Adjacency list { nodeId: [neighbor1, neighbor2, ...] }
 * @returns {Object} - { nodeId: clusterId } mapping
 */
function detectCommunitiesLouvain(nodeIds, adjacencyList) {
    console.log('üî¨ Louvain: Starting community detection...');
    console.log(`üìä Louvain Input: ${nodeIds.length} nodes`);
    
    // Handle edge cases
    if (nodeIds.length === 0) {
        console.log('‚ö†Ô∏è Louvain: No nodes to cluster');
        return {};
    }
    
    if (nodeIds.length === 1) {
        const result = {};
        result[nodeIds[0]] = 1;
        console.log('‚úÖ Louvain: Single node assigned to cluster 1');
        return result;
    }
    
    // Phase 1: Initialize - each node in its own community
    let communities = {};
    nodeIds.forEach((id, index) => {
        communities[id] = index;
    });
    
    // Calculate total edge weight (m = total edges)
    let totalEdges = 0;
    Object.keys(adjacencyList).forEach(node => {
        totalEdges += adjacencyList[node].length;
    });
    const m = totalEdges / 2; // Undirected graph
    
    console.log(`üìä Louvain: Total edges m = ${m}`);
    
    // Phase 2: Iterative modularity optimization
    let improved = true;
    let iteration = 0;
    let currentModularity = calculateModularity(communities, adjacencyList, m);
    
    console.log(`üìä Louvain: Initial modularity = ${currentModularity.toFixed(4)}`);
    
    while (improved && iteration < 100) {
        improved = false;
        iteration++;
        
        // Process each node in random order
        const shuffled = [...nodeIds].sort(() => Math.random() - 0.5);
        
        for (let node of shuffled) {
            const currentCommunity = communities[node];
            const neighbors = adjacencyList[node] || [];
            
            if (neighbors.length === 0) continue;
            
            // Calculate modularity gain for moving to each neighbor's community
            const communityGains = {};
            
            neighbors.forEach(neighbor => {
                const neighborCommunity = communities[neighbor];
                if (neighborCommunity !== currentCommunity) {
                    if (!(neighborCommunity in communityGains)) {
                        communityGains[neighborCommunity] = 0;
                    }
                    communityGains[neighborCommunity]++;
                }
            });
            
            // Find best community to move to
            let bestCommunity = currentCommunity;
            let bestGain = 0;
            
            Object.entries(communityGains).forEach(([community, gain]) => {
                const modularityGain = calculateModularityGain(
                    node, 
                    parseInt(community), 
                    communities, 
                    adjacencyList, 
                    m
                );
                
                if (modularityGain > bestGain) {
                    bestGain = modularityGain;
                    bestCommunity = parseInt(community);
                }
            });
            
            // Move node to best community if it improves modularity
            if (bestCommunity !== currentCommunity && bestGain > 0) {
                communities[node] = bestCommunity;
                improved = true;
            }
        }
        
        const newModularity = calculateModularity(communities, adjacencyList, m);
        console.log(`üîÑ Louvain Iteration ${iteration}: Modularity = ${newModularity.toFixed(4)} (Œî = ${(newModularity - currentModularity).toFixed(4)})`);
        currentModularity = newModularity;
    }
    
    console.log(`‚úÖ Louvain: Converged after ${iteration} iterations`);
    console.log(`üìä Louvain: Final modularity = ${currentModularity.toFixed(4)}`);
    
    // Renumber communities sequentially (1, 2, 3, ...)
    const uniqueCommunities = [...new Set(Object.values(communities))].sort((a, b) => a - b);
    const communityMap = {};
    uniqueCommunities.forEach((oldId, index) => {
        communityMap[oldId] = index + 1;
    });
    
    const renumbered = {};
    Object.keys(communities).forEach(node => {
        renumbered[node] = communityMap[communities[node]];
    });
    
    console.log('üé® Louvain: Final cluster assignments:', renumbered);
    console.log(`üìä Louvain: Found ${uniqueCommunities.length} communities`);
    
    // Log cluster distribution
    const clusterCounts = {};
    Object.values(renumbered).forEach(clusterId => {
        clusterCounts[clusterId] = (clusterCounts[clusterId] || 0) + 1;
    });
    console.log('üìä Louvain: Cluster sizes:', clusterCounts);
    
    return renumbered;
}

/**
 * Calculate global modularity Q
 * Q = (1/2m) Œ£ [A_ij - (k_i * k_j)/(2m)] * Œ¥(c_i, c_j)
 */
function calculateModularity(communities, adjacencyList, m) {
    let Q = 0;
    const nodes = Object.keys(communities);
    
    // Calculate degree for each node
    const degrees = {};
    nodes.forEach(node => {
        degrees[node] = (adjacencyList[node] || []).length;
    });
    
    // Calculate modularity
    nodes.forEach(i => {
        nodes.forEach(j => {
            if (communities[i] === communities[j]) {
                // Check if edge exists
                const A_ij = (adjacencyList[i] || []).includes(j) ? 1 : 0;
                const expected = (degrees[i] * degrees[j]) / (2 * m);
                Q += (A_ij - expected);
            }
        });
    });
    
    return Q / (2 * m);
}

/**
 * Calculate modularity gain from moving node to a new community
 */
function calculateModularityGain(node, newCommunity, communities, adjacencyList, m) {
    const oldCommunity = communities[node];
    
    // Temporarily move node
    const tempCommunities = { ...communities };
    tempCommunities[node] = newCommunity;
    
    const newQ = calculateModularity(tempCommunities, adjacencyList, m);
    const oldQ = calculateModularity(communities, adjacencyList, m);
    
    return newQ - oldQ;
}

// ============================================================================


/**
 * Get color for a cluster based on cluster ID
 * Uses a 10-color palette (similar to source text colors)
 */
const clusterColors = [
    '#e74c3c',  // Cluster 1 - Red
    '#3498db',  // Cluster 2 - Blue
    '#27ae60',  // Cluster 3 - Green
    '#9b59b6',  // Cluster 4 - Purple
    '#e67e22',  // Cluster 5 - Orange
    '#e91e63',  // Cluster 6 - Pink
    '#f39c12',  // Cluster 7 - Yellow
    '#1abc9c',  // Cluster 8 - Cyan
    '#795548',  // Cluster 9 - Brown
    '#95a5a6'   // Cluster 10+ - Gray
];

function getNodeColorByCluster(nodeText, nodeToClusterMap) {
    const clusterId = nodeToClusterMap[nodeText];
    
    // If clusterId is null/undefined, use gray (index 9)
    if (clusterId === null || clusterId === undefined) {
        return clusterColors[9]; // Gray for unknown cluster
    }
    
    // Map clusterId (1, 2, 3...) to color index (0, 1, 2...)
    // Cap at index 9 for Cluster 10+
    const colorIndex = Math.min(clusterId - 1, 9);
    return clusterColors[colorIndex];
}

// ============================================================================
		

        function displayNetworkMetrics(metrics, nodeCount, edgeCount) {
            const statsDiv = document.getElementById('networkStats');
            const avgDegree = (2 * edgeCount / nodeCount).toFixed(2);
            const density = (2 * edgeCount / (nodeCount * (nodeCount - 1))).toFixed(3);
            
            statsDiv.innerHTML = `
                <h3>Network Statistics</h3>
                <div class="stat-line"><strong>Nodes:</strong> ${nodeCount}</div>
                <div class="stat-line"><strong>Edges:</strong> ${edgeCount}</div>
                <div class="stat-line"><strong>Average Degree:</strong> ${avgDegree}</div>
                <div class="stat-line"><strong>Density:</strong> ${density}</div>
            `;

            // Display top nodes for each metric
            displayTopMetric('degreeCentrality', metrics, 'degree');
            displayTopMetric('betweennessCentrality', metrics, 'betweenness');
            displayTopMetric('closenessCentrality', metrics, 'closeness');
            displayTopMetric('eigenvectorCentrality', metrics, 'eigenvector');
        }

        function displayTopMetric(elementId, metrics, metricName) {
            const div = document.getElementById(elementId);
            const sorted = Object.entries(metrics)
                .sort((a, b) => b[1][metricName] - a[1][metricName])
                .slice(0, 10);

            div.innerHTML = sorted.map(([node, values]) => `
                <div class="metric-item">
                    <span class="metric-node" title="${node}">${getNodeLabel(node)}</span>
                    <span class="metric-value">${values[metricName].toFixed(3)}</span>
                </div>
            `).join('');
        }
		
function displayNetworkMetricsGraph(metrics, nodeCount, edgeCount) {
    const statsDiv = document.getElementById('networkStatsGraph');
    const avgDegree = (2 * edgeCount / nodeCount).toFixed(2);
    const density = (2 * edgeCount / (nodeCount * (nodeCount - 1))).toFixed(3);
    
    statsDiv.innerHTML = `
        <h3>Network Statistics</h3>
        <div class="stat-line"><strong>Nodes:</strong> ${nodeCount}</div>
        <div class="stat-line"><strong>Edges:</strong> ${edgeCount}</div>
        <div class="stat-line"><strong>Average Degree:</strong> ${avgDegree}</div>
        <div class="stat-line"><strong>Density:</strong> ${density}</div>
    `;

    // ‚≠ê‚≠ê‚≠ê PHASE 3: MAKE HEADERS CLICKABLE FOR SORTING ‚≠ê‚≠ê‚≠ê
    // Display top nodes for each metric WITH SORTING
    displayTopMetricGraphSortable('degreeCentralityGraph', metrics, 'degree');
    displayTopMetricGraphSortable('betweennessCentralityGraph', metrics, 'betweenness');
    displayTopMetricGraphSortable('closenessCentralityGraph', metrics, 'closeness');
    displayTopMetricGraphSortable('eigenvectorCentralityGraph', metrics, 'eigenvector');
    
    // ‚≠ê‚≠ê‚≠ê PHASE 3: SHOW/HIDE COMMUNITY SECTION ‚≠ê‚≠ê‚≠ê
    const communitySection = document.getElementById('communityDetectionSection');
    const communityStats = document.getElementById('communityDetectionStats');
    const communityData = document.getElementById('communityDetectionData');
    
    if ((nodeVisualizationSettings.color === 'cluster-lpa' || 
         nodeVisualizationSettings.color === 'cluster-louvain') && 
        Object.keys(clusterAssignments).length > 0) {
        
        // Show section
        communitySection.style.display = 'block';
        
        // Count communities
        const uniqueClusters = [...new Set(Object.values(clusterAssignments))];
        const numCommunities = uniqueClusters.length;
        
        // Display stats
        communityStats.textContent = `Communities Detected: ${numCommunities}`;
        
        // ‚≠ê ALIGNED: Initial sort using toggle (starts at desc, same as centrality)
        sortState.community = 'desc'; // Set initial state
        sortCommunityTable('toggle'); // Will render with desc sort
        
        console.log(`üìä Community Detection displayed: ${numCommunities} communities`);
    } else {
        // Hide section
        communitySection.style.display = 'none';
    }
    // ============================================================================
}

/**
 * ‚≠ê NEW: Display metric with sortable header
 */
function displayTopMetricGraphSortable(elementId, metrics, metricName) {
    const div = document.getElementById(elementId);
    if (!div) return;
    
    // Get header (previous sibling h3)
    const header = div.previousElementSibling;
    if (header && header.tagName === 'H3') {
        // Make clickable
        header.style.cursor = 'pointer';
        header.onclick = () => sortMetricTable(elementId, metrics, metricName);
        
        // Add arrow if not exists
        if (!header.querySelector('.sort-arrow')) {
            const arrow = document.createElement('span');
            arrow.className = 'sort-arrow';
            arrow.textContent = '‚ñº'; // Default descending
            header.appendChild(arrow);
        }
    }
    
    // Initial display (sorted descending)
    const sorted = Object.entries(metrics)
        .sort((a, b) => b[1][metricName] - a[1][metricName])
        .slice(0, 10);

    div.innerHTML = sorted.map(([node, values]) => `
        <div class="metric-item">
            <span class="metric-node" title="${node}">${getNodeLabel(node)}</span>
            <span class="metric-value">${values[metricName].toFixed(3)}</span>
        </div>
    `).join('');
}

function displayTopMetricGraph(elementId, metrics, metricName) {
    const div = document.getElementById(elementId);
    if (!div) return;
    
    const sorted = Object.entries(metrics)
        .sort((a, b) => b[1][metricName] - a[1][metricName])
        .slice(0, 10);

    div.innerHTML = sorted.map(([node, values]) => `
        <div class="metric-item">
            <span class="metric-node" title="${node}">${getNodeLabel(node)}</span>
            <span class="metric-value">${values[metricName].toFixed(3)}</span>
        </div>
    `).join('');
}

// ============================================================================
// ‚≠ê‚≠ê‚≠ê PHASE 3: SORTABLE TABLE FUNCTIONS ‚≠ê‚≠ê‚≠ê
// ============================================================================

/**
 * Sort a centrality metric table
 * @param {string} elementId - ID of the div to update
 * @param {object} metrics - Centrality metrics object
 * @param {string} metricName - Name of metric (degree, betweenness, etc.)
 */
function sortMetricTable(elementId, metrics, metricName) {
    const div = document.getElementById(elementId);
    if (!div) return;
    
    // Get current sort state
    let currentSort = sortState[metricName];
    
    // Cycle through: desc ‚Üí asc ‚Üí none ‚Üí desc
    if (currentSort === 'desc') {
        currentSort = 'asc';
    } else if (currentSort === 'asc') {
        currentSort = 'none';
    } else {
        currentSort = 'desc';
    }
    
    sortState[metricName] = currentSort;
    
    // Update arrow indicator
    updateSortArrow(metricName, currentSort);
    
    // Get sorted data
    let sorted = Object.entries(metrics);
    
    if (currentSort === 'desc') {
        sorted.sort((a, b) => b[1][metricName] - a[1][metricName]);
    } else if (currentSort === 'asc') {
        sorted.sort((a, b) => a[1][metricName] - b[1][metricName]);
    }
    // If 'none', keep original order (already in metrics object)
    
    sorted = sorted.slice(0, 10); // Top 10
    
    div.innerHTML = sorted.map(([node, values]) => `
        <div class="metric-item">
            <span class="metric-node" title="${node}">${getNodeLabel(node)}</span>
            <span class="metric-value">${values[metricName].toFixed(3)}</span>
        </div>
    `).join('');
}

/**
 * Update sort arrow indicator
 */
function updateSortArrow(metricName, sortType) {
    const headers = {
        'degree': document.querySelector('#degreeCentralityGraph').previousElementSibling,
        'betweenness': document.querySelector('#betweennessCentralityGraph').previousElementSibling,
        'closeness': document.querySelector('#closenessCentralityGraph').previousElementSibling,
        'eigenvector': document.querySelector('#eigenvectorCentralityGraph').previousElementSibling
    };
    
    const header = headers[metricName];
    if (!header) return;
    
    // Remove existing arrow
    let arrow = header.querySelector('.sort-arrow');
    if (!arrow) {
        arrow = document.createElement('span');
        arrow.className = 'sort-arrow';
        header.appendChild(arrow);
    }
    
    // Set arrow text
    if (sortType === 'desc') {
        arrow.textContent = '‚ñº';
    } else if (sortType === 'asc') {
        arrow.textContent = '‚ñ≤';
    } else {
        arrow.textContent = '';
    }
}

/**
 * ‚≠ê ALIGNED: Sort community detection table (same logic as centrality)
 * @param {string} mode - 'toggle' to cycle through states
 */
/**
 * ‚≠ê ALIGNED: Sort community detection table (same logic as centrality)
 * ‚≠ê PHASE 4.3.2: Updated to use correct cluster assignments (T-network vs W-network)
 */
function sortCommunityTable(mode) {
    const dataDiv = document.getElementById('communityDetectionData');
    if (!dataDiv) return;
    
    // ‚≠ê CRITICAL FIX: Use activeNetworkType to determine correct assignments
    let activeClusterAssignments = {};
    
    if (activeNetworkType === 'W-network' && Object.keys(wordClusterAssignments).length > 0) {
        activeClusterAssignments = wordClusterAssignments;
        console.log('üìä sortCommunityTable: Using W-network cluster assignments');
    } else if (activeNetworkType === 'T-network' && Object.keys(clusterAssignments).length > 0) {
        activeClusterAssignments = clusterAssignments;
        console.log('üìä sortCommunityTable: Using T-network cluster assignments');
    } else {
        // Fallback: If activeNetworkType not set, check what's available
        if (Object.keys(clusterAssignments).length > 0) {
            activeClusterAssignments = clusterAssignments;
            console.log('üìä sortCommunityTable: Fallback to T-network (available)');
        } else if (Object.keys(wordClusterAssignments).length > 0) {
            activeClusterAssignments = wordClusterAssignments;
            console.log('üìä sortCommunityTable: Fallback to W-network (available)');
        } else {
            console.log('‚ö†Ô∏è sortCommunityTable: No cluster data available');
            return;
        }
    }
    
    // Cycle through sort states
    if (mode === 'toggle') {
        let currentSort = sortState.community;
        
        if (currentSort === 'desc') {
            currentSort = 'asc';
        } else if (currentSort === 'asc') {
            currentSort = 'none';
        } else {
            currentSort = 'desc';
        }
        
        sortState.community = currentSort;
    }
    
    updateCommunityArrow(sortState.community);
    
    let entries = Object.entries(activeClusterAssignments);
    
    if (sortState.community === 'desc') {
        entries.sort((a, b) => b[1] - a[1]);
    } else if (sortState.community === 'asc') {
        entries.sort((a, b) => a[1] - b[1]);
    }
    
    dataDiv.innerHTML = entries.map(([node, clusterId]) => `
        <div class="metric-item">
            <span class="metric-node" title="${node}">${getNodeLabel(node)}</span>
            <span class="metric-value">${clusterId}</span>
        </div>
    `).join('');
}

/**
 * ‚≠ê ALIGNED: Update community arrow (same as updateSortArrow)
 */
function updateCommunityArrow(sortType) {
    const arrow = document.getElementById('communitySortArrow');
    if (!arrow) return;
    
    // ‚≠ê ALIGNED: Same arrow logic as centrality metrics
    if (sortType === 'desc') {
        arrow.textContent = '‚ñº';
    } else if (sortType === 'asc') {
        arrow.textContent = '‚ñ≤';
    } else {
        arrow.textContent = ''; // No arrow for 'none'
    }
}

// ============================================================================



function initializeCytoscapeGraph(nodes, edges, metrics, nodeToSourceMap, nodeToClusterMap) {
    const container = document.getElementById('networkGraphCanvas');
    
    // ‚≠ê FIX: Destroy BOTH instances to avoid conflicts
    if (cyInstance) {
        cyInstance.destroy();
        cyInstance = null;
    }
    
    // ‚≠ê CRITICAL: Also destroy word instance when creating T-network
    if (wordCyInstance) {
        wordCyInstance.destroy();
        wordCyInstance = null;
    }
    
    // Ensure container has dimensions
    if (container.offsetHeight === 0) {
        container.style.minHeight = '400px';
    }

    // Calculate node sizes based on SELECTED metric
    const sizeMetric = nodeVisualizationSettings.size;
    const metricValues = Object.values(metrics).map(m => m[sizeMetric]);
    const maxMetricValue = Math.max(...metricValues, 0.0001);
    
    console.log(`üìä Node sizing using: ${sizeMetric}, max value: ${maxMetricValue.toFixed(4)}`);
    
    // ============================================================================
    // ‚≠ê‚≠ê‚≠ê PHASE 3: DYNAMIC NODE COLORING (Source OR Cluster) ‚≠ê‚≠ê‚≠ê
    // ============================================================================
    const colorSetting = nodeVisualizationSettings.color;
    console.log(`üé® Phase 3: Node coloring mode: ${colorSetting}`);
    
    const elements = [
        ...nodes.map(node => {
            let nodeColor = '#3498db'; // Default blue
            
            // ‚≠ê Apply coloring based on setting
            if (colorSetting === 'source') {
                nodeColor = getNodeColorBySource(node.data.id, nodeToSourceMap);
                console.log(`üé® Node "${getNodeLabel(node.data.id)}" ‚Üí Source Color: ${nodeColor}`);
            } else if (colorSetting === 'cluster-lpa' || colorSetting === 'cluster-louvain') {
                nodeColor = getNodeColorByCluster(node.data.id, nodeToClusterMap);
                const clusterId = nodeToClusterMap[node.data.id];
                const algorithm = colorSetting === 'cluster-lpa' ? 'LPA' : 'Louvain';
                console.log(`üé® Node "${getNodeLabel(node.data.id)}" ‚Üí ${algorithm} Cluster ${clusterId} Color: ${nodeColor}`);
            }
            
            return {
                ...node,
                data: {
                    ...node.data,
                    size: 20 + (metrics[node.data.id][sizeMetric] / maxMetricValue) * 40,
                    color: nodeColor // ‚≠ê Store color in node data
                }
            };
        }),
        ...edges
    ];
    // ============================================================================

    cyInstance = cytoscape({
        container: container,
        elements: elements,
        style: [
            {
                selector: 'node',
                style: {
                    // ‚≠ê Use dynamic color from node data
                    'background-color': 'data(color)',
                    'label': 'data(label)',
                    'width': 'data(size)',
                    'height': 'data(size)',
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '12px',
                    'color': '#2c3e50',
                    'text-outline-width': 2,
                    'text-outline-color': '#fff',
                    'border-width': 2,
                    'border-color': '#2c3e50'
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': 2,
                    'line-color': '#95a5a6',
                    'target-arrow-color': '#95a5a6',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier',
                    'label': 'data(label)',
                    'font-size': '10px',
                    'text-rotation': 'autorotate',
                    'text-margin-y': -10,
                    'color': '#34495e',
                    'text-background-color': '#fff',
                    'text-background-opacity': 0.8,
                    'text-background-padding': '3px'
                }
            }
        ],
        layout: {
            name: 'cose',
            idealEdgeLength: 100,
            nodeOverlap: 20,
            refresh: 20,
            fit: true,
            padding: 30,
            randomize: false,
            componentSpacing: 100,
            nodeRepulsion: 400000,
            edgeElasticity: 100,
            nestingFactor: 5,
            gravity: 80,
            numIter: 1000,
            initialTemp: 200,
            coolingFactor: 0.95,
            minTemp: 1.0
        }
    });

    // Force resize after layout completes
    cyInstance.on('layoutstop', function() {
        cyInstance.resize();
        cyInstance.fit();
    });

    // Add interactivity
    cyInstance.on('tap', 'node', function(evt) {
        const node = evt.target;
        const nodeId = node.id();
        const nodeMetrics = metrics[nodeId];
        
        // ‚≠ê Show cluster info if cluster coloring is enabled
        let clusterInfo = '';
        if ((colorSetting === 'cluster-lpa' || colorSetting === 'cluster-louvain') && nodeToClusterMap[nodeId]) {
            const algorithm = colorSetting === 'cluster-lpa' ? 'LPA' : 'Louvain';
            clusterInfo = `Cluster (${algorithm}): ${nodeToClusterMap[nodeId]}\n\n`;
        }
        
        alert(`Node: ${nodeId}\n\n` +
              clusterInfo +
              `Degree: ${nodeMetrics.degree.toFixed(3)}\n` +
              `Betweenness: ${nodeMetrics.betweenness.toFixed(3)}\n` +
              `Closeness: ${nodeMetrics.closeness.toFixed(3)}\n` +
              `Eigenvector: ${nodeMetrics.eigenvector.toFixed(3)}`);
    });
}

        // The rest of your existing code continues here...
        // (All the functions from the original code)

function getTextTabDisplayNumber(pageId) {
            return pageId;
        }

        function getCanvasTabDisplayNumber(canvasId) {
            return canvasId;
        }

        function updateTextTabLabels() {
            textPages.forEach(page => {
                const tab = document.querySelector(`[data-page-type="text"][data-page-id="${page.id}"]`);
                if (tab) {
                    const closeBtn = tab.querySelector('.close-btn');
                    const closeBtnHTML = closeBtn ? closeBtn.outerHTML : '';
                    tab.innerHTML = `Text ${page.id}${closeBtnHTML}`;
                }
            });
        }

        function updateCanvasTabLabels() {
            const canvasList = canvasPages.filter(c => typeof c.id === 'number');
            
            canvasList.forEach(canvas => {
                const tab = document.querySelector(`.tab[data-tab="${canvas.id}"]:not(.help-tab):not(.settings-tab)`);
                if (tab) {
                    const closeBtn = tab.querySelector('.close-btn');
                    const closeBtnHTML = closeBtn ? closeBtn.outerHTML : '';
                    tab.innerHTML = `Canvas ${canvas.id}${closeBtnHTML}`;
                }
            });
        }

        function selectCustomRelation() {
            const customLabel = document.getElementById('customLabelInput').value.trim() || 'connection';
            selectRelation('custom', customLabel);
        }

        document.addEventListener('DOMContentLoaded', function() {
            const customInput = document.getElementById('customLabelInput');
            if (customInput) {
                customInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        selectCustomRelation();
                    }
                });
            }
        });

        let isResizing = false;
        let lastDownX = 0;

        const resizer = document.getElementById('resizer');
        const leftPanel = document.getElementById('leftPanel');
        const container = document.querySelector('.container');

        resizer.addEventListener('mousedown', function(e) {
            if (isPanelCollapsed) return;
            
            isResizing = true;
            lastDownX = e.clientX;
            resizer.classList.add('resizing');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            
            e.preventDefault();
        });

        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerWidth = container.offsetWidth;
            const newWidth = e.clientX;
            
            const minWidth = 200;
            const maxWidth = containerWidth * 0.8;
            
            if (newWidth >= minWidth && newWidth <= maxWidth) {
                leftPanel.style.width = newWidth + 'px';
                updateConnectionsOnly();
            }
        });

        document.addEventListener('mouseup', function(e) {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        function switchUnifiedTab(pageType, pageId) {
    // No need to hide network analysis - it's now in Graph tab

            if (currentLeftPageType === 'text') {
                const currentTextArea = getCurrentTextArea();
                if (currentTextArea) {
                    const currentPage = getCurrentTextPage();
                    if (currentPage) {
                        currentPage.content = currentTextArea.innerHTML;
                    }
                }
            }
            
            currentLeftPageType = pageType;
            if (pageType === 'text') {
                currentTextPageId = pageId;
            }
            
            const tabs = document.querySelectorAll('.unified-tab');
            tabs.forEach(tab => {
                const tabPageType = tab.getAttribute('data-page-type');
                const tabPageId = tab.getAttribute('data-page-id');
                
                if (tabPageType === pageType) {
                    if (pageType === 'text') {
                        if (parseInt(tabPageId) === pageId) {
                            tab.classList.add('active');
                        } else {
                            tab.classList.remove('active');
                        }
                    } else {
                        tab.classList.add('active');
                    }
                } else {
                    tab.classList.remove('active');
                }
            });
            
            const pages = document.querySelectorAll('.left-page');
            pages.forEach(page => {
                page.classList.remove('active');
            });
            
            if (pageType === 'text') {
                const textPage = document.getElementById('leftpage-text');
                if (textPage) {
                    textPage.classList.add('active');
                }
                
                const textPageDivs = document.querySelectorAll('.text-page');
                textPageDivs.forEach(div => {
                    div.classList.remove('active');
                });
                
                const activeTextPage = document.getElementById('textpage-' + pageId);
                if (activeTextPage) {
                    activeTextPage.classList.add('active');
                    
                    const textArea = activeTextPage.querySelector('.text-area');
                    const textPageData = getCurrentTextPage();
                    if (textArea && textPageData) {
                        textArea.innerHTML = textPageData.content;
                    }
                }
            } else {
                const page = document.getElementById('leftpage-' + pageType);
                if (page) {
                    page.classList.add('active');
                }
            }
            
            handleTextSelection();
        }
        
        function getCurrentTextPage() {
            return textPages.find(tp => tp.id === currentTextPageId);
        }

        function getCurrentTextArea() {
            const textPage = document.getElementById('textpage-' + currentTextPageId);
            if (textPage) {
                return textPage.querySelector('.text-area');
            }
            return null;
        }

        function createNewTextTab() {
            const newId = textPageIdCounter++;
            const newTextPage = {
                id: newId,
                content: ''
            };
            
            textPages.push(newTextPage);
            
            const textPagesContainer = document.getElementById('textPagesContainer');
            const textPageDiv = document.createElement('div');
            textPageDiv.className = 'text-page';
            textPageDiv.id = 'textpage-' + newId;
            textPageDiv.innerHTML = '<div class="text-area" contenteditable="true"></div>';
            textPagesContainer.appendChild(textPageDiv);
            
            const newTextArea = textPageDiv.querySelector('.text-area');
            setupTextAreaListeners(newTextArea);
            
            const unifiedTabContainer = document.getElementById('unifiedTabContainer');
            const newTabBtn = unifiedTabContainer.querySelector('.new-text-tab-btn');
            
            const tab = document.createElement('button');
            tab.className = 'unified-tab text-tab';
            tab.setAttribute('data-page-type', 'text');
            tab.setAttribute('data-page-id', newId);
            tab.onclick = () => switchUnifiedTab('text', newId);
            
            tab.innerHTML = `Text ${newId}<span class="close-btn" onclick="event.stopPropagation(); closeTextTab(event, ${newId})">√ó</span>`;
            
            unifiedTabContainer.insertBefore(tab, newTabBtn);
            
            switchUnifiedTab('text', newId);
            
            tab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
        }

        function closeTextTab(event, tabId) {
            event.stopPropagation();
            
            if (textPages.length <= 1) {
                alert('You must keep at least one text tab.');
                return;
            }
            
            if (confirm('Are you sure you want to close this text tab? All content will be lost.')) {
                const index = textPages.findIndex(tp => tp.id === tabId);
                if (index > -1) {
                    textPages.splice(index, 1);
                }
                
                const textPage = document.getElementById('textpage-' + tabId);
                if (textPage) {
                    textPage.remove();
                }
                
                const tab = document.querySelector(`[data-page-type="text"][data-page-id="${tabId}"]`);
                if (tab) {
                    tab.remove();
                }
                
                if (currentTextPageId === tabId) {
                    switchUnifiedTab('text', textPages[0].id);
                }
            }
        }

function createColorPalette(textboxId, currentColor, canvasId = null) {
    const colors = highlightColors;
    // ‚≠ê FIX: Use explicit canvasId parameter, fallback to currentCanvasId
    const effectiveCanvasId = canvasId !== null ? canvasId : currentCanvasId;
    const paletteId = `palette-${effectiveCanvasId}-${textboxId}`;
    
    const colorOptions = colors.map((color, index) => {
        const isSelected = color === currentColor;
        return `<div class="color-option ${isSelected ? 'selected' : ''}" 
                     style="background-color: ${color};" 
                     data-color="${color}"
                     onclick="selectHighlightColor(${textboxId}, '${color}')"></div>`;
    }).join('');
    
    return `<div class="color-palette" id="${paletteId}">
                <div class="color-palette-close" onclick="event.stopPropagation(); closeColorPalette(${textboxId})" title="Close">√ó</div>
                ${colorOptions}
                <div class="color-option" 
                     style="background: repeating-linear-gradient(45deg, #ddd, #ddd 2px, white 2px, white 4px); border: 2px solid #e74c3c;" 
                     onclick="event.stopPropagation(); removeHighlight(${textboxId})"
                     title="Remove highlight">‚úñ</div>
            </div>`;
}

function toggleColorPalette(textboxId) {
    const paletteId = `palette-${currentCanvasId}-${textboxId}`; // ‚≠ê FIX
    
    // Close all other palettes first
    document.querySelectorAll('.color-palette').forEach(palette => {
        if (palette.id !== paletteId) {
            palette.classList.remove('show');
        }
    });
    
    const palette = document.getElementById(paletteId);
    if (palette) {
        palette.classList.toggle('show');
    }
}

// ‚≠ê NEW: Close palette function
function closeColorPalette(textboxId) {
    const paletteId = `palette-${currentCanvasId}-${textboxId}`; // ‚≠ê FIX
    const palette = document.getElementById(paletteId);
    if (palette) {
        palette.classList.remove('show');
    }
}

// ‚≠ê NEW: Remove highlight function
// ‚≠ê FIXED: Enhanced removeHighlight function
function removeHighlight(textboxId) {
    const canvas = getCurrentCanvas();
    const textbox = canvas.textboxes.find(tb => tb.id === textboxId);
    if (!textbox) return;
    
    // Remove highlight state
    textbox.isHighlighted = false;
    
    const element = textbox.element;
    const highlightBtn = element.querySelector('.icon-btn.highlight');
    
    // Remove visual highlighting
    element.classList.remove('highlighted');
    element.style.backgroundColor = 'white';
    
    if (highlightBtn) {
        highlightBtn.classList.remove('active');
    }
    
    // Close the palette
    closeColorPalette(textboxId);
    
    console.log(`‚úÖ Removed highlight from textbox ${textboxId}`);
}

function selectHighlightColor(textboxId, color) {
    const canvas = getCurrentCanvas();
    const textbox = canvas.textboxes.find(tb => tb.id === textboxId);
    if (!textbox) return;
    
    // Set the new color
    textbox.highlightColor = color;
    
    // ‚≠ê IMPORTANT: Ensure highlight is activated
    if (!textbox.isHighlighted) {
        textbox.isHighlighted = true;
        const highlightBtn = textbox.element.querySelector('.icon-btn.highlight');
        if (highlightBtn) {
            highlightBtn.classList.add('active');
        }
    }
    
    // Apply the color
    textbox.element.classList.add('highlighted');
    textbox.element.style.backgroundColor = color;
    
    // Update palette visual feedback
    const paletteId = `palette-${currentCanvasId}-${textboxId}`; // ‚≠ê FIX
    const palette = document.getElementById(paletteId);
    if (palette) {
        palette.querySelectorAll('.color-option').forEach(option => {
            if (option.getAttribute('data-color') === color) {
                option.classList.add('selected');
            } else {
                option.classList.remove('selected');
            }
        });
        
        // Close palette after selection
        palette.classList.remove('show');
    }
    
    console.log(`‚úÖ Applied color ${color} to textbox ${textboxId} in canvas ${currentCanvasId}`);
}

        window.toggleHighlightButton = function(id, event) {
    const canvas = getCurrentCanvas();
    const textbox = canvas.textboxes.find(tb => tb.id === id);
    if (!textbox) return;
    
    // ‚≠ê NEW: Right-click = toggle highlight on/off
    if (event && event.button === 2) {
        event.preventDefault();
        
        if (textbox.isHighlighted) {
            // Remove highlight
            removeHighlight(id);
        } else {
            // Add highlight with default color
            textbox.isHighlighted = true;
            const element = textbox.element;
            const highlightBtn = element.querySelector('.icon-btn.highlight');
            
            element.classList.add('highlighted');
            const color = textbox.highlightColor || defaultHighlightColor;
            element.style.backgroundColor = color;
            highlightBtn.classList.add('active');
            
            console.log(`‚úÖ Added highlight to textbox ${id}`);
        }
        return;
    }
    
    // ‚≠ê Left-click = open color palette (existing behavior)
    if (!textbox.isHighlighted) {
        // Auto-highlight with default color before showing palette
        textbox.isHighlighted = true;
        const element = textbox.element;
        const highlightBtn = element.querySelector('.icon-btn.highlight');
        
        element.classList.add('highlighted');
        const color = textbox.highlightColor || defaultHighlightColor;
        element.style.backgroundColor = color;
        highlightBtn.classList.add('active');
    }
    
    toggleColorPalette(id);
}

        document.addEventListener('click', function(e) {
            if (!e.target.closest('.color-palette') && !e.target.closest('.icon-btn.highlight')) {
                document.querySelectorAll('.color-palette').forEach(palette => {
                    palette.classList.remove('show');
                });
            }
        });

        // Continue with all remaining functions from your original code...
        // (saveProject, loadProject, refreshMainIdea, refreshEdgelist, etc.)
        // I'll include the key modified functions:

function refreshEdgelist() {
    const display = document.getElementById('edgelistDisplay');
    const allConnections = [];
    
    canvasPages.forEach(canvas => {
        if (typeof canvas.id === 'number') {
            canvas.connections.forEach(conn => {
                const fromBox = canvas.textboxes.find(tb => tb.id === conn.from);
                const toBox = canvas.textboxes.find(tb => tb.id === conn.to);
                
                // Skip connections where either textbox is greyed out
                if (fromBox && toBox && !fromBox.isGreyed && !toBox.isGreyed) {
                    const tempDiv1 = document.createElement('div');
                    tempDiv1.innerHTML = fromBox.text;
                    const fromText = tempDiv1.textContent || tempDiv1.innerText || '';
                    
                    const tempDiv2 = document.createElement('div');
                    tempDiv2.innerHTML = toBox.text;
                    const toText = tempDiv2.textContent || tempDiv2.innerText || '';
                    
                    let sourceText, targetText, fromSourceId, toSourceId;
                    
                    if (['sequence', 'cause', 'solution', 'contrast', 'description', 'source', 'custom'].includes(conn.relation)) {
                        if (conn.reversed) {
                            sourceText = toText;
                            targetText = fromText;
                            fromSourceId = toBox.sourceTextId;
                            toSourceId = fromBox.sourceTextId;
                        } else {
                            sourceText = fromText;
                            targetText = toText;
                            fromSourceId = fromBox.sourceTextId;
                            toSourceId = toBox.sourceTextId;
                        }
                    } else {
                        sourceText = fromText;
                        targetText = toText;
                        fromSourceId = fromBox.sourceTextId;
                        toSourceId = toBox.sourceTextId;
                    }
                    
                    const displayLabel = conn.relation === 'custom' ? conn.customLabel : conn.relation;
                    
                    // ‚≠ê‚≠ê‚≠ê PHASE 3: GET CLUSTER LABELS ‚≠ê‚≠ê‚≠ê
                    let fromCluster = '';
                    let toCluster = '';
                    
                    // Only add cluster labels if clustering is enabled
                    if (nodeVisualizationSettings.color === 'cluster-lpa' || 
                        nodeVisualizationSettings.color === 'cluster-louvain') {
                        fromCluster = clusterAssignments[sourceText] || '';
                        toCluster = clusterAssignments[targetText] || '';
                    }
                    // ============================================================================
                    
                    const fromSourceNum = fromSourceId !== null && fromSourceId !== undefined ? fromSourceId : '';
                    const toSourceNum = toSourceId !== null && toSourceId !== undefined ? toSourceId : '';
                    
                    allConnections.push({
                        source: sourceText,
                        target: targetText,
                        relation: displayLabel,
                        fromSourceId: fromSourceNum,
                        toSourceId: toSourceNum,
                        fromCluster: fromCluster,  // ‚≠ê NEW
                        toCluster: toCluster       // ‚≠ê NEW
                    });
                }
            });
        }
    });
    
    if (allConnections.length === 0) {
        display.innerHTML = '<span style="color: #999;">No connections found. Create connections between textboxes to build an edgelist.</span>';
        return;
    }
    
    display.innerHTML = '';
    allConnections.forEach(conn => {
        const line = document.createElement('div');
        line.className = 'data-line';
        // ‚≠ê‚≠ê‚≠ê PHASE 3: APPEND CLUSTER COLUMNS ‚≠ê‚≠ê‚≠ê
        line.textContent = `"${conn.source}", "${conn.target}", ${conn.relation}, ${conn.fromSourceId}, ${conn.toSourceId}, ${conn.fromCluster}, ${conn.toCluster}`;
        display.appendChild(line);
    });
}

// Due to length constraints, I'm providing key sections. The rest of your code
// (saveProject, loadProject, all canvas/textbox functions, etc.) remains exactly the same.
// Simply add all your existing functions after the network analysis functions.

// Include all remaining functions from your original code here:
// - saveProject()
// - loadProject()
// - refreshMainIdea()
// - copyMainIdea()
// - copyEdgelist()
// - downloadEdgelist()
// - togglePanel()
// - updateFontSize()
// - etc.

// For brevity, I'll show the structure - you keep all your existing functions

// Node visualization setting update functions
// ===== PHASE 1: ENHANCED SETTING UPDATES =====
function updateNodeSizeSetting(value) {
    nodeVisualizationSettings.size = value;
    
    const metricNames = {
        'degree': 'Degree Centrality',
        'betweenness': 'Betweenness Centrality',
        'closeness': 'Closeness Centrality',
        'eigenvector': 'Eigenvector Centrality'
    };
    
    console.log(`‚úÖ Node size metric changed to: ${metricNames[value]}`);
    showSuccessMessage(`Node size set to ${metricNames[value]}. Click "üìä Network Analysis" to replot the graph.`);
}

function updateNodeColorSetting(value) {
    nodeVisualizationSettings.color = value;
    console.log('‚úÖ Node color setting updated to:', value);
    
    if (value === 'source') {
        showSuccessMessage('üé® Source text coloring enabled! Click "üìä Network Analysis" to replot with colors.');
    } else if (value === 'none') {
        showSuccessMessage('Nodes will use default blue color. Click "üìä Network Analysis" to replot.');
    } else if (value === 'cluster-lpa') {
        showSuccessMessage('üé® LPA clustering enabled! Click "üìä Network Analysis" to detect communities (fast, randomized).');
    } else if (value === 'cluster-louvain') {
        showSuccessMessage('üé® Louvain clustering enabled! Click "üìä Network Analysis" to detect communities (stable, optimal).');
    }
}

function updateNodeShapeSetting(value) {
    nodeVisualizationSettings.shape = value;
    console.log('Node shape setting updated to:', value);
    
    if (value === 'source' || value === 'cluster') {
        showSuccessMessage('Node shape variation. Feature coming soon!');
    }
}




function saveProject() {
    // Your existing saveProject code remains the same
    try {
        if (currentLeftPageType === 'text') {
            const currentTextArea = getCurrentTextArea();
            if (currentTextArea) {
                const currentPage = getCurrentTextPage();
                if (currentPage) {
                    currentPage.content = currentTextArea.innerHTML;
                }
            }
        }
        
        const textPagesData = textPages.map(tp => ({
            id: tp.id,
            content: tp.content
        }));
        
        const canvasData = canvasPages.filter(c => typeof c.id === 'number').map(canvas => ({
            id: canvas.id,
            textboxIdCounter: canvas.textboxIdCounter,
            textboxes: canvas.textboxes.map(tb => ({
                id: tb.id,
                text: tb.text,
                x: tb.x,
                y: tb.y,
                width: tb.width,
                height: tb.height,
                isGreyed: tb.isGreyed,
                isHighlighted: tb.isHighlighted,
                highlightColor: tb.highlightColor,
                isInferred: tb.isInferred,
                sourceTextId: tb.sourceTextId
            })),
            connections: canvas.connections.map(conn => ({
                from: conn.from,
                to: conn.to,
                relation: conn.relation,
                reversed: conn.reversed,
                customLabel: conn.customLabel
            }))
        }));
      
		// In saveProject(), ADD this line before creating saveData:
		const canvasZoomData = {};
		Object.keys(canvasZoomLevels).forEach(canvasId => {
			canvasZoomData[canvasId] = canvasZoomLevels[canvasId];
		});
		
		// ‚≠ê‚≠ê‚≠ê PHASE 4.2: Save doc2term settings & nodelist ‚≠ê‚≠ê‚≠ê
		const doc2termData = {
			settings: {
				method: doc2termSettings.method,
				boundarySymbols: doc2termSettings.boundarySymbols,
				windowSize: doc2termSettings.windowSize,
				windowStep: doc2termSettings.windowStep
			},
			nodelist: nodelistData
		};
		// ============================================================================

		// Then ADD to saveData object:
		const saveData = {
			version: '97.0', //  Update version
			timestamp: new Date().toISOString(),
			textPages: textPagesData,
			textPageIdCounter: textPageIdCounter,
			currentTextPageId: currentTextPageId,
			currentFontSize: currentFontSize,
			canvasPages: canvasData,
			canvasIdCounter: canvasIdCounter,
			currentCanvasId: currentCanvasId,
			mainIdeaOrder: mainIdeaOrder,
			leftPanelWidth: leftPanel.offsetWidth,
			exportSVGEnabled: exportSVGEnabled,
			nodeVisualizationSettings: nodeVisualizationSettings,
			canvasZoomLevels: canvasZoomData, //  ADD THIS for zoom feature
			tokenizationSettings: tokenizationSettings,
			stopwordsSettings: {  
				mode: stopwordsSettings.mode,
				customStopwords: Array.from(stopwordsSettings.customStopwords)
			},
			canvasZoomLevels: canvasZoomData,
			doc2termData: doc2termData,
			wNetworkViewMode: wNetworkViewMode,             // phase 4.3.1
			wordEdgelistData: wordEdgelistData,             // phase 4.3.1
			wordNetworkMetrics: wordNetworkMetrics,         // phase 4.3.2
			wordClusterAssignments: wordClusterAssignments,  // phase 4.3.2
			activeNetworkType: activeNetworkType 			// Track active network
 		};
        
        const jsonString = JSON.stringify(saveData, null, 2);
        
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        link.download = `text-structurer-project-${timestamp}.json`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
        
        showSuccessMessage('Project saved successfully!');
			} catch (error) {
				console.error('Error saving project:', error);
				alert('Failed to save project. Please try again.');
			}
	}

// Continue with all your remaining functions...
// Include EVERYTHING from your original code after this point

        
function loadProject(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const saveData = JSON.parse(e.target.result);
            
            if (!saveData.version || !saveData.canvasPages) {
                alert('Invalid project file format.');
                return;
            }
            
            if (!confirm('Loading this project will replace all current work. Continue?')) {
                event.target.value = '';
                return;
            }
            
            let needsMigration = false;
            if (saveData.textPages && saveData.textPages.some(tp => tp.id === 0)) {
                needsMigration = true;
                console.log('Migrating old project file: IDs 0‚Üí1');
            }
            
            textPages = [];
            const unifiedTabContainer = document.getElementById('unifiedTabContainer');
            const textPagesContainer = document.getElementById('textPagesContainer');
            
            document.querySelectorAll('.unified-tab.text-tab').forEach(tab => tab.remove());
            document.querySelectorAll('.text-page').forEach(page => page.remove());
            
            if (needsMigration) {
                textPageIdCounter = (saveData.textPageIdCounter || 1) + 1;
                currentTextPageId = (saveData.currentTextPageId || 0) + 1;
            } else {
                textPageIdCounter = saveData.textPageIdCounter || 2;
                currentTextPageId = saveData.currentTextPageId || 1;
            }
            
            const textPagesData = saveData.textPages || [{ id: needsMigration ? 1 : 1, content: saveData.textContent || '' }];
            
            textPagesData.forEach(tpData => {
                const textPageId = needsMigration ? tpData.id + 1 : tpData.id;
                
                const textPage = {
                    id: textPageId,
                    content: tpData.content || ''
                };
                
                textPages.push(textPage);
                
                const textPageDiv = document.createElement('div');
                textPageDiv.className = 'text-page';
                textPageDiv.id = 'textpage-' + textPageId;
                textPageDiv.innerHTML = '<div class="text-area" contenteditable="true"></div>';
                textPagesContainer.appendChild(textPageDiv);
                
                const textArea = textPageDiv.querySelector('.text-area');
                textArea.innerHTML = textPage.content;
                setupTextAreaListeners(textArea);
                
                const tab = document.createElement('button');
                tab.className = 'unified-tab text-tab';
                tab.setAttribute('data-page-type', 'text');
                tab.setAttribute('data-page-id', textPageId);
                tab.onclick = () => switchUnifiedTab('text', textPageId);
                
                tab.innerHTML = `Text ${textPageId}<span class="close-btn" onclick="event.stopPropagation(); closeTextTab(event, ${textPageId})">√ó</span>`;
                
                const newTabBtn = unifiedTabContainer.querySelector('.new-text-tab-btn');
                unifiedTabContainer.insertBefore(tab, newTabBtn);
            });
            
            currentFontSize = saveData.currentFontSize || 16;
            updateFontSize();
            
            if (saveData.leftPanelWidth) {
                leftPanel.style.width = saveData.leftPanelWidth + 'px';
            }
            
            exportSVGEnabled = saveData.exportSVGEnabled || false;
            const exportToggle = document.getElementById('exportSVGToggle');
            const exportBtn = document.getElementById('exportSVGBtn');
            if (exportToggle) {
                exportToggle.checked = exportSVGEnabled;
            }
            if (exportBtn) {
                exportBtn.style.display = exportSVGEnabled ? 'inline-block' : 'none';
            }
            
            // Restore node visualization settings
            if (saveData.nodeVisualizationSettings) {
                nodeVisualizationSettings = saveData.nodeVisualizationSettings;
                
                const sizeRadio = document.querySelector(`input[name="nodeSize"][value="${nodeVisualizationSettings.size}"]`);
                if (sizeRadio) sizeRadio.checked = true;
                
                const colorRadio = document.querySelector(`input[name="nodeColor"][value="${nodeVisualizationSettings.color}"]`);
                if (colorRadio) colorRadio.checked = true;
                
                const shapeRadio = document.querySelector(`input[name="nodeShape"][value="${nodeVisualizationSettings.shape}"]`);
                if (shapeRadio) shapeRadio.checked = true;
            }
			
			// ‚≠ê‚≠ê‚≠ê PHASE 4.1: Restore tokenization settings ‚≠ê‚≠ê‚≠ê
			if (saveData.tokenizationSettings) {
				tokenizationSettings = saveData.tokenizationSettings;
    
				// Restore radio button state
				const methodRadio = document.querySelector(`input[name="tokenizationMethod"][value="${tokenizationSettings.method}"]`);
				if (methodRadio) methodRadio.checked = true;
    
				// Restore separator input
				const separatorInput = document.getElementById('tokenSeparatorInput');
				if (separatorInput) {
					separatorInput.value = tokenizationSettings.separator;
					updateTokenSeparator(); // Update preview
				}
    
				console.log('‚úÖ Restored tokenization settings:', tokenizationSettings);
			}
			// ============================================================================

			// In loadProject(), after restoring tokenization settings:
			// ‚≠ê‚≠ê‚≠ê Restore stopwords settings ‚≠ê‚≠ê‚≠ê
			if (saveData.stopwordsSettings) {
				stopwordsSettings.mode = saveData.stopwordsSettings.mode || 'default';
				stopwordsSettings.customStopwords = new Set(saveData.stopwordsSettings.customStopwords || []);
    
				// Restore radio button
				const modeRadio = document.querySelector(`input[name="stopwordsMode"][value="${stopwordsSettings.mode}"]`);
				if (modeRadio) modeRadio.checked = true;
    
				// Restore textarea
				if (stopwordsSettings.customStopwords.size > 0) {
					document.getElementById('customStopwordsInput').value = 
						Array.from(stopwordsSettings.customStopwords).join('\n');
				}
    
				console.log('‚úÖ Restored stopwords settings:', stopwordsSettings);
			}
            
			// ‚≠ê‚≠ê‚≠ê PHASE 4.2: Restore doc2term settings & nodelist ‚≠ê‚≠ê‚≠ê
			if (saveData.doc2termData) {
				if (saveData.doc2termData.settings) {
					doc2termSettings = saveData.doc2termData.settings;
        
					// Restore method radio button
					const methodRadio = document.querySelector(`input[name="segmentationMethod"][value="${doc2termSettings.method}"]`);
					if (methodRadio) {
						methodRadio.checked = true;
						updateSegmentationMethod(doc2termSettings.method); // Update visibility
					}
        
					// Restore symbol textarea
					const symbolTextarea = document.getElementById('boundarySymbolsInput');
					if (symbolTextarea) {
						symbolTextarea.value = doc2termSettings.boundarySymbols.join('\n');
					}
        
					// Restore window inputs
					const sizeInput = document.getElementById('windowSizeInput');
					const stepInput = document.getElementById('windowStepInput');
					if (sizeInput) sizeInput.value = doc2termSettings.windowSize;
					if (stepInput) stepInput.value = doc2termSettings.windowStep;
        
					console.log('‚úÖ Restored doc2term settings:', doc2termSettings);
				}
    
				// Restore nodelist data
				if (saveData.doc2termData.nodelist) {
					nodelistData = saveData.doc2termData.nodelist;
					displayNodelist();
					console.log(`‚úÖ Restored ${nodelistData.length} nodelist segments`);
				}
			}
			// ============================================================================
			
			// ‚≠ê‚≠ê‚≠ê PHASE 4.3.1: Restore W-Network view mode and edgelist ‚≠ê‚≠ê‚≠ê
			if (saveData.wNetworkViewMode) {
				wNetworkViewMode = saveData.wNetworkViewMode;
				console.log(`‚úÖ Restored W-Network view mode: ${wNetworkViewMode}`);
    
				// Show/hide toggle button based on mode
				const toggleBtn = document.getElementById('backToNodelistBtn');
				if (wNetworkViewMode === '1mode') {
					toggleBtn.style.display = 'inline-block';
				} else {
					toggleBtn.style.display = 'none';
				}
			}

			if (saveData.wordEdgelistData) {
				wordEdgelistData = saveData.wordEdgelistData;
				console.log(`‚úÖ Restored ${wordEdgelistData.length} word edges`);
    
				// Restore display if in 1-mode view
				if (wNetworkViewMode === '1mode') {
					displayWordEdgelist();
				}
			}
			// ============================================================================	

			// ‚≠ê‚≠ê‚≠ê PHASE 4.3.2: Restore word network metrics and clusters ‚≠ê‚≠ê‚≠ê
			if (saveData.wordNetworkMetrics) {
				wordNetworkMetrics = saveData.wordNetworkMetrics;
				console.log(`‚úÖ Restored word network metrics for ${Object.keys(wordNetworkMetrics).length} words`);
			}

			if (saveData.wordClusterAssignments) {
				wordClusterAssignments = saveData.wordClusterAssignments;
				console.log(`‚úÖ Restored word cluster assignments: ${Object.keys(wordClusterAssignments).length} words`);
			}
			// ============================================================================
			
			// ‚≠ê‚≠ê‚≠ê PHASE 4.3.2: Restore word network metrics and clusters ‚≠ê‚≠ê‚≠ê
			if (saveData.wordNetworkMetrics) {
				wordNetworkMetrics = saveData.wordNetworkMetrics;
				console.log(`‚úÖ Restored word network metrics for ${Object.keys(wordNetworkMetrics).length} words`);
			}

			if (saveData.wordClusterAssignments) {
				wordClusterAssignments = saveData.wordClusterAssignments;
				console.log(`‚úÖ Restored word cluster assignments: ${Object.keys(wordClusterAssignments).length} words`);
			}

			// ‚≠ê NEW: Restore active network type
			if (saveData.activeNetworkType) {
				activeNetworkType = saveData.activeNetworkType;
				console.log(`‚úÖ Restored active network type: ${activeNetworkType}`);
			}
			
            // ‚≠ê Restore canvas zoom levels
            if (saveData.canvasZoomLevels) {
                canvasZoomLevels = saveData.canvasZoomLevels;
                console.log('‚úÖ Restored zoom levels:', canvasZoomLevels);
            } else {
                canvasZoomLevels = {};
            }
            
            canvasPages = [];
            const tabContainer = document.getElementById('tabContainer');
            const canvasContent = document.getElementById('canvasContent');
            
            document.querySelectorAll('.tab:not(.help-tab):not(.settings-tab):not(.new-tab-btn)').forEach(tab => tab.remove());
            document.querySelectorAll('.canvas-page:not(#canvas-graph):not(#canvas-help):not(#canvas-settings)').forEach(page => page.remove());
            
            let canvasNeedsMigration = saveData.canvasPages && saveData.canvasPages.some(c => c.id === 0);
            
            if (canvasNeedsMigration) {
                canvasIdCounter = (saveData.canvasIdCounter || 1) + 1;
                currentCanvasId = (saveData.currentCanvasId || 0) + 1;
            } else {
                canvasIdCounter = saveData.canvasIdCounter || 2;
                currentCanvasId = saveData.currentCanvasId || 1;
            }
            
            mainIdeaOrder = saveData.mainIdeaOrder || [];
            
            // Create canvases and textboxes
            saveData.canvasPages.forEach(canvasData => {
                const canvasId = canvasNeedsMigration ? canvasData.id + 1 : canvasData.id;
                
                const canvas = {
                    id: canvasId,
                    textboxes: [],
                    connections: canvasData.connections.map(conn => ({
                        from: conn.from,
                        to: conn.to,
                        relation: conn.relation,
                        reversed: conn.reversed || false,
                        customLabel: conn.customLabel || 'connection'
                    })),
                    textboxIdCounter: canvasData.textboxIdCounter || 0
                };
                
                canvasPages.push(canvas);
                
                // Create canvas page
                const canvasPage = document.createElement('div');
                canvasPage.className = 'canvas-page';
                canvasPage.id = 'canvas-' + canvasId;
                canvasPage.innerHTML = '<div class="canvas-inner"><svg class="connections-svg"></svg></div>';
                
                // Insert canvas page into DOM
                const graphPage = document.getElementById('canvas-graph');
                if (graphPage && graphPage.parentNode) {
                    graphPage.parentNode.insertBefore(canvasPage, graphPage);
                }
                
                // Create canvas tab
                const tab = document.createElement('button');
                tab.className = 'tab';
                tab.setAttribute('data-tab', canvasId);
                tab.onclick = () => switchTab(canvasId);
                
                tab.innerHTML = `Canvas ${canvasId}<span class="close-btn" onclick="event.stopPropagation(); closeTab(event, ${canvasId})">√ó</span>`;
                
                const newTabBtn = tabContainer.querySelector('.new-tab-btn');
                tabContainer.insertBefore(tab, newTabBtn);
                
                // Get canvasInner after page is in DOM
                const canvasInner = canvasPage.querySelector('.canvas-inner');
                
                if (!canvasInner) {
                    console.error('Failed to find canvas-inner for canvas', canvasId);
                    return;
                }
                
                // Create textboxes
                (canvasData.textboxes || []).forEach(tbData => {
                    let sourceTextId = tbData.sourceTextId;
                    if (sourceTextId !== null && sourceTextId !== undefined && needsMigration) {
                        sourceTextId = sourceTextId + 1;
                    }
                    
                    const highlightColor = tbData.highlightColor || defaultHighlightColor;
                    const sourceDisplayNum = sourceTextId !== null && sourceTextId !== undefined ? sourceTextId : '';
                    
                    const textbox = document.createElement('div');
                    textbox.className = 'textbox';
                    textbox.id = 'textbox-' + canvasId + '-' + tbData.id;
                    textbox.style.left = tbData.x + 'px';
                    textbox.style.top = tbData.y + 'px';
                    textbox.style.width = tbData.width + 'px';
                    if (tbData.height) {
                        textbox.style.height = tbData.height + 'px';
                    }
                    
                    if (tbData.isGreyed) {
                        textbox.classList.add('greyed');
                    }
                    if (tbData.isHighlighted) {
                        textbox.classList.add('highlighted');
                        textbox.style.backgroundColor = highlightColor;
                    }
                    if (tbData.isInferred) {
                        textbox.classList.add('inferred');
                    }
                    
                    textbox.innerHTML = `
                        <div class="textbox-content" style="font-size: ${currentFontSize}px;">${tbData.text}</div>
                        <div class="textbox-actions">
                            <button class="icon-btn connect" onclick="startConnection(${tbData.id})" title="Connect">üîó</button>
                            <button class="icon-btn grey ${tbData.isGreyed ? 'active' : ''}" onclick="toggleGreyState(${tbData.id})" title="Grey out (supporting detail)">üëÅÔ∏è</button>
                            <button class="icon-btn highlight ${tbData.isHighlighted ? 'active' : ''}" 
                                    onclick="toggleHighlightButton(${tbData.id}, event)" 
                                    oncontextmenu="toggleHighlightButton(${tbData.id}, event); return false;"
                                    title="Left-click: Choose color | Right-click: Toggle highlight">
                                ‚≠ê
                                ${createColorPalette(tbData.id, highlightColor, canvasId)}
                            </button>
                            <button class="icon-btn delete" onclick="deleteTextbox(${tbData.id})" title="Delete">üóëÔ∏è</button>
                            <button class="icon-btn infer ${tbData.isInferred ? 'active' : ''}" onclick="toggleInferState(${tbData.id})" title="Mark as inferred content">üí≠</button>
                            <div class="source-id-label" title="Source: Text ID ${sourceDisplayNum}">${sourceDisplayNum}</div>
                        </div>
                        <div class="resize-handle"></div>
                    `;
                    
                    canvasInner.appendChild(textbox);
                    
                    makeTextboxDraggable(textbox, tbData.id);
                    makeTextboxResizable(textbox, tbData.id);
                    makeTextboxConnectable(textbox, tbData.id);
                    
                    canvas.textboxes.push({
                        id: tbData.id,
                        element: textbox,
                        text: tbData.text,
                        x: tbData.x,
                        y: tbData.y,
                        width: tbData.width,
                        height: tbData.height,
                        isGreyed: tbData.isGreyed || false,
                        isHighlighted: tbData.isHighlighted || false,
                        highlightColor: highlightColor,
                        isInferred: tbData.isInferred || false,
                        sourceTextId: sourceTextId
                    });
                });
            });
            
            switchUnifiedTab('text', currentTextPageId);
            switchTab(currentCanvasId);
            
            // ‚≠ê‚≠ê‚≠ê SINGLE requestAnimationFrame with zoom restore ‚≠ê‚≠ê‚≠ê
            requestAnimationFrame(() => {
                updateCanvasSize();
                updateConnectionsOnly();
                applyZoom(getCurrentZoomIndex()); // Restore zoom for loaded canvas
                
                if (needsMigration || canvasNeedsMigration) {
                    showSuccessMessage('Project loaded and migrated successfully!');
                } else {
                    showSuccessMessage('Project loaded successfully!');
                }
            });
            
        } catch (error) {
            console.error('Error loading project:', error);
            alert('Failed to load project. The file may be corrupted or invalid.');
        }
    };
    reader.readAsText(file);
    
    event.target.value = '';
}

        function showSuccessMessage(message = 'Copied to clipboard!') {
            const msg = document.getElementById('successMessage');
            msg.textContent = message;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.style.display = 'none';
            }, 2000);
        }

        function getCurrentCanvas() {
            return canvasPages.find(c => c.id === currentCanvasId);
        }

        function getAllTextboxes() {
            const allTextboxes = [];
            canvasPages.forEach(canvas => {
                if (typeof canvas.id === 'number') {
                    canvas.textboxes.forEach(tb => {
                        allTextboxes.push({
                            canvasId: canvas.id,
                            ...tb
                        });
                    });
                }
            });
            return allTextboxes;
        }

        function refreshMainIdea() {
            const display = document.getElementById('mainIdeaDisplay');
            const allTextboxes = getAllTextboxes();
            
            const mainIdeas = allTextboxes.filter(tb => !tb.isGreyed && tb.isHighlighted);
            
            if (mainIdeas.length === 0) {
                display.innerHTML = '<div class="main-idea-empty">No main ideas found. Highlight textboxes with ‚≠ê to mark them as main ideas.</div>';
                mainIdeaOrder = [];
                return;
            }
            
            const currentIds = mainIdeas.map(tb => `${tb.canvasId}-${tb.id}`);
            const orderIds = mainIdeaOrder.filter(id => currentIds.includes(id));
            
            currentIds.forEach(id => {
                if (!orderIds.includes(id)) {
                    orderIds.push(id);
                }
            });
            
            mainIdeaOrder = orderIds;
            
            display.innerHTML = '';
            mainIdeaOrder.forEach((compositeId, index) => {
                const [canvasId, tbId] = compositeId.split('-').map(Number);
                const tb = mainIdeas.find(t => t.canvasId === canvasId && t.id === tbId);
                
                if (tb) {
                    const item = document.createElement('div');
                    item.className = 'main-idea-item';
                    item.draggable = true;
                    item.dataset.index = index;
                    item.dataset.compositeId = compositeId;
                    
                    const number = document.createElement('span');
                    number.className = 'main-idea-number';
                    number.textContent = `${index + 1}.`;
                    
                    const text = document.createElement('span');
                    text.className = 'main-idea-text';
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = tb.text;
                    text.textContent = tempDiv.textContent || tempDiv.innerText || '';
                    
                    if (tb.sourceTextId !== null && tb.sourceTextId !== undefined) {
                        const sourceLabel = document.createElement('span');
                        sourceLabel.className = 'main-idea-source';
                        sourceLabel.textContent = tb.sourceTextId;
                        text.appendChild(sourceLabel);
                    }
                    
                    const handle = document.createElement('span');
                    handle.className = 'drag-handle';
                    handle.textContent = '‚ãÆ‚ãÆ';
                    
                    item.appendChild(number);
                    item.appendChild(text);
                    item.appendChild(handle);
                    
                    item.addEventListener('dragstart', handleMainIdeaDragStart);
                    item.addEventListener('dragend', handleMainIdeaDragEnd);
                    item.addEventListener('dragover', handleMainIdeaDragOver);
                    item.addEventListener('drop', handleMainIdeaDrop);
                    item.addEventListener('dragleave', handleMainIdeaDragLeave);
                    
                    display.appendChild(item);
                }
            });
        }

        function handleMainIdeaDragStart(e) {
            draggedMainIdeaIndex = parseInt(e.target.dataset.index);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleMainIdeaDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedMainIdeaIndex = null;
            
            document.querySelectorAll('.main-idea-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function handleMainIdeaDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const targetIndex = parseInt(e.currentTarget.dataset.index);
            if (draggedMainIdeaIndex !== null && draggedMainIdeaIndex !== targetIndex) {
                e.currentTarget.classList.add('drag-over');
            }
            
            return false;
        }

        function handleMainIdeaDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const targetIndex = parseInt(e.currentTarget.dataset.index);
            
            if (draggedMainIdeaIndex !== null && draggedMainIdeaIndex !== targetIndex) {
                const item = mainIdeaOrder[draggedMainIdeaIndex];
                mainIdeaOrder.splice(draggedMainIdeaIndex, 1);
                
                let insertIndex = targetIndex;
                if (draggedMainIdeaIndex < targetIndex) {
                    insertIndex = targetIndex;
                } else {
                    insertIndex = targetIndex;
                }
                
                mainIdeaOrder.splice(insertIndex, 0, item);
                
                refreshMainIdea();
            }
            
            e.currentTarget.classList.remove('drag-over');
            return false;
        }

        function handleMainIdeaDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function copyMainIdea() {
            const allTextboxes = getAllTextboxes();
            const mainIdeas = allTextboxes.filter(tb => !tb.isGreyed && tb.isHighlighted);
            
            if (mainIdeas.length === 0) {
                alert('No main ideas to copy. Highlight textboxes with ‚≠ê to mark them as main ideas.');
                return;
            }
            
            const orderedTexts = mainIdeaOrder.map((compositeId, index) => {
                const [canvasId, tbId] = compositeId.split('-').map(Number);
                const tb = mainIdeas.find(t => t.canvasId === canvasId && t.id === tbId);
                if (tb) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = tb.text;
                    const plainText = tempDiv.textContent || tempDiv.innerText || '';
                    
                    let sourceStr = '';
                    if (tb.sourceTextId !== null && tb.sourceTextId !== undefined) {
                        sourceStr = `, ${tb.sourceTextId}`;
                    }
                    
                    return `${index + 1}. ${plainText}${sourceStr}`;
                }
                return null;
            }).filter(text => text !== null);
            
            const text = orderedTexts.join('\n');
            
            navigator.clipboard.writeText(text).then(() => {
                showSuccessMessage();
            }).catch(err => {
                alert('Failed to copy to clipboard.');
                console.error(err);
            });
        }

        function copyEdgelist() {
    const allConnections = [];
    
    canvasPages.forEach(canvas => {
        if (typeof canvas.id === 'number') {
            canvas.connections.forEach(conn => {
                const fromBox = canvas.textboxes.find(tb => tb.id === conn.from);
                const toBox = canvas.textboxes.find(tb => tb.id === conn.to);
                
                // Skip connections where either textbox is greyed out
                if (fromBox && toBox && !fromBox.isGreyed && !toBox.isGreyed) {
                    const tempDiv1 = document.createElement('div');
                    tempDiv1.innerHTML = fromBox.text;
                    const fromText = tempDiv1.textContent || tempDiv1.innerText || '';
                    
                    const tempDiv2 = document.createElement('div');
                    tempDiv2.innerHTML = toBox.text;
                    const toText = tempDiv2.textContent || tempDiv2.innerText || '';
                    
                    let sourceText, targetText, fromSourceId, toSourceId;
                    
                    if (['sequence', 'cause', 'solution', 'contrast', 'description', 'source', 'custom'].includes(conn.relation)) {
                        if (conn.reversed) {
                            sourceText = toText;
                            targetText = fromText;
                            fromSourceId = toBox.sourceTextId;
                            toSourceId = fromBox.sourceTextId;
                        } else {
                            sourceText = fromText;
                            targetText = toText;
                            fromSourceId = fromBox.sourceTextId;
                            toSourceId = toBox.sourceTextId;
                        }
                    } else {
                        sourceText = fromText;
                        targetText = toText;
                        fromSourceId = fromBox.sourceTextId;
                        toSourceId = toBox.sourceTextId;
                    }
                    
                    const displayLabel = conn.relation === 'custom' ? conn.customLabel : conn.relation;
                    
                    // ‚≠ê‚≠ê‚≠ê PHASE 3: GET CLUSTER LABELS ‚≠ê‚≠ê‚≠ê
                    let fromCluster = '';
                    let toCluster = '';
                    
                    if (nodeVisualizationSettings.color === 'cluster-lpa' || 
                        nodeVisualizationSettings.color === 'cluster-louvain') {
                        fromCluster = clusterAssignments[sourceText] || '';
                        toCluster = clusterAssignments[targetText] || '';
                    }
                    // ============================================================================
                    
                    const fromSourceNum = fromSourceId !== null && fromSourceId !== undefined ? fromSourceId : '';
                    const toSourceNum = toSourceId !== null && toSourceId !== undefined ? toSourceId : '';
                    
                    // ‚≠ê‚≠ê‚≠ê PHASE 3: APPEND CLUSTER COLUMNS TO CSV STRING ‚≠ê‚≠ê‚≠ê
                    allConnections.push(`"${sourceText}", "${targetText}", ${displayLabel}, ${fromSourceNum}, ${toSourceNum}, ${fromCluster}, ${toCluster}`);
                }
            });
        }
    });
    
    if (allConnections.length === 0) {
        alert('No edgelist data to copy. Create connections between textboxes first.');
        return;
    }
    
    const text = allConnections.join('\n');
    
    navigator.clipboard.writeText(text).then(() => {
        showSuccessMessage();
    }).catch(err => {
        alert('Failed to copy to clipboard.');
        console.error(err);
    });
}

function downloadEdgelist() {
    const allConnections = [];
    
    canvasPages.forEach(canvas => {
        if (typeof canvas.id === 'number') {
            canvas.connections.forEach(conn => {
                const fromBox = canvas.textboxes.find(tb => tb.id === conn.from);
                const toBox = canvas.textboxes.find(tb => tb.id === conn.to);
                
                // Skip connections where either textbox is greyed out
                if (fromBox && toBox && !fromBox.isGreyed && !toBox.isGreyed) {
                    const tempDiv1 = document.createElement('div');
                    tempDiv1.innerHTML = fromBox.text;
                    const fromText = tempDiv1.textContent || tempDiv1.innerText || '';
                    
                    const tempDiv2 = document.createElement('div');
                    tempDiv2.innerHTML = toBox.text;
                    const toText = tempDiv2.textContent || tempDiv2.innerText || '';
                    
                    let sourceText, targetText, fromSourceId, toSourceId;
                    
                    if (['sequence', 'cause', 'solution', 'contrast', 'description', 'source', 'custom'].includes(conn.relation)) {
                        if (conn.reversed) {
                            sourceText = toText;
                            targetText = fromText;
                            fromSourceId = toBox.sourceTextId;
                            toSourceId = fromBox.sourceTextId;
                        } else {
                            sourceText = fromText;
                            targetText = toText;
                            fromSourceId = fromBox.sourceTextId;
                            toSourceId = toBox.sourceTextId;
                        }
                    } else {
                        sourceText = fromText;
                        targetText = toText;
                        fromSourceId = fromBox.sourceTextId;
                        toSourceId = toBox.sourceTextId;
                    }
                    
                    const displayLabel = conn.relation === 'custom' ? conn.customLabel : conn.relation;
                    
                    // ‚≠ê‚≠ê‚≠ê PHASE 3: GET CLUSTER LABELS ‚≠ê‚≠ê‚≠ê
                    let fromCluster = '';
                    let toCluster = '';
                    
                    if (nodeVisualizationSettings.color === 'cluster-lpa' || 
                        nodeVisualizationSettings.color === 'cluster-louvain') {
                        fromCluster = clusterAssignments[sourceText] || '';
                        toCluster = clusterAssignments[targetText] || '';
                    }
                    // ============================================================================
                    
                    const fromSourceNum = fromSourceId !== null && fromSourceId !== undefined ? fromSourceId : '';
                    const toSourceNum = toSourceId !== null && toSourceId !== undefined ? toSourceId : '';
                    
                    allConnections.push({
                        source: sourceText,
                        target: targetText,
                        relation: displayLabel,
                        fromSourceId: fromSourceNum,
                        toSourceId: toSourceNum,
                        fromCluster: fromCluster,  // ‚≠ê NEW
                        toCluster: toCluster       // ‚≠ê NEW
                    });
                }
            });
        }
    });
    
    if (allConnections.length === 0) {
        alert('No edgelist data to download. Create connections between textboxes first.');
        return;
    }
    
    // ‚≠ê‚≠ê‚≠ê PHASE 3: ADD CLUSTER COLUMNS TO CSV HEADER ‚≠ê‚≠ê‚≠ê
    let csvContent = 'Source,Target,Relation,Source_Text_ID,Target_Text_ID,Source_Cluster,Target_Cluster\n';
    // ============================================================================
    
    allConnections.forEach(conn => {
        const source = `"${conn.source.replace(/"/g, '""')}"`;
        const target = `"${conn.target.replace(/"/g, '""')}"`;
        const relation = conn.relation;
        const fromId = conn.fromSourceId;
        const toId = conn.toSourceId;
        const fromClust = conn.fromCluster;  // ‚≠ê NEW
        const toClust = conn.toCluster;      // ‚≠ê NEW
        
        // ‚≠ê‚≠ê‚≠ê PHASE 3: APPEND CLUSTER COLUMNS ‚≠ê‚≠ê‚≠ê
        csvContent += `${source},${target},${relation},${fromId},${toId},${fromClust},${toClust}\n`;
    });
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    link.download = `text-structurer-edgelist-${timestamp}.csv`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
    
    showSuccessMessage('Edgelist CSV downloaded successfully!');
}

        function togglePanel() {
            const leftPanelElement = document.getElementById('leftPanel');
            const collapseBtnElement = document.getElementById('collapseBtn');
            const floatingExpandElement = document.getElementById('floatingExpand');
            const resizerElement = document.getElementById('resizer');
            
            isPanelCollapsed = !isPanelCollapsed;
            
            if (isPanelCollapsed) {
                leftPanelElement.dataset.previousWidth = leftPanelElement.style.width || '40%';
                leftPanelElement.style.width = '';
                leftPanelElement.classList.add('collapsed');
                floatingExpandElement.classList.add('show');
                resizerElement.classList.add('hidden');
            } else {
                leftPanelElement.classList.remove('collapsed');
                if (leftPanelElement.dataset.previousWidth) {
                    leftPanelElement.style.width = leftPanelElement.dataset.previousWidth;
                }
                floatingExpandElement.classList.remove('show');
                resizerElement.classList.remove('hidden');
            }
            
            setTimeout(() => {
                updateConnectionsOnly();
            }, 300);
        }

        function updateFontSize() {
            const textAreas = document.querySelectorAll('.text-area');
            const fontSizeDisplay = document.getElementById('fontSizeDisplay');
            
            textAreas.forEach(textArea => {
                textArea.style.fontSize = currentFontSize + 'px';
            });
            
            document.querySelectorAll('.textbox-content').forEach(content => {
                content.style.fontSize = currentFontSize + 'px';
            });
            
            fontSizeDisplay.textContent = currentFontSize + 'px';
            
            updateConnectionsOnly();
        }

        function increaseFontSize() {
            if (currentFontSize < 32) {
                currentFontSize += 2;
                updateFontSize();
            }
        }

        function decreaseFontSize() {
            if (currentFontSize > 10) {
                currentFontSize -= 2;
                updateFontSize();
            }
        }

        function exportCanvasAsSVG() {
            if (currentCanvasId === 'help' || currentCanvasId === 'settings' || currentCanvasId === 'graph') {
    alert('Please switch to a canvas tab to export as SVG.');
    return;
}

            const canvas = getCurrentCanvas();
            if (!canvas) {
                alert('No canvas found to export.');
                return;
            }

            const canvasPage = document.getElementById('canvas-' + currentCanvasId);
            const canvasInner = canvasPage ? canvasPage.querySelector('.canvas-inner') : null;
            
            if (!canvasInner) {
                alert('No canvas content found to export.');
                return;
            }

            const svgNS = 'http://www.w3.org/2000/svg';
            
            const canvasWidth = parseInt(canvasInner.style.width) || 1600;
            const canvasHeight = parseInt(canvasInner.style.height) || 1200;
            
            const exportSVG = document.createElementNS(svgNS, 'svg');
            exportSVG.setAttribute('xmlns', svgNS);
            exportSVG.setAttribute('width', canvasWidth);
            exportSVG.setAttribute('height', canvasHeight);
            exportSVG.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
            
            const background = document.createElementNS(svgNS, 'rect');
            background.setAttribute('width', '100%');
            background.setAttribute('height', '100%');
            background.setAttribute('fill', '#ecf0f1');
            exportSVG.appendChild(background);
            
            const defs = document.createElementNS(svgNS, 'defs');
            
            const marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            
            const arrowPath = document.createElementNS(svgNS, 'path');
            arrowPath.setAttribute('d', 'M0,0 L0,6 L9,3 z');
            arrowPath.setAttribute('fill', '#999');
            marker.appendChild(arrowPath);
            defs.appendChild(marker);
            exportSVG.appendChild(defs);
            
            canvas.connections.forEach(conn => {
                const fromBox = canvas.textboxes.find(tb => tb.id === conn.from);
                const toBox = canvas.textboxes.find(tb => tb.id === conn.to);
                
                if (fromBox && toBox) {
                    const fromX = parseFloat(fromBox.element.style.left) || fromBox.x;
                    const fromY = parseFloat(fromBox.element.style.top) || fromBox.y;
                    const toX = parseFloat(toBox.element.style.left) || toBox.x;
                    const toY = parseFloat(toBox.element.style.top) || toBox.y;
                    
                    const fromWidth = fromBox.element.offsetWidth;
                    const fromHeight = fromBox.element.offsetHeight;
                    const toWidth = toBox.element.offsetWidth;
                    const toHeight = toBox.element.offsetHeight;
                    
                    const x1 = fromX + fromWidth / 2;
                    const y1 = fromY + fromHeight / 2;
                    const x2 = toX + toWidth / 2;
                    const y2 = toY + toHeight / 2;
                    
                    const color = relationColors[conn.relation] || '#3498db';
                    
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('stroke-opacity', '0.8');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                    
                    exportSVG.appendChild(line);
                    
                    const labelX = (x1 + x2) / 2;
                    const labelY = (y1 + y2) / 2;
                    
                    const displayLabel = conn.relation === 'custom' ? (conn.customLabel || 'connection') : conn.relation;
                    
                    const tempText = document.createElementNS(svgNS, 'text');
                    tempText.setAttribute('font-size', '12px');
                    tempText.setAttribute('font-weight', 'bold');
                    tempText.textContent = displayLabel;
                    exportSVG.appendChild(tempText);
                    const textWidth = tempText.getComputedTextLength ? tempText.getComputedTextLength() : displayLabel.length * 7;
                    exportSVG.removeChild(tempText);
                    
                    const labelBg = document.createElementNS(svgNS, 'rect');
                    labelBg.setAttribute('x', labelX - textWidth / 2 - 4);
                    labelBg.setAttribute('y', labelY - 10);
                    labelBg.setAttribute('width', textWidth + 8);
                    labelBg.setAttribute('height', 18);
                    labelBg.setAttribute('fill', 'white');
                    labelBg.setAttribute('stroke', color);
                    labelBg.setAttribute('rx', '3');
                    exportSVG.appendChild(labelBg);
                    
                    const labelText = document.createElementNS(svgNS, 'text');
                    labelText.setAttribute('x', labelX);
                    labelText.setAttribute('y', labelY + 4);
                    labelText.setAttribute('text-anchor', 'middle');
                    labelText.setAttribute('font-size', '12px');
                    labelText.setAttribute('font-weight', 'bold');
                    labelText.setAttribute('fill', color);
                    labelText.textContent = displayLabel;
                    
                    exportSVG.appendChild(labelText);
                }
            });
            
            function getPlainText(html) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                return tempDiv.textContent || tempDiv.innerText || '';
            }
            
            function measureTextWidth(text, fontSize, fontFamily) {
                const tempText = document.createElementNS(svgNS, 'text');
                tempText.setAttribute('font-size', fontSize + 'px');
                tempText.setAttribute('font-family', fontFamily);
                tempText.textContent = text;
                tempText.setAttribute('visibility', 'hidden');
                exportSVG.appendChild(tempText);
                
                const width = tempText.getComputedTextLength ? tempText.getComputedTextLength() : text.length * fontSize * 0.6;
                exportSVG.removeChild(tempText);
                return width;
            }
            
            function wrapText(text, maxWidth, fontSize, fontFamily) {
                const words = text.split(/\s+/);
                const lines = [];
                let currentLine = '';
                
                words.forEach(word => {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    const testWidth = measureTextWidth(testLine, fontSize, fontFamily);
                    
                    if (testWidth > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                });
                
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            canvas.textboxes.forEach(textbox => {
                const element = textbox.element;
                if (!element) return;
                
                const x = parseFloat(element.style.left) || textbox.x;
                const y = parseFloat(element.style.top) || textbox.y;
                const width = element.offsetWidth;
                const height = element.offsetHeight;
                
                const group = document.createElementNS(svgNS, 'g');
                
                const shadow = document.createElementNS(svgNS, 'rect');
                shadow.setAttribute('x', x + 2);
                shadow.setAttribute('y', y + 2);
                shadow.setAttribute('width', width);
                shadow.setAttribute('height', height);
                shadow.setAttribute('fill', 'rgba(0,0,0,0.15)');
                shadow.setAttribute('rx', '8');
                group.appendChild(shadow);
                
                const bgRect = document.createElementNS(svgNS, 'rect');
                bgRect.setAttribute('x', x);
                bgRect.setAttribute('y', y);
                bgRect.setAttribute('width', width);
                bgRect.setAttribute('height', height);
                bgRect.setAttribute('fill', 'white');
                bgRect.setAttribute('stroke', '#3498db');
                bgRect.setAttribute('stroke-width', '2');
                bgRect.setAttribute('rx', '8');
                
                if (textbox.isHighlighted) {
                    bgRect.setAttribute('fill', textbox.highlightColor || defaultHighlightColor);
                }
                
                if (textbox.isGreyed) {
                    bgRect.setAttribute('opacity', '0.5');
                }
                
                if (textbox.isInferred) {
                    bgRect.setAttribute('stroke-dasharray', '8,4');
                }
                
                group.appendChild(bgRect);
                
                const contentElement = element.querySelector('.textbox-content');
                let textContent = '';
                if (contentElement) {
                    textContent = getPlainText(contentElement.innerHTML);
                }
                
                const padding = 10;
                const fontSize = currentFontSize;
                const fontFamily = 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                const lineHeight = fontSize * 1.4;
                const maxTextWidth = width - (padding * 2);
                
                const lines = wrapText(textContent, maxTextWidth, fontSize, fontFamily);
                
                lines.forEach((line, index) => {
                    const textElement = document.createElementNS(svgNS, 'text');
                    textElement.setAttribute('x', x + padding);
                    textElement.setAttribute('y', y + padding + (index + 1) * lineHeight - 2);
                    textElement.setAttribute('font-size', fontSize + 'px');
                    textElement.setAttribute('font-family', fontFamily);
                    textElement.setAttribute('fill', textbox.isGreyed ? '#95a5a6' : '#2c3e50');
                    textElement.textContent = line;
                    
                    group.appendChild(textElement);
                });
                
                exportSVG.appendChild(group);
            });
            
            const serializer = new XMLSerializer();
            const svgString = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' + 
                              serializer.serializeToString(exportSVG);
            
            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.href = url;
            link.download = `canvas-${currentCanvasId}-${timestamp}.svg`;
            link.click();
            
            URL.revokeObjectURL(url);
            
            showSuccessMessage('SVG exported successfully!');
        }

        function toggleExportSVG() {
            const checkbox = document.getElementById('exportSVGToggle');
            const exportBtn = document.getElementById('exportSVGBtn');
            
            exportSVGEnabled = checkbox.checked;
            
            if (exportSVGEnabled) {
                exportBtn.style.display = 'inline-block';
            } else {
                exportBtn.style.display = 'none';
            }
        }

/**
 * ‚≠ê‚≠ê‚≠ê SMART PNG EXPORT - Context-Aware (Canvas OR Graph) ‚≠ê‚≠ê‚≠ê
 * Automatically detects active tab and exports accordingly:
 * - Canvas tabs (1, 2, 3...) ‚Üí Export canvas as PNG using html2canvas
 * - Graph tab ‚Üí Export Cytoscape.js network as PNG using native export
 */
async function saveCanvasAsImage() {
    // ============================================================================
    // ‚≠ê PHASE 1: DETECT ACTIVE TAB TYPE
    // ============================================================================
    
    if (currentCanvasId === 'help' || currentCanvasId === 'settings') {
        alert('Please switch to a Canvas tab or Graph tab to save as PNG.');
        return;
    }
    
// ============================================================================
// ‚≠ê PHASE 2: GRAPH TAB - Export Cytoscape.js Graph (T-network OR W-network)
// ============================================================================

if (currentCanvasId === 'graph') {
    // ‚≠ê PHASE 4.3.2: Detect which network is active
    const activeCyInstance = wordCyInstance !== null ? wordCyInstance : cyInstance;
    const networkType = wordCyInstance !== null ? 'W-network' : 'T-network';
    
    if (!activeCyInstance) {
        alert('No network graph found. Please run Network Analysis first.');
        return;
    }
    
    try {
        console.log(`üìä Exporting ${networkType} graph as PNG...`);
        
        // Get PNG data from active Cytoscape instance
        const png64 = activeCyInstance.png({
            output: 'blob-promise',
            bg: 'white',
            full: true,
            scale: 2
        });
        
        png64.then(function(blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            // Generate filename with network type and settings
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const algorithm = nodeVisualizationSettings.color === 'cluster-lpa' ? 'LPA' : 
                            nodeVisualizationSettings.color === 'cluster-louvain' ? 'Louvain' : 
                            nodeVisualizationSettings.color === 'source' ? 'Source' : 'Default';
            const sizeMetric = nodeVisualizationSettings.size;
            
            const prefix = networkType === 'W-network' ? 'w-network' : 't-network';
            link.download = `${prefix}-${algorithm}-${sizeMetric}-${timestamp}.png`;
            link.href = url;
            link.click();
            
            URL.revokeObjectURL(url);
            
            showSuccessMessage(`${networkType} graph saved as PNG successfully!`);
            console.log(`‚úÖ ${networkType} graph exported successfully`);
        }).catch(function(error) {
            console.error('Error exporting graph:', error);
            alert('Failed to export network graph. Please try again.');
        });
        
    } catch (error) {
        console.error('Error creating graph PNG:', error);
        alert('Failed to export graph. Your browser may not support this feature.');
    }
    
    return; // Exit after handling graph export
}
    
    // ============================================================================
    // ‚≠ê PHASE 3: CANVAS TAB - Export Canvas as PNG (Original Behavior)
    // ============================================================================
    
    const canvasPage = document.getElementById('canvas-' + currentCanvasId);
    const canvasInner = canvasPage ? canvasPage.querySelector('.canvas-inner') : null;
    
    if (!canvasInner) {
        alert('No canvas found to save.');
        return;
    }

    try {
        console.log(`üñºÔ∏è Exporting canvas ${currentCanvasId} as PNG...`);
        
        const canvas = await html2canvas(canvasInner, {
            backgroundColor: '#ecf0f1',
            scale: 2,
            useCORS: true,
            logging: false
        });

        canvas.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const timestamp = new Date().getTime();
            link.download = `canvas-${currentCanvasId}-${timestamp}.png`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
            
            showSuccessMessage('Canvas saved as PNG successfully!');
            console.log('‚úÖ Canvas exported successfully');
        });
    } catch (error) {
        console.error('Error saving canvas:', error);
        alert('Failed to save canvas as image. Please try again.');
    }
}

        function createNewTab() {
            const newId = canvasIdCounter++;
            const newCanvas = {
                id: newId,
                textboxes: [],
                connections: [],
                textboxIdCounter: 0
            };
            
            canvasPages.push(newCanvas);
            
            const canvasPage = document.createElement('div');
            canvasPage.className = 'canvas-page';
            canvasPage.id = 'canvas-' + newId;
            canvasPage.innerHTML = '<div class="canvas-inner"><svg class="connections-svg"></svg></div>';
            
            const graphPage = document.getElementById('canvas-graph');
if (graphPage && graphPage.parentNode) {
    graphPage.parentNode.insertBefore(canvasPage, graphPage);
}
            
            const tabContainer = document.getElementById('tabContainer');
            const newTabBtn = tabContainer.querySelector('.new-tab-btn');
            
            const tab = document.createElement('button');
            tab.className = 'tab';
            tab.setAttribute('data-tab', newId);
            tab.onclick = () => switchTab(newId);
            
            tab.innerHTML = `Canvas ${newId}<span class="close-btn" onclick="event.stopPropagation(); closeTab(event, ${newId})">√ó</span>`;
            
            tabContainer.insertBefore(tab, newTabBtn);
            
            switchTab(newId);
            
            tab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
        }

        function closeTab(event, tabId) {
            event.stopPropagation();
            
            const canvasTabs = canvasPages.filter(c => typeof c.id === 'number');
            if (canvasTabs.length <= 1) {
                alert('You must keep at least one canvas tab.');
                return;
            }
            
            if (confirm('Are you sure you want to close this tab? All content will be lost.')) {
                const index = canvasPages.findIndex(c => c.id === tabId);
                if (index > -1) {
                    canvasPages.splice(index, 1);
                }
                
                const canvasPage = document.getElementById('canvas-' + tabId);
                if (canvasPage) {
                    canvasPage.remove();
                }
                
                const tab = document.querySelector(`[data-tab="${tabId}"]`);
                if (tab) {
                    tab.remove();
                }
                
                if (currentCanvasId === tabId) {
                    const firstCanvas = canvasPages.find(c => typeof c.id === 'number');
                    if (firstCanvas) {
                        switchTab(firstCanvas.id);
                    }
                }
            }
        }

        function switchTab(tabId) {
    currentCanvasId = tabId;
    
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
        const tabDataId = tab.getAttribute('data-tab');
        if (tabDataId == tabId) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });
    
    const pages = document.querySelectorAll('.canvas-page');
    pages.forEach(page => {
        page.classList.remove('active');
    });
    
    const activePage = document.getElementById('canvas-' + tabId);
    if (activePage) {
        activePage.classList.add('active');
    }
    
    // Only update canvas for numeric canvas IDs (not help/settings/graph)
    if (tabId !== 'help' && tabId !== 'settings' && tabId !== 'graph') {
        updateCanvasSize();
        updateConnectionsOnly();
		// Add for zoom feature
        applyZoom(getCurrentZoomIndex()); // Restore zoom level for this canvas
    }
}

        function sanitizePastedContent(html) {
            html = html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
            html = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
            html = html.replace(/<link[^>]*>/gi, '');
            html = html.replace(/<\?xml[^>]*>/gi, '');
            html = html.replace(/<\/?o:[^>]*>/gi, '');
            html = html.replace(/<\/?w:[^>]*>/gi, '');
            html = html.replace(/<\/?m:[^>]*>/gi, '');
            html = html.replace(/<\/?v:[^>]*>/gi, '');
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            const allElements = doc.body.getElementsByTagName('*');
            for (let i = allElements.length - 1; i >= 0; i--) {
                const element = allElements[i];
                
                if (element.className && typeof element.className === 'string') {
                    element.className = element.className
                        .split(' ')
                        .filter(cls => !cls.match(/^Mso/i))
                        .join(' ');
                    
                    if (!element.className) {
                        element.removeAttribute('class');
                    }
                }
                
                if (element.hasAttribute('style')) {
                    const allowedStyles = cleanInlineStyles(element.style);
                    if (allowedStyles) {
                        element.setAttribute('style', allowedStyles);
                    } else {
                        element.removeAttribute('style');
                    }
                }
                
                const badAttributes = ['lang', 'xml:lang', 'v:shapes', 'o:gfxdata'];
                badAttributes.forEach(attr => {
                    if (element.hasAttribute(attr)) {
                        element.removeAttribute(attr);
                    }
                });
            }
            
            return doc.body.innerHTML;
        }

        function cleanInlineStyles(styleObj) {
            const allowedStyles = [];
            
            const safeProperties = [
                'font-weight',
                'font-style',
                'text-decoration',
                'text-align',
                'margin-left',
                'margin-right',
                'padding-left',
                'padding-right'
            ];
            
            for (let i = 0; i < styleObj.length; i++) {
                const prop = styleObj[i];
                if (safeProperties.includes(prop)) {
                    allowedStyles.push(`${prop}: ${styleObj.getPropertyValue(prop)}`);
                }
            }
            
            return allowedStyles.length > 0 ? allowedStyles.join('; ') : null;
        }

        function setupTextAreaListeners(textArea) {
            textArea.addEventListener('paste', function(e) {
                e.preventDefault();
                
                let htmlContent = e.clipboardData.getData('text/html');
                
                if (!htmlContent || htmlContent.trim() === '') {
                    const plainText = e.clipboardData.getData('text/plain');
                    if (plainText) {
                        htmlContent = plainText
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/\n/g, '<br>');
                    }
                } else {
                    htmlContent = sanitizePastedContent(htmlContent);
                }
                
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                range.deleteContents();
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                
                const fragment = document.createDocumentFragment();
                let node;
                while ((node = tempDiv.firstChild)) {
                    fragment.appendChild(node);
                }
                
                range.insertNode(fragment);
                
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
            });

            textArea.addEventListener('mouseup', handleTextSelection);
            textArea.addEventListener('keyup', handleTextSelection);

            textArea.addEventListener('mousedown', function(e) {
                isDraggingText = false;
            });

            textArea.addEventListener('mousemove', function(e) {
                const selection = window.getSelection();
                if (selection.toString().trim().length > 0 && e.buttons === 1) {
                    isDraggingText = true;
                    const range = selection.getRangeAt(0);
                    const div = document.createElement('div');
                    div.appendChild(range.cloneContents());
                    draggedText = div.innerHTML || selection.toString().trim();
                    draggedTextSourceId = currentTextPageId;
                }
            });

            textArea.addEventListener('dragstart', function(e) {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                if (selectedText.length > 0) {
                    isDraggingText = true;
                    const range = selection.getRangeAt(0);
                    const div = document.createElement('div');
                    div.appendChild(range.cloneContents());
                    draggedText = div.innerHTML || selectedText;
                    draggedTextSourceId = currentTextPageId;
                    
                    e.dataTransfer.effectAllowed = 'copy';
                    
                    const img = document.createElement('div');
                    img.style.position = 'absolute';
                    img.style.top = '-1000px';
                    document.body.appendChild(img);
                    e.dataTransfer.setDragImage(img, 0, 0);
                    setTimeout(() => {
                        if (document.body.contains(img)) {
                            document.body.removeChild(img);
                        }
                    }, 0);
                }
            });

            textArea.addEventListener('dragend', function(e) {
                isDraggingText = false;
                draggedTextSourceId = null;
                const preview = document.getElementById('dragPreview');
                preview.style.display = 'none';
            });
        }

        function handleTextSelection() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            const segmentBtn = document.getElementById('segmentBtn');
            const keyBtn = document.getElementById('keyBtn');
            
            if (selectedText.length > 0 && currentLeftPageType === 'text') {
                segmentBtn.disabled = false;
                keyBtn.disabled = false;
            } else {
                segmentBtn.disabled = true;
                keyBtn.disabled = true;
            }
        }

        function toggleKeyHighlight() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length === 0) return;
            
            const range = selection.getRangeAt(0);
            
            let isKeyText = false;
            let keySpan = null;
            
            const container = range.commonAncestorContainer;
            let node = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
            
            while (node && node !== getCurrentTextArea()) {
                if (node.classList && node.classList.contains('key-text')) {
                    isKeyText = true;
                    keySpan = node;
                    break;
                }
                node = node.parentElement;
            }
            
            if (isKeyText && keySpan) {
                const parent = keySpan.parentNode;
                while (keySpan.firstChild) {
                    parent.insertBefore(keySpan.firstChild, keySpan);
                }
                parent.removeChild(keySpan);
                
                parent.normalize();
            } else {
                const span = document.createElement('span');
                span.className = 'key-text';
                
                try {
                    range.surroundContents(span);
                } catch (e) {
                    const fragment = range.extractContents();
                    span.appendChild(fragment);
                    range.insertNode(span);
                }
            }
            
            selection.removeAllRanges();
        }

        function createSegment() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length === 0) return;
            
            if (currentCanvasId === 'help' || currentCanvasId === 'settings' || currentCanvasId === 'graph') {
    alert('Please switch to a canvas tab to create segments.');
    return;
}
            
            const range = selection.getRangeAt(0);
            const div = document.createElement('div');
            div.appendChild(range.cloneContents());
            const htmlContent = div.innerHTML || selectedText;
            
            selection.removeAllRanges();
            
            const canvasContent = document.getElementById('canvasContent');
            const scrollX = canvasContent.scrollLeft;
            const scrollY = canvasContent.scrollTop;
            
            const x = scrollX + 50;
            const y = scrollY + 50;
            
            createTextbox(htmlContent, x, y, currentTextPageId);
        }

        function loadHtmlFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const textArea = getCurrentTextArea();
                if (textArea) {
                    textArea.innerHTML = e.target.result;
                    
                    const currentPage = getCurrentTextPage();
                    if (currentPage) {
                        currentPage.content = e.target.result;
                    }
                }
            };
            reader.readAsText(file);
            
            event.target.value = '';
        }

        const canvasContent = document.getElementById('canvasContent');
        
        canvasContent.addEventListener('dragover', function(e) {
            if (isDraggingText && currentCanvasId !== 'help' && currentCanvasId !== 'settings' && currentCanvasId !== 'graph') {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                
                const preview = document.getElementById('dragPreview');
                preview.style.display = 'block';
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = draggedText;
                const previewText = tempDiv.textContent || tempDiv.innerText || '';
                preview.textContent = previewText.substring(0, 50) + (previewText.length > 50 ? '...' : '');
                
                preview.style.left = (e.clientX + 15) + 'px';
                preview.style.top = (e.clientY + 15) + 'px';
            }
        });

        canvasContent.addEventListener('dragleave', function(e) {
            if (e.target === canvasContent && !canvasContent.contains(e.relatedTarget)) {
                const preview = document.getElementById('dragPreview');
                preview.style.display = 'none';
            }
        });

        canvasContent.addEventListener('drop', function(e) {
            if (isDraggingText && currentCanvasId !== 'help' && currentCanvasId !== 'settings' && currentCanvasId !== 'graph') {
                e.preventDefault();
                
                const preview = document.getElementById('dragPreview');
                preview.style.display = 'none';
                
                const canvasPage = document.getElementById('canvas-' + currentCanvasId);
                const canvasInner = canvasPage ? canvasPage.querySelector('.canvas-inner') : null;
                
                if (canvasInner) {
                    const canvasRect = canvasContent.getBoundingClientRect();
                    
                    const x = e.clientX - canvasRect.left + canvasContent.scrollLeft;
                    const y = e.clientY - canvasRect.top + canvasContent.scrollTop;
                    
                    createTextbox(draggedText, x, y, draggedTextSourceId);
                }
                
                isDraggingText = false;
                draggedTextSourceId = null;
            }
        });

        window.toggleGreyState = function(id) {
            const canvas = getCurrentCanvas();
            const textbox = canvas.textboxes.find(tb => tb.id === id);
            if (!textbox) return;
            
            textbox.isGreyed = !textbox.isGreyed;
            
            const element = textbox.element;
            const greyBtn = element.querySelector('.icon-btn.grey');
            
            if (textbox.isGreyed) {
                element.classList.add('greyed');
                greyBtn.classList.add('active');
            } else {
                element.classList.remove('greyed');
                greyBtn.classList.remove('active');
            }
        }

        window.toggleInferState = function(id) {
            const canvas = getCurrentCanvas();
            const textbox = canvas.textboxes.find(tb => tb.id === id);
            if (!textbox) return;
            
            textbox.isInferred = !textbox.isInferred;
            
            const element = textbox.element;
            const inferBtn = element.querySelector('.icon-btn.infer');
            
            if (textbox.isInferred) {
                element.classList.add('inferred');
                inferBtn.classList.add('active');
            } else {
                element.classList.remove('inferred');
                inferBtn.classList.remove('active');
            }
        }

        window.startConnection = function(fromId) {
            const canvas = getCurrentCanvas();
            
            if (connectingFrom === null) {
                connectingFrom = fromId;
                const textbox = document.getElementById('textbox-' + currentCanvasId + '-' + fromId);
                if (textbox) {
                    textbox.classList.add('connecting');
                }
            } else {
                const existingConnection = canvas.connections.find(
                    c => (c.from === connectingFrom && c.to === fromId) ||
                         (c.from === fromId && c.to === connectingFrom)
                );
                
                if (existingConnection) {
                    alert('A connection already exists between these textboxes.');
                    cancelConnection();
                    return;
                }
                
                if (connectingFrom !== fromId) {
                    pendingConnection = { from: connectingFrom, to: fromId };
                    editingConnectionIndex = null;
                    document.getElementById('dialogTitle').textContent = 'Select Relation Type';
                    document.getElementById('deleteConnectionBtn').style.display = 'none';
                    
                    const customInput = document.getElementById('customLabelInput');
                    customInput.value = 'connection';
                    
                    document.getElementById('dialogOverlay').classList.add('active');
                } else {
                    cancelConnection();
                }
            }
        }

        window.deleteTextbox = function(id) {
            const canvas = getCurrentCanvas();
            const textbox = canvas.textboxes.find(tb => tb.id === id);
            if (!textbox) return;
            
            canvas.connections = canvas.connections.filter(c => c.from !== id && c.to !== id);
            
            textbox.element.remove();
            
            const index = canvas.textboxes.findIndex(tb => tb.id === id);
            if (index > -1) {
                canvas.textboxes.splice(index, 1);
            }
            
            updateCanvasSize();
            updateConnectionsOnly();
        }

function createTextbox(text, x, y, sourceTextId = null) {
    const canvas = getCurrentCanvas();
    const id = canvas.textboxIdCounter++;
    
    const canvasPage = document.getElementById('canvas-' + currentCanvasId);
    const canvasInner = canvasPage.querySelector('.canvas-inner');
    
    const sourceDisplayNum = sourceTextId !== null ? sourceTextId : '';
    const highlightColor = defaultHighlightColor;
    
    const textbox = document.createElement('div');
    textbox.className = 'textbox';
    textbox.id = 'textbox-' + currentCanvasId + '-' + id;
    textbox.style.left = x + 'px';
    textbox.style.top = y + 'px';
    textbox.style.width = '250px';
    
    // ‚≠ê FIXED: Use 'id' not 'tb.id', remove undefined 'tb.isHighlighted'
    textbox.innerHTML = `
        <div class="textbox-content" style="font-size: ${currentFontSize}px;">${text}</div>
        <div class="textbox-actions">
            <button class="icon-btn connect" onclick="startConnection(${id})" title="Connect">üîó</button>
            <button class="icon-btn grey" onclick="toggleGreyState(${id})" title="Grey out (supporting detail)">üëÅÔ∏è</button>
            <button class="icon-btn highlight" 
                    onclick="toggleHighlightButton(${id}, event)" 
                    oncontextmenu="toggleHighlightButton(${id}, event); return false;"
                    title="Left-click: Choose color | Right-click: Toggle highlight">
                ‚≠ê
                ${createColorPalette(id, highlightColor, currentCanvasId)}
            </button>
            <button class="icon-btn delete" onclick="deleteTextbox(${id})" title="Delete">üóëÔ∏è</button>
            <button class="icon-btn infer" onclick="toggleInferState(${id})" title="Mark as inferred content">üí≠</button>
            <div class="source-id-label" title="Source: Text ID ${sourceDisplayNum}">${sourceDisplayNum}</div>
        </div>
        <div class="resize-handle"></div>
    `;
    
    canvasInner.appendChild(textbox);
    
    makeTextboxDraggable(textbox, id);
    makeTextboxResizable(textbox, id);
    makeTextboxConnectable(textbox, id);
    
    canvas.textboxes.push({
        id: id,
        element: textbox,
        text: text,
        x: x,
        y: y,
        width: textbox.offsetWidth,
        height: textbox.offsetHeight,
        isGreyed: false,
        isHighlighted: false,
        highlightColor: highlightColor,
        isInferred: false,
        sourceTextId: sourceTextId
    });
    
    updateConnectionsOnly();
}

        function makeTextboxDraggable(element, id) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            element.addEventListener('mousedown', dragStart);

            function dragStart(e) {
                if (e.target.tagName === 'BUTTON' || 
                    e.target.closest('.icon-btn') || 
                    e.target.closest('.color-palette') ||
                    e.target.classList.contains('resize-handle')) {
                    return;
                }
                
                isDragging = true;
                element.classList.add('dragging');
                
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseFloat(element.style.left) || 0;
                startTop = parseFloat(element.style.top) || 0;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                e.preventDefault();
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    const newX = Math.max(0, startLeft + deltaX);
                    const newY = Math.max(0, startTop + deltaY);
                    
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    const canvas = getCurrentCanvas();
                    const textbox = canvas.textboxes.find(tb => tb.id === id);
                    if (textbox) {
                        textbox.x = newX;
                        textbox.y = newY;
                    }
                    
                    updateConnectionsOnly();
                }
            }

            function dragEnd(e) {
                if (isDragging) {
                    isDragging = false;
                    element.classList.remove('dragging');
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', dragEnd);
                    
                    updateCanvasSize();
                }
            }
        }

        function makeTextboxResizable(element, id) {
            const resizeHandle = element.querySelector('.resize-handle');
            let isResizing = false;
            let startX, startY, startWidth, startHeight;

            resizeHandle.addEventListener('mousedown', function(e) {
                isResizing = true;
                
                element.classList.add('resizing');
                
                startX = e.clientX;
                startY = e.clientY;
                startWidth = element.offsetWidth;
                startHeight = element.offsetHeight;
                
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
                
                e.preventDefault();
                e.stopPropagation();
            });

            function resize(e) {
                if (isResizing) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    const newWidth = Math.max(100, Math.min(800, startWidth + deltaX));
                    const newHeight = Math.max(40, startHeight + deltaY);
                    
                    element.style.width = newWidth + 'px';
                    element.style.height = newHeight + 'px';
                    
                    const canvas = getCurrentCanvas();
                    const textbox = canvas.textboxes.find(tb => tb.id === id);
                    if (textbox) {
                        textbox.width = newWidth;
                        textbox.height = newHeight;
                    }
                    
                    updateConnectionsOnly();
                }
            }

            function stopResize(e) {
                if (isResizing) {
                    isResizing = false;
                    element.classList.remove('resizing');
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                    
                    updateCanvasSize();
                }
            }
        }

        function makeTextboxConnectable(element, id) {
            const connectBtn = element.querySelector('.icon-btn.connect');
            
            if (!connectBtn) return;
            
            connectBtn.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                isDraggingConnection = true;
                connectionDragFrom = id;
                
                element.classList.add('connecting');
                
                const canvasPage = document.getElementById('canvas-' + currentCanvasId);
                const svg = canvasPage.querySelector('.connections-svg');
                
                tempConnectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tempConnectionLine.setAttribute('stroke', '#2ecc71');
                tempConnectionLine.setAttribute('stroke-width', '3');
                tempConnectionLine.setAttribute('stroke-dasharray', '5,5');
                tempConnectionLine.setAttribute('opacity', '0.7');
                
                const rect = element.getBoundingClientRect();
                const canvasContent = document.getElementById('canvasContent');
                const canvasRect = canvasContent.getBoundingClientRect();
                
                const startX = rect.left + rect.width / 2 - canvasRect.left + canvasContent.scrollLeft;
                const startY = rect.top + rect.height / 2 - canvasRect.top + canvasContent.scrollTop;
                
                tempConnectionLine.setAttribute('x1', startX);
                tempConnectionLine.setAttribute('y1', startY);
                tempConnectionLine.setAttribute('x2', startX);
                tempConnectionLine.setAttribute('y2', startY);
                
                svg.appendChild(tempConnectionLine);
            });
            
            element.addEventListener('mouseenter', function(e) {
                if (isDraggingConnection && connectionDragFrom !== id) {
                    element.style.borderColor = '#3498db';
                    element.style.borderWidth = '3px';
                }
            });
            
            element.addEventListener('mouseleave', function(e) {
                if (isDraggingConnection && connectionDragFrom !== id) {
                    element.style.borderColor = '#3498db';
                    element.style.borderWidth = '2px';
                }
            });
        }

        document.addEventListener('mousemove', function(e) {
            if (isDraggingConnection && tempConnectionLine && connectionDragFrom !== null) {
                const canvasContent = document.getElementById('canvasContent');
                const canvasRect = canvasContent.getBoundingClientRect();
                
                const currentX = e.clientX - canvasRect.left + canvasContent.scrollLeft;
                const currentY = e.clientY - canvasRect.top + canvasContent.scrollTop;
                
                tempConnectionLine.setAttribute('x2', currentX);
                tempConnectionLine.setAttribute('y2', currentY);
            }
        });

        document.addEventListener('mouseup', function(e) {
            if (isDraggingConnection && connectionDragFrom !== null) {
                const canvas = getCurrentCanvas();
                
                const targetElement = document.elementFromPoint(e.clientX, e.clientY);
                let targetTextbox = null;
                
                if (targetElement) {
                    let element = targetElement;
                    while (element && !element.classList.contains('textbox')) {
                        element = element.parentElement;
                    }
                    
                    if (element && element.classList.contains('textbox')) {
                        targetTextbox = element;
                    }
                }
                
                const fromElement = document.getElementById('textbox-' + currentCanvasId + '-' + connectionDragFrom);
                if (fromElement) {
                    fromElement.classList.remove('connecting');
                }
                
                if (targetTextbox) {
                    targetTextbox.style.borderColor = '#3498db';
                    targetTextbox.style.borderWidth = '2px';
                    
                    const targetId = parseInt(targetTextbox.id.split('-').pop());
                    
                    if (targetId !== connectionDragFrom) {
                        const existingConnection = canvas.connections.find(
                            c => (c.from === connectionDragFrom && c.to === targetId) ||
                                 (c.from === targetId && c.to === connectionDragFrom)
                        );
                        
                        if (!existingConnection) {
                            pendingConnection = { from: connectionDragFrom, to: targetId };
                            editingConnectionIndex = null;
                            document.getElementById('dialogTitle').textContent = 'Select Relation Type';
                            document.getElementById('deleteConnectionBtn').style.display = 'none';
                            
                            const customInput = document.getElementById('customLabelInput');
                            customInput.value = 'connection';
                            
                            document.getElementById('dialogOverlay').classList.add('active');
                        } else {
                            alert('A connection already exists between these textboxes.');
                        }
                    }
                }
                
                if (tempConnectionLine && tempConnectionLine.parentNode) {
                    tempConnectionLine.parentNode.removeChild(tempConnectionLine);
                }
                
                isDraggingConnection = false;
                connectionDragFrom = null;
                tempConnectionLine = null;
            }
        });

        function selectRelation(relation, customLabel) {
            const canvas = getCurrentCanvas();
            
            if (editingConnectionIndex !== null) {
                canvas.connections[editingConnectionIndex].relation = relation;
                if (relation === 'custom') {
                    canvas.connections[editingConnectionIndex].customLabel = customLabel || 'connection';
                }
                updateConnectionsOnly();
                document.getElementById('dialogOverlay').classList.remove('active');
                editingConnectionIndex = null;
            } else if (pendingConnection) {
                const newConnection = {
                    from: pendingConnection.from,
                    to: pendingConnection.to,
                    relation: relation,
                    reversed: false
                };
                
                if (relation === 'custom') {
                    newConnection.customLabel = customLabel || 'connection';
                }
                
                canvas.connections.push(newConnection);
                
                updateConnectionsOnly();
                document.getElementById('dialogOverlay').classList.remove('active');
                cancelConnection();
            }
        }

        function cancelConnection() {
            if (connectingFrom !== null) {
                const textbox = document.getElementById('textbox-' + currentCanvasId + '-' + connectingFrom);
                if (textbox) {
                    textbox.classList.remove('connecting');
                }
            }
            connectingFrom = null;
            pendingConnection = null;
            editingConnectionIndex = null;
            
            const customInput = document.getElementById('customLabelInput');
            customInput.value = 'connection';
            
            document.getElementById('dialogOverlay').classList.remove('active');
        }

        function deleteCurrentConnection() {
            const canvas = getCurrentCanvas();
            if (editingConnectionIndex !== null) {
                canvas.connections.splice(editingConnectionIndex, 1);
                updateConnectionsOnly();
                document.getElementById('dialogOverlay').classList.remove('active');
                editingConnectionIndex = null;
            }
        }

        function reverseConnection(index) {
            const canvas = getCurrentCanvas();
            const conn = canvas.connections[index];
            
            if (['sequence', 'cause', 'solution', 'contrast', 'description', 'source', 'custom'].includes(conn.relation)) {
                conn.reversed = !conn.reversed;
            }
            
            updateConnectionsOnly();
        }

        function getEdgePoint(boxX, boxY, boxWidth, boxHeight, targetX, targetY) {
            const centerX = boxX + boxWidth / 2;
            const centerY = boxY + boxHeight / 2;
            
            const angle = Math.atan2(targetY - centerY, targetX - centerX);
            
            const absAngle = Math.abs(angle);
            const halfWidth = boxWidth / 2;
            const halfHeight = boxHeight / 2;
            
            let edgeX, edgeY;
            
            if (absAngle < Math.atan2(halfHeight, halfWidth)) {
                edgeX = boxX + boxWidth;
                edgeY = centerY + (boxWidth / 2) * Math.tan(angle);
            } else if (absAngle > Math.PI - Math.atan2(halfHeight, halfWidth)) {
                edgeX = boxX;
                edgeY = centerY - (boxWidth / 2) * Math.tan(angle);
            } else if (angle > 0) {
                edgeY = boxY + boxHeight;
                edgeX = centerX + (boxHeight / 2) / Math.tan(angle);
            } else {
                edgeY = boxY;
                edgeX = centerX - (boxHeight / 2) / Math.tan(angle);
            }
            
            return { x: edgeX, y: edgeY };
        }

        function updateCanvasSize() {
            if (currentCanvasId === 'help' || currentCanvasId === 'settings' || currentCanvasId === 'graph') return;
            
            const canvas = getCurrentCanvas();
            const canvasPage = document.getElementById('canvas-' + currentCanvasId);
            if (!canvasPage) return;
            
            const canvasInner = canvasPage.querySelector('.canvas-inner');
            const svg = canvasInner.querySelector('.connections-svg');
            
            let maxWidth = 0;
            let maxHeight = 0;
            
            canvas.textboxes.forEach(tb => {
                const right = parseFloat(tb.element.style.left) + tb.element.offsetWidth;
                const bottom = parseFloat(tb.element.style.top) + tb.element.offsetHeight;
                maxWidth = Math.max(maxWidth, right);
                maxHeight = Math.max(maxHeight, bottom);
            });
            
            maxWidth += 200;
            maxHeight += 200;
            
            const canvasContent = document.getElementById('canvasContent');
            const contentWidth = canvasContent.clientWidth;
            const contentHeight = canvasContent.clientHeight;
            
            const finalWidth = Math.max(maxWidth, contentWidth);
            const finalHeight = Math.max(maxHeight, contentHeight);
            
            canvasInner.style.width = finalWidth + 'px';
            canvasInner.style.height = finalHeight + 'px';
            
            svg.setAttribute('width', finalWidth);
            svg.setAttribute('height', finalHeight);
            svg.setAttribute('viewBox', `0 0 ${finalWidth} ${finalHeight}`);
            svg.style.width = finalWidth + 'px';
            svg.style.height = finalHeight + 'px';
        }

// Due to character limits, the updateConnectionsOnly function and remaining helper functions
// continue exactly as in version 77. The key changes are:
// 1. Added color palette creation and toggle functions
// 2. Modified toggleHighlightButton to work with the palette
// 3. Added highlightColor property to textbox data structure
// 4. Saved/loaded highlight colors in project files

// Continue with the remaining connection drawing code from version 77...


function updateConnectionsOnly() {
    if (currentCanvasId === 'help' || currentCanvasId === 'settings' || currentCanvasId === 'graph') return;
    
    const canvas = getCurrentCanvas();
    const canvasPage = document.getElementById('canvas-' + currentCanvasId);
    if (!canvasPage) return;
    
    const svg = canvasPage.querySelector('.connections-svg');
    if (!svg) return;
    
    svg.innerHTML = '';
    
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    
    Object.keys(relationColors).forEach(relationType => {
        const color = relationColors[relationType];
        const markerId = `arrow-${relationType}-${currentCanvasId}`;
        
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', markerId);
        marker.setAttribute('markerWidth', '10');
        marker.setAttribute('markerHeight', '10');
        marker.setAttribute('refX', '9');
        marker.setAttribute('refY', '3');
        marker.setAttribute('orient', 'auto');
        marker.setAttribute('markerUnits', 'strokeWidth');
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M0,0 L0,6 L9,3 z');
        path.setAttribute('fill', color);
        marker.appendChild(path);
        
        defs.appendChild(marker);
    });
    
    const doubleMarkerStart = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    doubleMarkerStart.setAttribute('id', `arrow-double-start-${currentCanvasId}`);
    doubleMarkerStart.setAttribute('markerWidth', '10');
    doubleMarkerStart.setAttribute('markerHeight', '10');
    doubleMarkerStart.setAttribute('refX', '0');
    doubleMarkerStart.setAttribute('refY', '3');
    doubleMarkerStart.setAttribute('orient', 'auto');
    doubleMarkerStart.setAttribute('markerUnits', 'strokeWidth');
    
    const pathStart = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathStart.setAttribute('d', 'M9,0 L9,6 L0,3 z');
    pathStart.setAttribute('fill', relationColors['comparison']);
    doubleMarkerStart.appendChild(pathStart);
    defs.appendChild(doubleMarkerStart);
    
    const doubleMarkerEnd = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    doubleMarkerEnd.setAttribute('id', `arrow-double-end-${currentCanvasId}`);
    doubleMarkerEnd.setAttribute('markerWidth', '10');
    doubleMarkerEnd.setAttribute('markerHeight', '10');
    doubleMarkerEnd.setAttribute('refX', '9');
    doubleMarkerEnd.setAttribute('refY', '3');
    doubleMarkerEnd.setAttribute('orient', 'auto');
    doubleMarkerEnd.setAttribute('markerUnits', 'strokeWidth');
    
    const pathEnd = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathEnd.setAttribute('d', 'M0,0 L0,6 L9,3 z');
    pathEnd.setAttribute('fill', relationColors['comparison']);
    doubleMarkerEnd.appendChild(pathEnd);
    defs.appendChild(doubleMarkerEnd);
    
    const dotMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    dotMarker.setAttribute('id', `dot-${currentCanvasId}`);
    dotMarker.setAttribute('markerWidth', '8');
    dotMarker.setAttribute('markerHeight', '8');
    dotMarker.setAttribute('refX', '4');
    dotMarker.setAttribute('refY', '4');
    dotMarker.setAttribute('markerUnits', 'strokeWidth');
    
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '4');
    circle.setAttribute('cy', '4');
    circle.setAttribute('r', '3');
    circle.setAttribute('fill', relationColors['custom']);
    dotMarker.appendChild(circle);
    defs.appendChild(dotMarker);
    
    svg.appendChild(defs);
    
    canvas.connections.forEach((conn, index) => {
        const fromBox = canvas.textboxes.find(tb => tb.id === conn.from);
        const toBox = canvas.textboxes.find(tb => tb.id === conn.to);
        
        if (!fromBox || !toBox) return;
        
        const fromX = parseFloat(fromBox.element.style.left) || fromBox.x;
        const fromY = parseFloat(fromBox.element.style.top) || fromBox.y;
        const fromWidth = fromBox.element.offsetWidth;
        const fromHeight = fromBox.element.offsetHeight;
        
        const toX = parseFloat(toBox.element.style.left) || toBox.x;
        const toY = parseFloat(toBox.element.style.top) || toBox.y;
        const toWidth = toBox.element.offsetWidth;
        const toHeight = toBox.element.offsetHeight;
        
        const fromCenter = { x: fromX + fromWidth / 2, y: fromY + fromHeight / 2 };
        const toCenter = { x: toX + toWidth / 2, y: toY + toHeight / 2 };
        
        const fromEdge = getEdgePoint(fromX, fromY, fromWidth, fromHeight, toCenter.x, toCenter.y);
        const toEdge = getEdgePoint(toX, toY, toWidth, toHeight, fromCenter.x, fromCenter.y);
        
        const color = relationColors[conn.relation];
        
        let lineElement;
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.classList.add('connection-label-group');
        
        let visualSource = conn.reversed ? toEdge : fromEdge;
        let visualTarget = conn.reversed ? fromEdge : toEdge;
        
        if (conn.relation === 'comparison') {
            lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            lineElement.setAttribute('x1', fromEdge.x);
            lineElement.setAttribute('y1', fromEdge.y);
            lineElement.setAttribute('x2', toEdge.x);
            lineElement.setAttribute('y2', toEdge.y);
            lineElement.setAttribute('stroke', color);
            lineElement.setAttribute('stroke-width', '2');
            lineElement.setAttribute('marker-start', `url(#arrow-double-start-${currentCanvasId})`);
            lineElement.setAttribute('marker-end', `url(#arrow-double-end-${currentCanvasId})`);
        } else if (conn.relation === 'analogy') {
            const dx = toEdge.x - fromEdge.x;
            const dy = toEdge.y - fromEdge.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const offsetX = (dy / length) * 3;
            const offsetY = (-dx / length) * 3;
            
            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', fromEdge.x + offsetX);
            line1.setAttribute('y1', fromEdge.y + offsetY);
            line1.setAttribute('x2', toEdge.x + offsetX);
            line1.setAttribute('y2', toEdge.y + offsetY);
            line1.setAttribute('stroke', color);
            line1.setAttribute('stroke-width', '2');
            
            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', fromEdge.x - offsetX);
            line2.setAttribute('y1', fromEdge.y - offsetY);
            line2.setAttribute('x2', toEdge.x - offsetX);
            line2.setAttribute('y2', toEdge.y - offsetY);
            line2.setAttribute('stroke', color);
            line2.setAttribute('stroke-width', '2');
            
            group.appendChild(line1);
            group.appendChild(line2);
            lineElement = group;
        } else if (conn.relation === 'description' || conn.relation === 'source') {
            const midX = (visualSource.x + visualTarget.x) / 2;
            const midY = (visualSource.y + visualTarget.y) / 2;
            
            const dottedLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            dottedLine.setAttribute('x1', visualSource.x);
            dottedLine.setAttribute('y1', visualSource.y);
            dottedLine.setAttribute('x2', midX);
            dottedLine.setAttribute('y2', midY);
            dottedLine.setAttribute('stroke', color);
            dottedLine.setAttribute('stroke-width', '2');
            dottedLine.setAttribute('stroke-dasharray', '5,5');
            
            const solidLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            solidLine.setAttribute('x1', midX);
            solidLine.setAttribute('y1', midY);
            solidLine.setAttribute('x2', visualTarget.x);
            solidLine.setAttribute('y2', visualTarget.y);
            solidLine.setAttribute('stroke', color);
            solidLine.setAttribute('stroke-width', '2');
            
            group.appendChild(dottedLine);
            group.appendChild(solidLine);
            lineElement = group;
            
        } else if (conn.relation === 'contrast') {
            const midX = (visualSource.x + visualTarget.x) / 2;
            const midY = (visualSource.y + visualTarget.y) / 2;
            
            const dottedLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            dottedLine.setAttribute('x1', midX);
            dottedLine.setAttribute('y1', midY);
            dottedLine.setAttribute('x2', visualSource.x);
            dottedLine.setAttribute('y2', visualSource.y);
            dottedLine.setAttribute('stroke', color);
            dottedLine.setAttribute('stroke-width', '2');
            dottedLine.setAttribute('stroke-dasharray', '5,5');
            dottedLine.setAttribute('marker-end', `url(#arrow-${conn.relation}-${currentCanvasId})`);
            
            const solidLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            solidLine.setAttribute('x1', midX);
            solidLine.setAttribute('y1', midY);
            solidLine.setAttribute('x2', visualTarget.x);
            solidLine.setAttribute('y2', visualTarget.y);
            solidLine.setAttribute('stroke', color);
            solidLine.setAttribute('stroke-width', '2');
            solidLine.setAttribute('marker-end', `url(#arrow-${conn.relation}-${currentCanvasId})`);
            
            group.appendChild(dottedLine);
            group.appendChild(solidLine);
            lineElement = group;
            
        } else if (conn.relation === 'custom') {
            const midX = (visualSource.x + visualTarget.x) / 2;
            const midY = (visualSource.y + visualTarget.y) / 2;
            
            const dottedLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            dottedLine.setAttribute('x1', visualSource.x);
            dottedLine.setAttribute('y1', visualSource.y);
            dottedLine.setAttribute('x2', midX);
            dottedLine.setAttribute('y2', midY);
            dottedLine.setAttribute('stroke', color);
            dottedLine.setAttribute('stroke-width', '2');
            dottedLine.setAttribute('stroke-dasharray', '5,5');
            dottedLine.setAttribute('marker-start', `url(#dot-${currentCanvasId})`);
            
            const solidLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            solidLine.setAttribute('x1', midX);
            solidLine.setAttribute('y1', midY);
            solidLine.setAttribute('x2', visualTarget.x);
            solidLine.setAttribute('y2', visualTarget.y);
            solidLine.setAttribute('stroke', color);
            solidLine.setAttribute('stroke-width', '2');
            solidLine.setAttribute('marker-end', `url(#dot-${currentCanvasId})`);
            
            group.appendChild(dottedLine);
            group.appendChild(solidLine);
            lineElement = group;
        } else {
            lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            lineElement.setAttribute('x1', visualSource.x);
            lineElement.setAttribute('y1', visualSource.y);
            lineElement.setAttribute('x2', visualTarget.x);
            lineElement.setAttribute('y2', visualTarget.y);
            lineElement.setAttribute('stroke', color);
            lineElement.setAttribute('stroke-width', '2');
            lineElement.setAttribute('marker-end', `url(#arrow-${conn.relation}-${currentCanvasId})`);
        }
        
        if (lineElement === group) {
            group.addEventListener('click', function(e) {
                e.stopPropagation();
                editingConnectionIndex = index;
                pendingConnection = null;
                document.getElementById('dialogTitle').textContent = 'Edit Connection';
                document.getElementById('deleteConnectionBtn').style.display = 'block';
                
                const customInput = document.getElementById('customLabelInput');
                if (conn.relation === 'custom' && conn.customLabel) {
                    customInput.value = conn.customLabel;
                } else {
                    customInput.value = 'connection';
                }
                
                document.getElementById('dialogOverlay').classList.add('active');
            });
        } else {
            lineElement.addEventListener('click', function(e) {
                e.stopPropagation();
                editingConnectionIndex = index;
                pendingConnection = null;
                document.getElementById('dialogTitle').textContent = 'Edit Connection';
                document.getElementById('deleteConnectionBtn').style.display = 'block';
                
                const customInput = document.getElementById('customLabelInput');
                if (conn.relation === 'custom' && conn.customLabel) {
                    customInput.value = conn.customLabel;
                } else {
                    customInput.value = 'connection';
                }
                
                document.getElementById('dialogOverlay').classList.add('active');
            });
        }
        
        if (lineElement === group) {
            svg.appendChild(group);
        } else {
            group.appendChild(lineElement);
            svg.appendChild(group);
        }
        
        const labelX = (fromEdge.x + toEdge.x) / 2;
        const labelY = (fromEdge.y + toEdge.y) / 2;
        
        const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        labelGroup.classList.add('connection-label-group');
        
        const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        const displayLabel = conn.relation === 'custom' ? conn.customLabel : conn.relation;
        const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        labelText.setAttribute('x', labelX);
        labelText.setAttribute('y', labelY);
        labelText.setAttribute('text-anchor', 'middle');
        labelText.setAttribute('dominant-baseline', 'middle');
        labelText.setAttribute('class', 'connection-label');
        labelText.setAttribute('fill', color);
        labelText.textContent = displayLabel;
        
        svg.appendChild(labelText);
        const bbox = labelText.getBBox();
        svg.removeChild(labelText);
        
        labelBg.setAttribute('x', bbox.x - 4);
        labelBg.setAttribute('y', bbox.y - 2);
        labelBg.setAttribute('width', bbox.width + 8);
        labelBg.setAttribute('height', bbox.height + 4);
        labelBg.setAttribute('fill', 'white');
        labelBg.setAttribute('stroke', color);
        labelBg.setAttribute('stroke-width', '1');
        labelBg.setAttribute('rx', '3');
        
        labelGroup.appendChild(labelBg);
        labelGroup.appendChild(labelText);
        
        if (['sequence', 'cause', 'solution', 'contrast', 'description', 'source', 'custom'].includes(conn.relation)) {
            const dirBtn = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            dirBtn.setAttribute('x', labelX + bbox.width / 2 + 12);
            dirBtn.setAttribute('y', labelY);
            dirBtn.setAttribute('text-anchor', 'middle');
            dirBtn.setAttribute('dominant-baseline', 'middle');
            dirBtn.setAttribute('class', 'direction-btn');
            dirBtn.setAttribute('fill', 'white');
            dirBtn.textContent = '‚áÑ';
            dirBtn.style.cursor = 'pointer';
            
            const dirBtnBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            dirBtnBg.setAttribute('x', labelX + bbox.width / 2 + 5);
            dirBtnBg.setAttribute('y', labelY - 8);
            dirBtnBg.setAttribute('width', '16');
            dirBtnBg.setAttribute('height', '16');
            dirBtnBg.setAttribute('fill', color);
            dirBtnBg.setAttribute('rx', '3');
            dirBtnBg.style.cursor = 'pointer';
            
            const dirGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            dirGroup.appendChild(dirBtnBg);
            dirGroup.appendChild(dirBtn);
            dirGroup.addEventListener('click', function(e) {
                e.stopPropagation();
                reverseConnection(index);
            });
            
            labelGroup.appendChild(dirGroup);
        }
        
        labelGroup.addEventListener('click', function(e) {
            e.stopPropagation();
            editingConnectionIndex = index;
            pendingConnection = null;
            document.getElementById('dialogTitle').textContent = 'Edit Connection';
            document.getElementById('deleteConnectionBtn').style.display = 'block';
            
            const customInput = document.getElementById('customLabelInput');
            if (conn.relation === 'custom' && conn.customLabel) {
                customInput.value = conn.customLabel;
            } else {
                customInput.value = 'connection';
            }
            
            document.getElementById('dialogOverlay').classList.add('active');
        });
        
        svg.appendChild(labelGroup);
    });
}

function loadFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const textArea = getCurrentTextArea();
        if (textArea) {
            const plainText = e.target.result;
            const htmlContent = plainText
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>');
            
            textArea.innerHTML = htmlContent;
            
            const currentPage = getCurrentTextPage();
            if (currentPage) {
                currentPage.content = htmlContent;
            }
        }
    };
    reader.readAsText(file);
    
    event.target.value = '';
}

function clearText() {
    const textArea = getCurrentTextArea();
    if (textArea) {
        if (confirm('Are you sure you want to clear all text in this tab?')) {
            textArea.innerHTML = '';
            
            const currentPage = getCurrentTextPage();
            if (currentPage) {
                currentPage.content = '';
            }
        }
    }
}

window.addEventListener('resize', function() {
    updateCanvasSize();
    updateConnectionsOnly();
});

document.addEventListener('DOMContentLoaded', function() {
    const initialTextArea = document.querySelector('.text-area');
    if (initialTextArea) {
        setupTextAreaListeners(initialTextArea);
    }
    
    updateCanvasSize();
    updateFontSize();
});

    </script>
</body>
</html>